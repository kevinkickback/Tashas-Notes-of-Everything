/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

"use strict";
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __defNormalProp = (obj, key, value) => key in obj ? __defProp(obj, key, { enumerable: true, configurable: true, writable: true, value }) : obj[key] = value;
var __export = (target, all) => {
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __copyProps = (to, from, except, desc) => {
  if (from && typeof from === "object" || typeof from === "function") {
    for (let key of __getOwnPropNames(from))
      if (!__hasOwnProp.call(to, key) && key !== except)
        __defProp(to, key, { get: () => from[key], enumerable: !(desc = __getOwnPropDesc(from, key)) || desc.enumerable });
  }
  return to;
};
var __toCommonJS = (mod) => __copyProps(__defProp({}, "__esModule", { value: true }), mod);
var __publicField = (obj, key, value) => {
  __defNormalProp(obj, typeof key !== "symbol" ? key + "" : key, value);
  return value;
};

// src/main.ts
var main_exports = {};
__export(main_exports, {
  default: () => ModalFormPlugin
});
module.exports = __toCommonJS(main_exports);
var import_obsidian22 = require("obsidian");

// src/exampleModalDefinition.ts
var exampleModalDefinition = {
  title: "Example form",
  name: "example-form",
  version: "1",
  fields: [
    {
      name: "name",
      label: "Name",
      description: "It is named how?",
      isRequired: true,
      input: { type: "text" }
    },
    {
      name: "age",
      label: "Age",
      description: "How old",
      isRequired: true,
      input: { type: "number" }
    },
    {
      name: "dateOfBirth",
      label: "Date of Birth",
      description: "When were you born?",
      input: { type: "date" }
    },
    {
      name: "timeOfDay",
      label: "Time of day",
      description: "The time you can do this",
      input: { type: "time" }
    },
    {
      name: "is_family",
      label: "Is family",
      description: "If it is part of the family",
      input: { type: "toggle" }
    },
    {
      name: "favorite_book",
      label: "Favorite book",
      description: "Pick one",
      input: { type: "note", folder: "Books" }
    },
    {
      name: "folder",
      label: "The destination folder",
      description: "It offers auto-completion to existing folders",
      input: { type: "folder" }
    },
    {
      name: "multi_example",
      label: "Multi select folder",
      description: "Allows to pick many notes from a folder",
      input: { type: "multiselect", source: "notes", folder: "Books" }
    },
    {
      name: "multi_example_2",
      label: "Multi select fixed",
      description: "Allows to pick many notes from a fixed list",
      input: {
        type: "multiselect",
        source: "fixed",
        allowUnknownValues: false,
        multi_select_options: [
          "Android",
          "iOS",
          "Windows",
          "MacOS",
          "Linux",
          "Solaris",
          "MS2"
        ]
      }
    },
    {
      name: "multi_select_dataview",
      label: "Multi select dataview",
      description: "Allows to pick several values from a dv query",
      input: {
        type: "multiselect",
        source: "dataview",
        query: 'dv.pages("#person").map(p => p.file.name)',
        allowUnknownValues: true
      }
    },
    {
      name: "best_fried",
      label: "Best friend",
      description: "Select of type note from a folder",
      input: {
        type: "select",
        source: "notes",
        folder: "People"
      }
    },
    {
      name: "dataview_example",
      label: "Dataview example",
      description: "Only people matching the dataview query will be shown",
      input: {
        type: "dataview",
        query: 'dv.pages("#person").filter(p => p.age < 30).map(p => p.file.name)'
      }
    },
    {
      name: "friendship_level",
      label: "Friendship level",
      description: "How good friends are you?",
      input: {
        type: "slider",
        min: 0,
        max: 10
      }
    },
    {
      name: "favorite_meal",
      label: "Favorite meal",
      description: "Pick one option",
      input: {
        type: "select",
        source: "fixed",
        options: [
          { value: "pizza", label: "\u{1F355} Pizza" },
          { value: "pasta", label: "\u{1F35D} Pasta" },
          { value: "burger", label: "\u{1F354} Burger" },
          { value: "salad", label: "\u{1F957} Salad" },
          { value: "steak", label: "\u{1F969} Steak" },
          { value: "sushi", label: "\u{1F363} Sushi" },
          { value: "ramen", label: "\u{1F35C} Ramen" },
          { value: "tacos", label: "\u{1F32E} Tacos" },
          { value: "fish", label: "\u{1F41F} Fish" },
          { value: "chicken", label: "\u{1F357} Chicken" }
        ]
      }
    },
    {
      name: "some notes",
      label: "Multi line notes",
      description: "Put your thouhts here",
      input: {
        type: "textarea"
      }
    },
    {
      name: "Tags",
      description: "Tags input example",
      input: { type: "tag" }
    },
    {
      name: "document",
      description: "Document block example",
      input: {
        type: "document_block",
        body: "return `Hello ${form.name}!<br> Your best friend is <b>${form.best_fried}</b>`"
      }
    }
  ]
};

// src/ModalFormSettingTab.ts
var import_obsidian = require("obsidian");

// node_modules/valibot/dist/index.js
var ValiError = class extends Error {
  /**
   * Creates a Valibot error with useful information.
   *
   * @param issues The error issues.
   */
  constructor(issues) {
    super(issues[0].message);
    __publicField(this, "issues");
    this.name = "ValiError";
    this.issues = issues;
  }
};
var BrandSymbol = Symbol("brand");
function coerce(schema, action) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return schema._parse(action(input), info);
    }
  };
}
function getIssues(issues) {
  return { issues };
}
function getOutput(output) {
  return { output };
}
function getIssue(info, issue) {
  return {
    reason: info == null ? void 0 : info.reason,
    validation: issue.validation,
    origin: (info == null ? void 0 : info.origin) || "value",
    message: issue.message,
    input: issue.input,
    path: issue.path,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function getPipeInfo(info, reason) {
  return {
    reason,
    origin: info == null ? void 0 : info.origin,
    abortEarly: info == null ? void 0 : info.abortEarly,
    abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
    skipPipe: info == null ? void 0 : info.skipPipe
  };
}
function executePipe(input, pipe3, parseInfo, reason) {
  if (!pipe3 || !pipe3.length || (parseInfo == null ? void 0 : parseInfo.skipPipe)) {
    return getOutput(input);
  }
  let pipeInfo;
  let issues;
  let output = input;
  for (const action of pipe3) {
    const result = action(output);
    if (result.issues) {
      pipeInfo = pipeInfo || getPipeInfo(parseInfo, reason);
      for (const issueInfo of result.issues) {
        const issue = getIssue(pipeInfo, issueInfo);
        issues ? issues.push(issue) : issues = [issue];
      }
      if (pipeInfo.abortEarly || pipeInfo.abortPipeEarly) {
        break;
      }
    } else {
      output = result.output;
    }
  }
  return issues ? getIssues(issues) : getOutput(output);
}
function getDefaultArgs(arg1, arg2) {
  return Array.isArray(arg1) ? [void 0, arg1] : [arg1, arg2];
}
function getErrorMessage(error2) {
  return typeof error2 === "function" ? error2() : error2;
}
function getPipeIssues(validation, error2, input) {
  return getIssues([
    {
      validation,
      message: getErrorMessage(error2),
      input
    }
  ]);
}
function getSchemaIssues(info, reason, validation, error2, input, issues) {
  return {
    issues: [
      {
        reason,
        validation,
        origin: (info == null ? void 0 : info.origin) || "value",
        message: getErrorMessage(error2),
        input,
        issues,
        abortEarly: info == null ? void 0 : info.abortEarly,
        abortPipeEarly: info == null ? void 0 : info.abortPipeEarly,
        skipPipe: info == null ? void 0 : info.skipPipe
      }
    ]
  };
}
function is(schema, input) {
  return !schema._parse(input, { abortEarly: true }).issues;
}
function array(item2, arg2, arg3) {
  const [error2, pipe3] = getDefaultArgs(arg2, arg3);
  return {
    /**
     * The schema type.
     */
    schema: "array",
    /**
     * The array item schema.
     */
    array: { item: item2 },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!Array.isArray(input)) {
        return getSchemaIssues(
          info,
          "type",
          "array",
          error2 || "Invalid type",
          input
        );
      }
      let issues;
      const output = [];
      for (let key = 0; key < input.length; key++) {
        const value2 = input[key];
        const result = item2._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "array",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else {
          output.push(result.output);
        }
      }
      return issues ? getIssues(issues) : executePipe(output, pipe3, info, "array");
    }
  };
}
function boolean(arg1, arg2) {
  const [error2, pipe3] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "boolean",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "boolean") {
        return getSchemaIssues(
          info,
          "type",
          "boolean",
          error2 || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe3, info, "boolean");
    }
  };
}
function enumType(enumValue, error2) {
  return {
    /**
     * The schema type.
     */
    schema: "enum",
    /**
     * The enum value.
     */
    enum: enumValue,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!enumValue.includes(input)) {
        return getSchemaIssues(
          info,
          "type",
          "enum",
          error2 || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function literal(literal2, error2) {
  return {
    /**
     * The schema type.
     */
    schema: "literal",
    /**
     * The literal value.
     */
    literal: literal2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (input !== literal2) {
        return getSchemaIssues(
          info,
          "type",
          "literal",
          error2 || "Invalid type",
          input
        );
      }
      return getOutput(input);
    }
  };
}
function number(arg1, arg2) {
  const [error2, pipe3] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "number",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "number" || Number.isNaN(input)) {
        return getSchemaIssues(
          info,
          "type",
          "number",
          error2 || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe3, info, "number");
    }
  };
}
function object(object2, arg2, arg3) {
  const [error2, pipe3] = getDefaultArgs(arg2, arg3);
  let cachedEntries;
  return {
    /**
     * The schema type.
     */
    schema: "object",
    /**
     * The object schema.
     */
    object: object2,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (!input || typeof input !== "object") {
        return getSchemaIssues(
          info,
          "type",
          "object",
          error2 || "Invalid type",
          input
        );
      }
      cachedEntries = cachedEntries || Object.entries(object2);
      let issues;
      const output = {};
      for (const [key, schema] of cachedEntries) {
        const value2 = input[key];
        const result = schema._parse(value2, info);
        if (result.issues) {
          const pathItem = {
            schema: "object",
            input,
            key,
            value: value2
          };
          for (const issue of result.issues) {
            if (issue.path) {
              issue.path.unshift(pathItem);
            } else {
              issue.path = [pathItem];
            }
            issues == null ? void 0 : issues.push(issue);
          }
          if (!issues) {
            issues = result.issues;
          }
          if (info == null ? void 0 : info.abortEarly) {
            break;
          }
        } else if (result.output !== void 0 || key in input) {
          output[key] = result.output;
        }
      }
      return issues ? getIssues(issues) : executePipe(
        output,
        pipe3,
        info,
        "object"
      );
    }
  };
}
function optional(wrapped, default_) {
  return {
    /**
     * The schema type.
     */
    schema: "optional",
    /**
     * The wrapped schema.
     */
    wrapped,
    /**
     * The default value.
     */
    get default() {
      return typeof default_ === "function" ? default_() : default_;
    },
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const value2 = input === void 0 ? this.default : input;
      if (value2 === void 0) {
        return getOutput(value2);
      }
      return wrapped._parse(value2, info);
    }
  };
}
function string(arg1, arg2) {
  const [error2, pipe3] = getDefaultArgs(arg1, arg2);
  return {
    /**
     * The schema type.
     */
    schema: "string",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      if (typeof input !== "string") {
        return getSchemaIssues(
          info,
          "type",
          "string",
          error2 || "Invalid type",
          input
        );
      }
      return executePipe(input, pipe3, info, "string");
    }
  };
}
function union(union22, error2) {
  return {
    /**
     * The schema type.
     */
    schema: "union",
    /**
     * The union schema.
     */
    union: union22,
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      let issues;
      let output;
      for (const schema of union22) {
        const result = schema._parse(input, info);
        if (result.issues) {
          if (issues) {
            for (const issue of result.issues) {
              issues.push(issue);
            }
          } else {
            issues = result.issues;
          }
        } else {
          output = [result.output];
          break;
        }
      }
      return output ? getOutput(output[0]) : getSchemaIssues(
        info,
        "type",
        "union",
        error2 || "Invalid type",
        input,
        issues
      );
    }
  };
}
function unknown(pipe3 = []) {
  return {
    /**
     * The schema type.
     */
    schema: "unknown",
    /**
     * Whether it's async.
     */
    async: false,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      return executePipe(input, pipe3, info, "unknown");
    }
  };
}
function merge(schemas, arg2, arg3) {
  const [error2, pipe3] = getDefaultArgs(arg2, arg3);
  return object(
    schemas.reduce(
      (object2, schemas2) => ({ ...object2, ...schemas2.object }),
      {}
    ),
    error2,
    pipe3
  );
}
function parse(schema, input, info) {
  const result = schema._parse(input, info);
  if (result.issues) {
    throw new ValiError(result.issues);
  }
  return result.output;
}
function passthrough(schema) {
  return {
    ...schema,
    /**
     * Parses unknown input based on its schema.
     *
     * @param input The input to be parsed.
     * @param info The parse info.
     *
     * @returns The parsed output.
     */
    _parse(input, info) {
      const result = schema._parse(input, info);
      return !result.issues ? getOutput({ ...input, ...result.output }) : result;
    }
  };
}
function safeParse(schema, input, info) {
  const result = schema._parse(input, info);
  return result.issues ? {
    success: false,
    error: new ValiError(result.issues),
    issues: result.issues
  } : {
    success: true,
    data: result.output,
    output: result.output
  };
}
function toTrimmed() {
  return (input) => getOutput(input.trim());
}
function minLength(requirement, error2) {
  return (input) => input.length < requirement ? getPipeIssues("min_length", error2 || "Invalid length", input) : getOutput(input);
}

// node_modules/fp-ts/es6/function.js
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function identity(a) {
  return a;
}
function flow(ab, bc, cd, de, ef, fg, gh, hi, ij) {
  switch (arguments.length) {
    case 1:
      return ab;
    case 2:
      return function() {
        return bc(ab.apply(this, arguments));
      };
    case 3:
      return function() {
        return cd(bc(ab.apply(this, arguments)));
      };
    case 4:
      return function() {
        return de(cd(bc(ab.apply(this, arguments))));
      };
    case 5:
      return function() {
        return ef(de(cd(bc(ab.apply(this, arguments)))));
      };
    case 6:
      return function() {
        return fg(ef(de(cd(bc(ab.apply(this, arguments))))));
      };
    case 7:
      return function() {
        return gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))));
      };
    case 8:
      return function() {
        return hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments))))))));
      };
    case 9:
      return function() {
        return ij(hi(gh(fg(ef(de(cd(bc(ab.apply(this, arguments)))))))));
      };
  }
  return;
}
function absurd(_) {
  throw new Error("Called `absurd` function which should be uncallable");
}
function pipe(a, ab, bc, cd, de, ef, fg, gh, hi) {
  switch (arguments.length) {
    case 1:
      return a;
    case 2:
      return ab(a);
    case 3:
      return bc(ab(a));
    case 4:
      return cd(bc(ab(a)));
    case 5:
      return de(cd(bc(ab(a))));
    case 6:
      return ef(de(cd(bc(ab(a)))));
    case 7:
      return fg(ef(de(cd(bc(ab(a))))));
    case 8:
      return gh(fg(ef(de(cd(bc(ab(a)))))));
    case 9:
      return hi(gh(fg(ef(de(cd(bc(ab(a))))))));
    default: {
      var ret = arguments[0];
      for (var i = 1; i < arguments.length; i++) {
        ret = arguments[i](ret);
      }
      return ret;
    }
  }
}
var dual = function(arity, body) {
  var isDataFirst = typeof arity === "number" ? function(args) {
    return args.length >= arity;
  } : arity;
  return function() {
    var args = Array.from(arguments);
    if (isDataFirst(arguments)) {
      return body.apply(this, args);
    }
    return function(self) {
      return body.apply(void 0, __spreadArray([self], args, false));
    };
  };
};

// node_modules/fp-ts/es6/internal.js
var isSome = function(fa) {
  return fa._tag === "Some";
};
var none = { _tag: "None" };
var some = function(a) {
  return { _tag: "Some", value: a };
};
var isLeft = function(ma) {
  return ma._tag === "Left";
};
var isRight = function(ma) {
  return ma._tag === "Right";
};
var left = function(e) {
  return { _tag: "Left", left: e };
};
var right = function(a) {
  return { _tag: "Right", right: a };
};
var singleton = function(a) {
  return [a];
};
var isNonEmpty = function(as4) {
  return as4.length > 0;
};
var has = Object.prototype.hasOwnProperty;

// node_modules/fp-ts/es6/Functor.js
function flap(F) {
  return function(a) {
    return function(fab) {
      return F.map(fab, function(f) {
        return f(a);
      });
    };
  };
}
function as(F) {
  return function(self, b) {
    return F.map(self, function() {
      return b;
    });
  };
}
function asUnit(F) {
  var asM = as(F);
  return function(self) {
    return asM(self, void 0);
  };
}

// node_modules/fp-ts/es6/Chain.js
function tap(M) {
  return function(first2, f) {
    return M.chain(first2, function(a) {
      return M.map(f(a), function() {
        return a;
      });
    });
  };
}

// node_modules/fp-ts/es6/ChainRec.js
var tailRec = function(startWith, f) {
  var ab = f(startWith);
  while (ab._tag === "Left") {
    ab = f(ab.left);
  }
  return ab.right;
};

// node_modules/fp-ts/es6/FromEither.js
function fromEitherK(F) {
  return function(f) {
    return flow(f, F.fromEither);
  };
}
function tapEither(F, M) {
  var fromEither2 = fromEitherK(F);
  var tapM = tap(M);
  return function(self, f) {
    return tapM(self, fromEither2(f));
  };
}

// node_modules/fp-ts/es6/Separated.js
var separated = function(left4, right4) {
  return { left: left4, right: right4 };
};
var left2 = function(s) {
  return s.left;
};
var right2 = function(s) {
  return s.right;
};

// node_modules/fp-ts/es6/Either.js
var left3 = left;
var right3 = right;
var flatMap = /* @__PURE__ */ dual(2, function(ma, f) {
  return isLeft2(ma) ? ma : f(ma.right);
});
var _map = function(fa, f) {
  return pipe(fa, map(f));
};
var _ap = function(fab, fa) {
  return pipe(fab, ap(fa));
};
var URI = "Either";
var map = function(f) {
  return function(fa) {
    return isLeft2(fa) ? fa : right3(f(fa.right));
  };
};
var Functor = {
  URI,
  map: _map
};
var as2 = dual(2, as(Functor));
var asUnit2 = asUnit(Functor);
var of = right3;
var apW = function(fa) {
  return function(fab) {
    return isLeft2(fab) ? fab : isLeft2(fa) ? fa : right3(fab.right(fa.right));
  };
};
var ap = apW;
var Chain = {
  URI,
  map: _map,
  ap: _ap,
  chain: flatMap
};
var bimap = function(f, g) {
  return function(fa) {
    return isLeft2(fa) ? left3(f(fa.left)) : right3(g(fa.right));
  };
};
var mapLeft = function(f) {
  return function(fa) {
    return isLeft2(fa) ? left3(f(fa.left)) : fa;
  };
};
var FromEither = {
  URI,
  fromEither: identity
};
var isLeft2 = isLeft;
var isRight2 = isRight;
var matchW = function(onLeft, onRight) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : onRight(ma.right);
  };
};
var match = matchW;
var fold = match;
var getOrElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma.right;
  };
};
var getOrElse = getOrElseW;
var flap2 = /* @__PURE__ */ flap(Functor);
var tap2 = /* @__PURE__ */ dual(2, tap(Chain));
var _FromEither = {
  fromEither: FromEither.fromEither
};
var orElseW = function(onLeft) {
  return function(ma) {
    return isLeft2(ma) ? onLeft(ma.left) : ma;
  };
};
var orElse = orElseW;
var fromNullable = function(e) {
  return function(a) {
    return a == null ? left3(e) : right3(a);
  };
};
var tryCatch = function(f, onThrow) {
  try {
    return right3(f());
  } catch (e) {
    return left3(onThrow(e));
  }
};
var tryCatchK = function(f, onThrow) {
  return function() {
    var a = [];
    for (var _i = 0; _i < arguments.length; _i++) {
      a[_i] = arguments[_i];
    }
    return tryCatch(function() {
      return f.apply(void 0, a);
    }, onThrow);
  };
};
var chainW = flatMap;
var chain = flatMap;

// src/std/index.ts
var std_exports = {};
__export(std_exports, {
  A: () => A,
  E: () => E,
  EFunSemigroup: () => EFunSemigroup,
  NEA: () => NEA,
  O: () => O,
  absurd: () => absurd2,
  ensureError: () => ensureError,
  flow: () => flow2,
  parse: () => parse2,
  parseC: () => parseC,
  parseFunctionBody: () => parseFunctionBody,
  pipe: () => pipe2,
  tap: () => tap4,
  throttle: () => throttle,
  trySchemas: () => trySchemas
});

// node_modules/fp-ts/es6/Magma.js
var concatAll = function(M) {
  return function(startWith) {
    return function(as4) {
      return as4.reduce(function(a, acc) {
        return M.concat(a, acc);
      }, startWith);
    };
  };
};

// node_modules/fp-ts/es6/Semigroup.js
var constant = function(a) {
  return {
    concat: function() {
      return a;
    }
  };
};
var struct = function(semigroups) {
  return {
    concat: function(first2, second) {
      var r = {};
      for (var k in semigroups) {
        if (has.call(semigroups, k)) {
          r[k] = semigroups[k].concat(first2[k], second[k]);
        }
      }
      return r;
    }
  };
};
var first = function() {
  return { concat: identity };
};
var last = function() {
  return { concat: function(_, y) {
    return y;
  } };
};
var concatAll2 = concatAll;
var semigroupVoid = constant(void 0);
var semigroupAll = {
  concat: function(x, y) {
    return x && y;
  }
};
var semigroupAny = {
  concat: function(x, y) {
    return x || y;
  }
};
var semigroupString = {
  concat: function(x, y) {
    return x + y;
  }
};
var semigroupSum = {
  concat: function(x, y) {
    return x + y;
  }
};
var semigroupProduct = {
  concat: function(x, y) {
    return x * y;
  }
};

// node_modules/fp-ts/es6/ReadonlyNonEmptyArray.js
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty2 = isNonEmpty;
var isOutOfBound = function(i, as4) {
  return i < 0 || i >= as4.length;
};
var appendW = function(end) {
  return function(init4) {
    return __spreadArray2(__spreadArray2([], init4, true), [end], false);
  };
};
var append = appendW;
var of2 = singleton;

// node_modules/fp-ts/es6/NonEmptyArray.js
var __spreadArray3 = function(to, from, pack) {
  if (pack || arguments.length === 2)
    for (var i = 0, l = from.length, ar; i < l; i++) {
      if (ar || !(i in from)) {
        if (!ar)
          ar = Array.prototype.slice.call(from, 0, i);
        ar[i] = from[i];
      }
    }
  return to.concat(ar || Array.prototype.slice.call(from));
};
var isNonEmpty3 = function(as4) {
  return as4.length > 0;
};
var prependW = function(head5) {
  return function(tail4) {
    return __spreadArray3([head5], tail4, true);
  };
};
var prepend = prependW;
var appendW2 = function(end) {
  return function(init4) {
    return __spreadArray3(__spreadArray3([], init4, true), [end], false);
  };
};
var append2 = appendW2;
var fromArray = function(as4) {
  return isNonEmpty3(as4) ? some(as4) : none;
};
var of3 = function(a) {
  return [a];
};
var concatAll3 = function(S) {
  return function(as4) {
    return as4.reduce(S.concat);
  };
};

// node_modules/fp-ts/es6/ReadonlyArray.js
var append3 = append;
var isOutOfBound2 = isOutOfBound;
function lookup(i, as4) {
  return as4 === void 0 ? function(as5) {
    return lookup(i, as5);
  } : isOutOfBound2(i, as4) ? none : some(as4[i]);
}
function findFirst(predicate) {
  return function(as4) {
    for (var i = 0; i < as4.length; i++) {
      if (predicate(as4[i])) {
        return some(as4[i]);
      }
    }
    return none;
  };
}
var findFirstMap = function(f) {
  return function(as4) {
    for (var i = 0; i < as4.length; i++) {
      var out = f(as4[i]);
      if (isSome(out)) {
        return out;
      }
    }
    return none;
  };
};
var foldMapWithIndex = function(M) {
  return function(f) {
    return function(fa) {
      return fa.reduce(function(b, a, i) {
        return M.concat(b, f(i, a));
      }, M.empty);
    };
  };
};
var reduce = function(b, f) {
  return reduceWithIndex(b, function(_, b2, a) {
    return f(b2, a);
  });
};
var foldMap = function(M) {
  var foldMapWithIndexM = foldMapWithIndex(M);
  return function(f) {
    return foldMapWithIndexM(function(_, a) {
      return f(a);
    });
  };
};
var reduceWithIndex = function(b, f) {
  return function(fa) {
    var len = fa.length;
    var out = b;
    for (var i = 0; i < len; i++) {
      out = f(i, out, fa[i]);
    }
    return out;
  };
};
var reduceRight = function(b, f) {
  return reduceRightWithIndex(b, function(_, a, b2) {
    return f(a, b2);
  });
};
var reduceRightWithIndex = function(b, f) {
  return function(fa) {
    return fa.reduceRight(function(b2, a, i) {
      return f(i, a, b2);
    }, b);
  };
};

// node_modules/fp-ts/es6/Array.js
var prepend3 = prepend;
var append4 = append2;
var chainWithIndex = function(f) {
  return function(as4) {
    var out = [];
    for (var i = 0; i < as4.length; i++) {
      out.push.apply(out, f(i, as4[i]));
    }
    return out;
  };
};
var lookup2 = lookup;
function findFirst2(predicate) {
  return findFirst(predicate);
}
var findFirstMap2 = findFirstMap;
var _reduce = function(fa, b, f) {
  return pipe(fa, reduce2(b, f));
};
var _foldMap = function(M) {
  var foldMapM = foldMap2(M);
  return function(fa, f) {
    return pipe(fa, foldMapM(f));
  };
};
var _reduceRight = function(fa, b, f) {
  return pipe(fa, reduceRight2(b, f));
};
var map2 = function(f) {
  return function(fa) {
    return fa.map(function(a) {
      return f(a);
    });
  };
};
var flatMap2 = /* @__PURE__ */ dual(2, function(ma, f) {
  return pipe(ma, chainWithIndex(function(i, a) {
    return f(a, i);
  }));
});
var flatten = /* @__PURE__ */ flatMap2(identity);
var filterMapWithIndex = function(f) {
  return function(fa) {
    var out = [];
    for (var i = 0; i < fa.length; i++) {
      var optionB = f(i, fa[i]);
      if (isSome(optionB)) {
        out.push(optionB.value);
      }
    }
    return out;
  };
};
var filterMap = function(f) {
  return filterMapWithIndex(function(_, a) {
    return f(a);
  });
};
var compact = /* @__PURE__ */ filterMap(identity);
var separate = function(fa) {
  var left4 = [];
  var right4 = [];
  for (var _i = 0, fa_1 = fa; _i < fa_1.length; _i++) {
    var e = fa_1[_i];
    if (e._tag === "Left") {
      left4.push(e.left);
    } else {
      right4.push(e.right);
    }
  }
  return separated(left4, right4);
};
var filter = function(predicate) {
  return function(as4) {
    return as4.filter(predicate);
  };
};
var partition = function(predicate) {
  return partitionWithIndex(function(_, a) {
    return predicate(a);
  });
};
var partitionWithIndex = function(predicateWithIndex) {
  return function(as4) {
    var left4 = [];
    var right4 = [];
    for (var i = 0; i < as4.length; i++) {
      var b = as4[i];
      if (predicateWithIndex(i, b)) {
        right4.push(b);
      } else {
        left4.push(b);
      }
    }
    return separated(left4, right4);
  };
};
var partitionMap = function(f) {
  return partitionMapWithIndex(function(_, a) {
    return f(a);
  });
};
var partitionMapWithIndex = function(f) {
  return function(fa) {
    var left4 = [];
    var right4 = [];
    for (var i = 0; i < fa.length; i++) {
      var e = f(i, fa[i]);
      if (e._tag === "Left") {
        left4.push(e.left);
      } else {
        right4.push(e.right);
      }
    }
    return separated(left4, right4);
  };
};
var foldMap2 = foldMap;
var reduce2 = reduce;
var reduceRight2 = reduceRight;
var URI2 = "Array";
var getSemigroup2 = function() {
  return {
    concat: function(first2, second) {
      return first2.concat(second);
    }
  };
};
var getMonoid = function() {
  return {
    concat: getSemigroup2().concat,
    empty: []
  };
};
var Foldable = {
  URI: URI2,
  reduce: _reduce,
  foldMap: _foldMap,
  reduceRight: _reduceRight
};
var some2 = function(predicate) {
  return function(as4) {
    return as4.some(predicate);
  };
};

// node_modules/fp-ts/es6/Predicate.js
var not = function(predicate) {
  return function(a) {
    return !predicate(a);
  };
};

// node_modules/fp-ts/es6/Option.js
var none2 = none;
var some3 = some;
function fromPredicate(predicate) {
  return function(a) {
    return predicate(a) ? some3(a) : none2;
  };
}
var getRight = function(ma) {
  return ma._tag === "Left" ? none2 : some3(ma.right);
};
var _map2 = function(fa, f) {
  return pipe(fa, map3(f));
};
var _ap2 = function(fab, fa) {
  return pipe(fab, ap2(fa));
};
var URI3 = "Option";
var map3 = function(f) {
  return function(fa) {
    return isNone2(fa) ? none2 : some3(f(fa.value));
  };
};
var Functor2 = {
  URI: URI3,
  map: _map2
};
var as3 = dual(2, as(Functor2));
var asUnit3 = asUnit(Functor2);
var ap2 = function(fa) {
  return function(fab) {
    return isNone2(fab) ? none2 : isNone2(fa) ? none2 : some3(fab.value(fa.value));
  };
};
var flatMap3 = /* @__PURE__ */ dual(2, function(ma, f) {
  return isNone2(ma) ? none2 : f(ma.value);
});
var Chain2 = {
  URI: URI3,
  map: _map2,
  ap: _ap2,
  chain: flatMap3
};
var orElse2 = dual(2, function(self, that) {
  return isNone2(self) ? that() : self;
});
var alt = orElse2;
var fromEither = getRight;
var FromEither2 = {
  URI: URI3,
  fromEither
};
var isSome2 = isSome;
var isNone2 = function(fa) {
  return fa._tag === "None";
};
var matchW2 = function(onNone, onSome) {
  return function(ma) {
    return isNone2(ma) ? onNone() : onSome(ma.value);
  };
};
var match2 = matchW2;
var fold2 = match2;
var getOrElseW2 = function(onNone) {
  return function(ma) {
    return isNone2(ma) ? onNone() : ma.value;
  };
};
var getOrElse2 = getOrElseW2;
var tap3 = /* @__PURE__ */ dual(2, tap(Chain2));
var tapEither2 = /* @__PURE__ */ dual(2, tapEither(FromEither2, Chain2));
var fromNullable2 = function(a) {
  return a == null ? none2 : some3(a);
};
var chain2 = flatMap3;

// src/std/index.ts
var flow2 = flow;
var pipe2 = pipe;
var absurd2 = absurd;
var A = {
  partitionMap,
  partition,
  compact,
  findFirst: findFirst2,
  findFirstMap: findFirstMap2,
  map: map2,
  filter,
  filterMap,
  flatten
};
var NEA = {
  concatAll: concatAll3
};
var E = {
  isLeft: isLeft2,
  isRight: isRight2,
  left: left3,
  right: right3,
  tryCatchK,
  tryCatch,
  getOrElse,
  map,
  mapLeft,
  bimap,
  flatMap,
  fromNullable,
  match,
  ap,
  flap: flap2,
  chainW,
  fold: match
};
var O = {
  map: map3,
  getOrElse: getOrElse2,
  some: some3,
  none: none2,
  fold: fold2,
  fromNullable: fromNullable2,
  chain: chain2,
  fromPredicate,
  isNone: isNone2,
  isSome: isSome2,
  alt,
  match: match2
};
var parse2 = tryCatchK(parse, (e) => e);
function parseC(schema, options) {
  return (input, moreOptions) => parse2(schema, input, { ...options, ...moreOptions });
}
var _EFunSemigroup = class {
  concat(f, g) {
    return (i) => {
      const fRes = f(i);
      if (isRight2(fRes))
        return fRes;
      return g(i);
    };
  }
};
var EFunSemigroup = new _EFunSemigroup();
function trySchemas(schemas, options) {
  const [first2, ...rest] = schemas;
  return pipe2(
    rest,
    A.map((schema) => parseC(schema, options)),
    concatAll2(EFunSemigroup)(parseC(first2, options))
  );
}
function throttle(fn, ms = 100) {
  let lastCall = 0;
  let lastResult;
  return function(...args) {
    const now2 = Date.now();
    if (now2 - lastCall > ms) {
      lastResult = fn(...args);
    }
    lastCall = now2;
    return lastResult;
  };
}
function tap4(msg) {
  return (x) => {
    console.log(msg, x);
    return x;
  };
}
function ensureError(e) {
  return e instanceof Error ? e : new Error(String(e));
}
function parseFunctionBody(body, ...args) {
  const fnBody = `"use strict";
${body}`;
  try {
    const fn = new Function(...args, fnBody);
    return right3(tryCatchK(fn, ensureError));
  } catch (e) {
    return left3(ensureError(e));
  }
}

// src/core/settings.ts
var OpenPositionSchema = enumType(["left", "right", "mainView"]);
function isValidOpenPosition(position) {
  return is(OpenPositionSchema, position);
}
var ModalFormSettingsSchema = object({
  editorPosition: optional(OpenPositionSchema, "right"),
  attachShortcutToGlobalWindow: optional(boolean(), false),
  globalNamespace: optional(enumType(["MF", "ModalForm"]), "MF"),
  formDefinitions: array(unknown())
});
function getDefaultSettings() {
  return {
    editorPosition: "right",
    attachShortcutToGlobalWindow: false,
    globalNamespace: "MF",
    formDefinitions: []
  };
}
var NullSettingsError = class {
  constructor() {
    this._tag = "NullSettingsError";
  }
};
function parseSettings(maybeSettings) {
  return pipe2(
    maybeSettings,
    fromNullable(new NullSettingsError()),
    chainW((s) => parse2(ModalFormSettingsSchema, { ...getDefaultSettings(), ...s }))
  );
}

// src/ModalFormSettingTab.ts
var ModalFormSettingTab = class extends import_obsidian.PluginSettingTab {
  constructor(app2, plugin) {
    super(app2, plugin);
    this.plugin = plugin;
  }
  async display() {
    const { containerEl, plugin } = this;
    containerEl.empty();
    containerEl.createEl("a", { text: "Modal Form documentation", cls: "nav-link", href: "https://github.com/danielo515/obsidian-modal-form" });
    const settings2 = await plugin.getSettings();
    new import_obsidian.Setting(containerEl).setName("Editor position").setDesc("Where the form editor will be opened. In mobile it will always be main view.").addDropdown((component) => {
      component.addOptions({
        left: "Left",
        right: "Right",
        mainView: "Main View"
      }).setValue(settings2.editorPosition).onChange(async (value) => {
        if (isValidOpenPosition(value)) {
          await this.plugin.setEditorPosition(value);
        }
      });
    });
    new import_obsidian.Setting(containerEl).setName("Attach Modal-Form Shortcut to Global Window").setDesc("Enable or disable attaching a modal-form shortcut to the global window. If you enable this you will be able to access the API using the global variable `MF`. Enabling is immediate, disabling requires a restart.").addToggle((component) => {
      component.setValue(settings2.attachShortcutToGlobalWindow).onChange(async (value) => {
        await this.plugin.setAttachShortcutToGlobalWindow(value);
      });
    });
  }
};

// src/API.ts
var import_obsidian10 = require("obsidian");

// src/core/InputDefinitionSchema.ts
function nonEmptyString(name) {
  return string(`${name} should be a string`, [
    toTrimmed(),
    minLength(1, `${name} should not be empty`)
  ]);
}
var InputBasicTypeSchema = enumType([
  "text",
  "number",
  "date",
  "time",
  "datetime",
  "textarea",
  "toggle",
  "email",
  "tel"
]);
var SelectFromNotesSchema = object({
  type: literal("select"),
  source: literal("notes"),
  folder: nonEmptyString("folder name")
});
var InputTagSchema = object({
  type: literal("tag"),
  exclude: optional(string())
  // This should be a regex string
});
var InputSliderSchema = object({
  type: literal("slider"),
  min: number(),
  max: number()
});
var InputNoteFromFolderSchema = object({
  type: literal("note"),
  folder: nonEmptyString("folder name")
});
var InputFolderSchema = object({
  type: literal("folder")
  // TODO: allow exclude option
});
var InputDataviewSourceSchema = object({
  type: literal("dataview"),
  query: nonEmptyString("dataview query")
});
var InputBasicSchema = object({ type: InputBasicTypeSchema });
var InputSelectFixedSchema = object({
  type: literal("select"),
  source: literal("fixed"),
  options: array(
    object({
      value: string([toTrimmed()]),
      label: string()
    })
  )
});
var MultiSelectNotesSchema = object({
  type: literal("multiselect"),
  source: literal("notes"),
  folder: nonEmptyString("multi select source folder")
});
var MultiSelectFixedSchema = object({
  type: literal("multiselect"),
  source: literal("fixed"),
  multi_select_options: array(string()),
  allowUnknownValues: optional(boolean(), false)
});
var MultiSelectQuerySchema = object({
  type: literal("multiselect"),
  source: literal("dataview"),
  query: nonEmptyString("dataview query"),
  allowUnknownValues: optional(boolean(), false)
});
function canAllowUnknownValues(type, source) {
  return type === "multiselect" && (source === "dataview" || source === "fixed");
}
var MultiselectSchema = union([
  MultiSelectNotesSchema,
  MultiSelectFixedSchema,
  MultiSelectQuerySchema
]);
var DocumentBlock = object({
  type: literal("document_block"),
  body: string()
});
var InputTypeSchema = union([
  InputBasicSchema,
  InputNoteFromFolderSchema,
  InputFolderSchema,
  InputSliderSchema,
  InputTagSchema,
  SelectFromNotesSchema,
  InputDataviewSourceSchema,
  InputSelectFixedSchema,
  MultiselectSchema,
  DocumentBlock
]);
var InputTypeToParserMap = {
  number: parseC(InputBasicSchema),
  text: parseC(InputBasicSchema),
  email: parseC(InputBasicSchema),
  tel: parseC(InputBasicSchema),
  date: parseC(InputBasicSchema),
  time: parseC(InputBasicSchema),
  datetime: parseC(InputBasicSchema),
  textarea: parseC(InputBasicSchema),
  toggle: parseC(InputBasicSchema),
  note: parseC(InputNoteFromFolderSchema),
  folder: parseC(InputFolderSchema),
  slider: parseC(InputSliderSchema),
  tag: parseC(InputTagSchema),
  select: trySchemas([SelectFromNotesSchema, InputSelectFixedSchema]),
  dataview: parseC(InputDataviewSourceSchema),
  multiselect: parseC(MultiselectSchema),
  document_block: parseC(DocumentBlock)
};

// src/core/findInputDefinitionSchema.ts
function stringifyIssues(error2) {
  return error2.issues.map(
    (issue) => {
      var _a;
      return `${(_a = issue.path) == null ? void 0 : _a.map((i) => i.key).join(".")}: ${issue.message} got ${issue.input}`;
    }
  );
}
var InvalidInputTypeError = class {
  constructor(field, inputType2) {
    this.field = field;
    this.inputType = inputType2;
    this.path = "input.type";
  }
  toString() {
    return `InvalidInputTypeError: ${this.getFieldErrors()[0]}`;
  }
  getFieldErrors() {
    return [`"input.type" is invalid, got: ${JSON.stringify(this.inputType)}`];
  }
};
InvalidInputTypeError._tag = "InvalidInputTypeError";
var InvalidInputError = class {
  constructor(field, error2) {
    this.field = field;
    this.error = error2;
    var _a, _b;
    this.path = (_b = (_a = error2.issues[0].path) == null ? void 0 : _a.map((i) => i.key).join(".")) != null ? _b : "";
  }
  toString() {
    return `InvalidInputError: ${stringifyIssues(this.error).join(", ")}`;
  }
  getFieldErrors() {
    return stringifyIssues(this.error);
  }
};
InvalidInputError._tag = "InvalidInputError";
var _InvalidFieldError = class {
  constructor(field, error2) {
    this.field = field;
    this.error = error2;
    var _a, _b;
    this.path = (_b = (_a = error2.issues[0].path) == null ? void 0 : _a.map((i) => i.key).join(".")) != null ? _b : "";
  }
  toString() {
    return `InvalidFieldError: ${stringifyIssues(this.error).join(", ")}`;
  }
  toArrayOfStrings() {
    return this.getFieldErrors();
  }
  getFieldErrors() {
    return stringifyIssues(this.error);
  }
  static of(field) {
    return (error2) => new _InvalidFieldError(field, error2);
  }
};
var InvalidFieldError = _InvalidFieldError;
InvalidFieldError._tag = "InvalidFieldError";
function isValidInputType(input) {
  return "string" === typeof input && input in InputTypeToParserMap;
}
function findInputDefinitionSchema(fieldDefinition) {
  return pipe2(
    parse2(FieldMinimalSchema, fieldDefinition),
    mapLeft(InvalidFieldError.of(fieldDefinition)),
    chainW((field) => {
      const type = field.input.type;
      if (isValidInputType(type))
        return right3([field, InputTypeToParserMap[type]]);
      else
        return left3(new InvalidInputTypeError(field, type));
    })
  );
}
function findFieldErrors(fields) {
  return pipe2(
    fields,
    A.partitionMap((fieldUnparsed) => {
      return pipe2(
        findInputDefinitionSchema(fieldUnparsed),
        chainW(
          ([field, parser]) => pipe2(
            parser(field.input),
            bimap(
              (error2) => new InvalidInputError(field, error2),
              () => field
            )
          )
        )
      );
    })
    // Separated.left,
  );
}

// src/core/template/templateSchema.ts
var TemplateTextSchema = object({
  _tag: literal("text"),
  value: string()
});
var TemplateVariableSchema = object({
  _tag: literal("variable"),
  value: string()
});
var FrontmatterCommandSchema = object({
  _tag: literal("frontmatter-command"),
  pick: array(string()),
  omit: array(string())
});
var ParsedTemplateSchema = array(union([TemplateTextSchema, TemplateVariableSchema, FrontmatterCommandSchema]));

// src/core/formDefinitionSchema.ts
var FieldDefinitionSchema = object({
  name: nonEmptyString("field name"),
  label: optional(string()),
  description: string(),
  isRequired: optional(boolean()),
  input: InputTypeSchema
});
var FieldMinimalSchema = passthrough(
  merge([FieldDefinitionSchema, object({ input: passthrough(object({ type: string() })) })])
);
var FieldListSchema = array(FieldDefinitionSchema);
var FormDefinitionBasicSchema = object({
  title: nonEmptyString("form title"),
  name: nonEmptyString("form name"),
  customClassname: optional(string()),
  fields: array(unknown())
});
var FormDefinitionV1Schema = merge([
  FormDefinitionBasicSchema,
  object({
    version: literal("1"),
    fields: FieldListSchema,
    template: optional(
      object({
        createCommand: boolean(),
        parsedTemplate: ParsedTemplateSchema
      })
    )
  })
]);
var FormDefinitionLatestSchema = FormDefinitionV1Schema;
var MigrationError = class {
  constructor(form, error2) {
    this.form = form;
    this.error = error2;
    this.name = form.name;
  }
  toString() {
    return `MigrationError: 
            ${this.error.message}
            ${this.error.issues.map((issue) => issue.message).join(", ")}`;
  }
  toArrayOfStrings() {
    return stringifyIssues(this.error);
  }
  // This allows to store the error in the settings, along with the rest of the forms and
  // have save all the data in one go transparently.
  // This is required so we don't lose the form, even if it is invalid
  toJSON() {
    return this.form;
  }
  get fieldErrors() {
    return findFieldErrors(this.form.fields);
  }
};
MigrationError._tag = "MigrationError";
var InvalidData = class {
  constructor(data, error2) {
    this.data = data;
    this.error = error2;
  }
  toString() {
    return `InvalidData: ${stringifyIssues(this.error).join(", ")}`;
  }
  toArrayOfStrings() {
    return stringifyIssues(this.error);
  }
};
InvalidData._tag = "InvalidData";
function fromV0toV1(data) {
  return pipe2(
    parse2(FormDefinitionV1Schema, { ...data, version: "1" }),
    getOrElseW((error2) => new MigrationError(data, error2))
  );
}
function migrateToLatest(data) {
  return pipe2(
    // first try a quick one with the latest schema
    parse2(FormDefinitionLatestSchema, data, { abortEarly: true }),
    orElse(
      () => pipe2(
        parse2(FormDefinitionBasicSchema, data, { abortEarly: false }),
        mapLeft((error2) => new InvalidData(data, error2)),
        map(fromV0toV1)
      )
    )
  );
}
function formNeedsMigration(data) {
  return !is(FormDefinitionLatestSchema, data);
}

// src/utils/ModalFormError.ts
var ModalFormError = class extends Error {
  constructor(msg, console_msg) {
    super(msg);
    this.console_msg = console_msg;
    this.name = this.constructor.name;
    Error.captureStackTrace(this, this.constructor);
  }
};

// src/FormModal.ts
var import_obsidian9 = require("obsidian");

// node_modules/fp-ts/es6/string.js
var Eq = {
  equals: function(first2, second) {
    return first2 === second;
  }
};
var Semigroup2 = {
  concat: function(first2, second) {
    return first2 + second;
  }
};
var empty2 = "";
var Monoid = {
  concat: Semigroup2.concat,
  empty: empty2
};
var Ord = {
  equals: Eq.equals,
  compare: function(first2, second) {
    return first2 < second ? -1 : first2 > second ? 1 : 0;
  }
};
var isString = function(u) {
  return typeof u === "string";
};
var trim = function(s) {
  return s.trim();
};
var split = function(separator) {
  return function(s) {
    var out = s.split(separator);
    return isNonEmpty2(out) ? out : [s];
  };
};

// node_modules/fp-ts/es6/ReadonlyRecord.js
function filterMapWithIndex2(f) {
  return function(r) {
    var out = {};
    for (var k in r) {
      if (has.call(r, k)) {
        var ob = f(k, r[k]);
        if (isSome(ob)) {
          out[k] = ob.value;
        }
      }
    }
    return out;
  };
}
function filterWithIndex(predicateWithIndex) {
  return function(fa) {
    var out = {};
    var changed = false;
    for (var key in fa) {
      if (has.call(fa, key)) {
        var a = fa[key];
        if (predicateWithIndex(key, a)) {
          out[key] = a;
        } else {
          changed = true;
        }
      }
    }
    return changed ? out : fa;
  };
}
function fromFoldable(M, F) {
  var fromFoldableMapM = fromFoldableMap(M, F);
  return function(fka) {
    return fromFoldableMapM(fka, identity);
  };
}
function fromFoldableMap(M, F) {
  return function(ta, f) {
    return F.reduce(ta, {}, function(r, a) {
      var _a = f(a), k = _a[0], b = _a[1];
      r[k] = has.call(r, k) ? M.concat(r[k], b) : b;
      return r;
    });
  };
}
var filterMap2 = function(f) {
  return filterMapWithIndex2(function(_, a) {
    return f(a);
  });
};

// node_modules/fp-ts/es6/Record.js
var keys_ = function(O2) {
  return function(r) {
    return Object.keys(r).sort(O2.compare);
  };
};
function collect(O2) {
  if (typeof O2 === "function") {
    return collect(Ord)(O2);
  }
  var keysO = keys_(O2);
  return function(f) {
    return function(r) {
      var out = [];
      for (var _i = 0, _a = keysO(r); _i < _a.length; _i++) {
        var key = _a[_i];
        out.push(f(key, r[key]));
      }
      return out;
    };
  };
}
var toArray = /* @__PURE__ */ collect(Ord)(function(k, a) {
  return [
    k,
    a
  ];
});
var filterMapWithIndex3 = filterMapWithIndex2;
function filterWithIndex2(predicateWithIndex) {
  return filterWithIndex(predicateWithIndex);
}
function fromFoldable2(M, F) {
  return fromFoldable(M, F);
}
var toEntries = toArray;
var fromEntries = function(fa) {
  return fromFoldable2(last(), Foldable)(fa);
};
var filterMap3 = filterMap2;

// node_modules/svelte/src/runtime/internal/utils.js
function noop() {
}
function assign(tar, src) {
  for (const k in src)
    tar[k] = src[k];
  return (
    /** @type {T & S} */
    tar
  );
}
function run(fn) {
  return fn();
}
function blank_object() {
  return /* @__PURE__ */ Object.create(null);
}
function run_all(fns) {
  fns.forEach(run);
}
function is_function(thing) {
  return typeof thing === "function";
}
function safe_not_equal(a, b) {
  return a != a ? b == b : a !== b || a && typeof a === "object" || typeof a === "function";
}
function is_empty(obj) {
  return Object.keys(obj).length === 0;
}
function subscribe(store, ...callbacks) {
  if (store == null) {
    for (const callback of callbacks) {
      callback(void 0);
    }
    return noop;
  }
  const unsub = store.subscribe(...callbacks);
  return unsub.unsubscribe ? () => unsub.unsubscribe() : unsub;
}
function get_store_value(store) {
  let value;
  subscribe(store, (_) => value = _)();
  return value;
}
function component_subscribe(component, store, callback) {
  component.$$.on_destroy.push(subscribe(store, callback));
}
function create_slot(definition, ctx, $$scope, fn) {
  if (definition) {
    const slot_ctx = get_slot_context(definition, ctx, $$scope, fn);
    return definition[0](slot_ctx);
  }
}
function get_slot_context(definition, ctx, $$scope, fn) {
  return definition[1] && fn ? assign($$scope.ctx.slice(), definition[1](fn(ctx))) : $$scope.ctx;
}
function get_slot_changes(definition, $$scope, dirty, fn) {
  if (definition[2] && fn) {
    const lets = definition[2](fn(dirty));
    if ($$scope.dirty === void 0) {
      return lets;
    }
    if (typeof lets === "object") {
      const merged = [];
      const len = Math.max($$scope.dirty.length, lets.length);
      for (let i = 0; i < len; i += 1) {
        merged[i] = $$scope.dirty[i] | lets[i];
      }
      return merged;
    }
    return $$scope.dirty | lets;
  }
  return $$scope.dirty;
}
function update_slot_base(slot, slot_definition, ctx, $$scope, slot_changes, get_slot_context_fn) {
  if (slot_changes) {
    const slot_context = get_slot_context(slot_definition, ctx, $$scope, get_slot_context_fn);
    slot.p(slot_context, slot_changes);
  }
}
function get_all_dirty_from_scope($$scope) {
  if ($$scope.ctx.length > 32) {
    const dirty = [];
    const length = $$scope.ctx.length / 32;
    for (let i = 0; i < length; i++) {
      dirty[i] = -1;
    }
    return dirty;
  }
  return -1;
}
function action_destroyer(action_result) {
  return action_result && is_function(action_result.destroy) ? action_result.destroy : noop;
}

// node_modules/svelte/src/runtime/internal/globals.js
var globals = typeof window !== "undefined" ? window : typeof globalThis !== "undefined" ? globalThis : (
  // @ts-ignore Node typings have this
  global
);

// node_modules/svelte/src/runtime/internal/ResizeObserverSingleton.js
var ResizeObserverSingleton = class {
  /** @param {ResizeObserverOptions} options */
  constructor(options) {
    /**
     * @private
     * @readonly
     * @type {WeakMap<Element, import('./private.js').Listener>}
     */
    __publicField(this, "_listeners", "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0);
    /**
     * @private
     * @type {ResizeObserver}
     */
    __publicField(this, "_observer");
    /** @type {ResizeObserverOptions} */
    __publicField(this, "options");
    this.options = options;
  }
  /**
   * @param {Element} element
   * @param {import('./private.js').Listener} listener
   * @returns {() => void}
   */
  observe(element2, listener) {
    this._listeners.set(element2, listener);
    this._getObserver().observe(element2, this.options);
    return () => {
      this._listeners.delete(element2);
      this._observer.unobserve(element2);
    };
  }
  /**
   * @private
   */
  _getObserver() {
    var _a;
    return (_a = this._observer) != null ? _a : this._observer = new ResizeObserver((entries) => {
      var _a2;
      for (const entry of entries) {
        ResizeObserverSingleton.entries.set(entry.target, entry);
        (_a2 = this._listeners.get(entry.target)) == null ? void 0 : _a2(entry);
      }
    });
  }
};
ResizeObserverSingleton.entries = "WeakMap" in globals ? /* @__PURE__ */ new WeakMap() : void 0;

// node_modules/svelte/src/runtime/internal/dom.js
var is_hydrating = false;
function start_hydrating() {
  is_hydrating = true;
}
function end_hydrating() {
  is_hydrating = false;
}
function append5(target, node) {
  target.appendChild(node);
}
function append_styles(target, style_sheet_id, styles) {
  const append_styles_to = get_root_for_style(target);
  if (!append_styles_to.getElementById(style_sheet_id)) {
    const style = element("style");
    style.id = style_sheet_id;
    style.textContent = styles;
    append_stylesheet(append_styles_to, style);
  }
}
function get_root_for_style(node) {
  if (!node)
    return document;
  const root = node.getRootNode ? node.getRootNode() : node.ownerDocument;
  if (root && /** @type {ShadowRoot} */
  root.host) {
    return (
      /** @type {ShadowRoot} */
      root
    );
  }
  return node.ownerDocument;
}
function append_stylesheet(node, style) {
  append5(
    /** @type {Document} */
    node.head || node,
    style
  );
  return style.sheet;
}
function insert(target, node, anchor) {
  target.insertBefore(node, anchor || null);
}
function detach(node) {
  if (node.parentNode) {
    node.parentNode.removeChild(node);
  }
}
function destroy_each(iterations, detaching) {
  for (let i = 0; i < iterations.length; i += 1) {
    if (iterations[i])
      iterations[i].d(detaching);
  }
}
function element(name) {
  return document.createElement(name);
}
function text(data) {
  return document.createTextNode(data);
}
function space() {
  return text(" ");
}
function empty3() {
  return text("");
}
function listen(node, event, handler, options) {
  node.addEventListener(event, handler, options);
  return () => node.removeEventListener(event, handler, options);
}
function prevent_default(fn) {
  return function(event) {
    event.preventDefault();
    return fn.call(this, event);
  };
}
function attr(node, attribute, value) {
  if (value == null)
    node.removeAttribute(attribute);
  else if (node.getAttribute(attribute) !== value)
    node.setAttribute(attribute, value);
}
function to_number(value) {
  return value === "" ? null : +value;
}
function children(element2) {
  return Array.from(element2.childNodes);
}
function set_data(text3, data) {
  data = "" + data;
  if (text3.data === data)
    return;
  text3.data = /** @type {string} */
  data;
}
function set_input_value(input, value) {
  input.value = value == null ? "" : value;
}
function set_style(node, key, value, important) {
  if (value == null) {
    node.style.removeProperty(key);
  } else {
    node.style.setProperty(key, value, important ? "important" : "");
  }
}
function select_option(select, value, mounting) {
  for (let i = 0; i < select.options.length; i += 1) {
    const option = select.options[i];
    if (option.__value === value) {
      option.selected = true;
      return;
    }
  }
  if (!mounting || value !== void 0) {
    select.selectedIndex = -1;
  }
}
function select_value(select) {
  const selected_option = select.querySelector(":checked");
  return selected_option && selected_option.__value;
}
function toggle_class(element2, name, toggle) {
  element2.classList.toggle(name, !!toggle);
}
function get_custom_elements_slots(element2) {
  const result = {};
  element2.childNodes.forEach(
    /** @param {Element} node */
    (node) => {
      result[node.slot || "default"] = true;
    }
  );
  return result;
}

// node_modules/svelte/src/runtime/internal/lifecycle.js
var current_component;
function set_current_component(component) {
  current_component = component;
}
function get_current_component() {
  if (!current_component)
    throw new Error("Function called outside component initialization");
  return current_component;
}
function onMount(fn) {
  get_current_component().$$.on_mount.push(fn);
}

// node_modules/svelte/src/runtime/internal/scheduler.js
var dirty_components = [];
var binding_callbacks = [];
var render_callbacks = [];
var flush_callbacks = [];
var resolved_promise = /* @__PURE__ */ Promise.resolve();
var update_scheduled = false;
function schedule_update() {
  if (!update_scheduled) {
    update_scheduled = true;
    resolved_promise.then(flush);
  }
}
function add_render_callback(fn) {
  render_callbacks.push(fn);
}
function add_flush_callback(fn) {
  flush_callbacks.push(fn);
}
var seen_callbacks = /* @__PURE__ */ new Set();
var flushidx = 0;
function flush() {
  if (flushidx !== 0) {
    return;
  }
  const saved_component = current_component;
  do {
    try {
      while (flushidx < dirty_components.length) {
        const component = dirty_components[flushidx];
        flushidx++;
        set_current_component(component);
        update(component.$$);
      }
    } catch (e) {
      dirty_components.length = 0;
      flushidx = 0;
      throw e;
    }
    set_current_component(null);
    dirty_components.length = 0;
    flushidx = 0;
    while (binding_callbacks.length)
      binding_callbacks.pop()();
    for (let i = 0; i < render_callbacks.length; i += 1) {
      const callback = render_callbacks[i];
      if (!seen_callbacks.has(callback)) {
        seen_callbacks.add(callback);
        callback();
      }
    }
    render_callbacks.length = 0;
  } while (dirty_components.length);
  while (flush_callbacks.length) {
    flush_callbacks.pop()();
  }
  update_scheduled = false;
  seen_callbacks.clear();
  set_current_component(saved_component);
}
function update($$) {
  if ($$.fragment !== null) {
    $$.update();
    run_all($$.before_update);
    const dirty = $$.dirty;
    $$.dirty = [-1];
    $$.fragment && $$.fragment.p($$.ctx, dirty);
    $$.after_update.forEach(add_render_callback);
  }
}
function flush_render_callbacks(fns) {
  const filtered = [];
  const targets = [];
  render_callbacks.forEach((c) => fns.indexOf(c) === -1 ? filtered.push(c) : targets.push(c));
  targets.forEach((c) => c());
  render_callbacks = filtered;
}

// node_modules/svelte/src/runtime/internal/transitions.js
var outroing = /* @__PURE__ */ new Set();
var outros;
function group_outros() {
  outros = {
    r: 0,
    c: [],
    p: outros
    // parent group
  };
}
function check_outros() {
  if (!outros.r) {
    run_all(outros.c);
  }
  outros = outros.p;
}
function transition_in(block, local) {
  if (block && block.i) {
    outroing.delete(block);
    block.i(local);
  }
}
function transition_out(block, local, detach2, callback) {
  if (block && block.o) {
    if (outroing.has(block))
      return;
    outroing.add(block);
    outros.c.push(() => {
      outroing.delete(block);
      if (callback) {
        if (detach2)
          block.d(1);
        callback();
      }
    });
    block.o(local);
  } else if (callback) {
    callback();
  }
}

// node_modules/svelte/src/runtime/internal/each.js
function ensure_array_like(array_like_or_iterator) {
  return (array_like_or_iterator == null ? void 0 : array_like_or_iterator.length) !== void 0 ? array_like_or_iterator : Array.from(array_like_or_iterator);
}

// node_modules/svelte/src/shared/boolean_attributes.js
var _boolean_attributes = (
  /** @type {const} */
  [
    "allowfullscreen",
    "allowpaymentrequest",
    "async",
    "autofocus",
    "autoplay",
    "checked",
    "controls",
    "default",
    "defer",
    "disabled",
    "formnovalidate",
    "hidden",
    "inert",
    "ismap",
    "loop",
    "multiple",
    "muted",
    "nomodule",
    "novalidate",
    "open",
    "playsinline",
    "readonly",
    "required",
    "reversed",
    "selected"
  ]
);
var boolean_attributes = /* @__PURE__ */ new Set([..._boolean_attributes]);

// node_modules/svelte/src/runtime/internal/Component.js
function bind2(component, name, callback) {
  const index = component.$$.props[name];
  if (index !== void 0) {
    component.$$.bound[index] = callback;
    callback(component.$$.ctx[index]);
  }
}
function create_component(block) {
  block && block.c();
}
function mount_component(component, target, anchor) {
  const { fragment, after_update } = component.$$;
  fragment && fragment.m(target, anchor);
  add_render_callback(() => {
    const new_on_destroy = component.$$.on_mount.map(run).filter(is_function);
    if (component.$$.on_destroy) {
      component.$$.on_destroy.push(...new_on_destroy);
    } else {
      run_all(new_on_destroy);
    }
    component.$$.on_mount = [];
  });
  after_update.forEach(add_render_callback);
}
function destroy_component(component, detaching) {
  const $$ = component.$$;
  if ($$.fragment !== null) {
    flush_render_callbacks($$.after_update);
    run_all($$.on_destroy);
    $$.fragment && $$.fragment.d(detaching);
    $$.on_destroy = $$.fragment = null;
    $$.ctx = [];
  }
}
function make_dirty(component, i) {
  if (component.$$.dirty[0] === -1) {
    dirty_components.push(component);
    schedule_update();
    component.$$.dirty.fill(0);
  }
  component.$$.dirty[i / 31 | 0] |= 1 << i % 31;
}
function init3(component, options, instance16, create_fragment16, not_equal, props, append_styles2, dirty = [-1]) {
  const parent_component = current_component;
  set_current_component(component);
  const $$ = component.$$ = {
    fragment: null,
    ctx: [],
    // state
    props,
    update: noop,
    not_equal,
    bound: blank_object(),
    // lifecycle
    on_mount: [],
    on_destroy: [],
    on_disconnect: [],
    before_update: [],
    after_update: [],
    context: new Map(options.context || (parent_component ? parent_component.$$.context : [])),
    // everything else
    callbacks: blank_object(),
    dirty,
    skip_bound: false,
    root: options.target || parent_component.$$.root
  };
  append_styles2 && append_styles2($$.root);
  let ready = false;
  $$.ctx = instance16 ? instance16(component, options.props || {}, (i, ret, ...rest) => {
    const value = rest.length ? rest[0] : ret;
    if ($$.ctx && not_equal($$.ctx[i], $$.ctx[i] = value)) {
      if (!$$.skip_bound && $$.bound[i])
        $$.bound[i](value);
      if (ready)
        make_dirty(component, i);
    }
    return ret;
  }) : [];
  $$.update();
  ready = true;
  run_all($$.before_update);
  $$.fragment = create_fragment16 ? create_fragment16($$.ctx) : false;
  if (options.target) {
    if (options.hydrate) {
      start_hydrating();
      const nodes = children(options.target);
      $$.fragment && $$.fragment.l(nodes);
      nodes.forEach(detach);
    } else {
      $$.fragment && $$.fragment.c();
    }
    if (options.intro)
      transition_in(component.$$.fragment);
    mount_component(component, options.target, options.anchor);
    end_hydrating();
    flush();
  }
  set_current_component(parent_component);
}
var SvelteElement;
if (typeof HTMLElement === "function") {
  SvelteElement = class extends HTMLElement {
    constructor($$componentCtor, $$slots, use_shadow_dom) {
      super();
      /** The Svelte component constructor */
      __publicField(this, "$$ctor");
      /** Slots */
      __publicField(this, "$$s");
      /** The Svelte component instance */
      __publicField(this, "$$c");
      /** Whether or not the custom element is connected */
      __publicField(this, "$$cn", false);
      /** Component props data */
      __publicField(this, "$$d", {});
      /** `true` if currently in the process of reflecting component props back to attributes */
      __publicField(this, "$$r", false);
      /** @type {Record<string, CustomElementPropDefinition>} Props definition (name, reflected, type etc) */
      __publicField(this, "$$p_d", {});
      /** @type {Record<string, Function[]>} Event listeners */
      __publicField(this, "$$l", {});
      /** @type {Map<Function, Function>} Event listener unsubscribe functions */
      __publicField(this, "$$l_u", /* @__PURE__ */ new Map());
      this.$$ctor = $$componentCtor;
      this.$$s = $$slots;
      if (use_shadow_dom) {
        this.attachShadow({ mode: "open" });
      }
    }
    addEventListener(type, listener, options) {
      this.$$l[type] = this.$$l[type] || [];
      this.$$l[type].push(listener);
      if (this.$$c) {
        const unsub = this.$$c.$on(type, listener);
        this.$$l_u.set(listener, unsub);
      }
      super.addEventListener(type, listener, options);
    }
    removeEventListener(type, listener, options) {
      super.removeEventListener(type, listener, options);
      if (this.$$c) {
        const unsub = this.$$l_u.get(listener);
        if (unsub) {
          unsub();
          this.$$l_u.delete(listener);
        }
      }
    }
    async connectedCallback() {
      this.$$cn = true;
      if (!this.$$c) {
        let create_slot2 = function(name) {
          return () => {
            let node;
            const obj = {
              c: function create() {
                node = element("slot");
                if (name !== "default") {
                  attr(node, "name", name);
                }
              },
              /**
               * @param {HTMLElement} target
               * @param {HTMLElement} [anchor]
               */
              m: function mount(target, anchor) {
                insert(target, node, anchor);
              },
              d: function destroy(detaching) {
                if (detaching) {
                  detach(node);
                }
              }
            };
            return obj;
          };
        };
        await Promise.resolve();
        if (!this.$$cn) {
          return;
        }
        const $$slots = {};
        const existing_slots = get_custom_elements_slots(this);
        for (const name of this.$$s) {
          if (name in existing_slots) {
            $$slots[name] = [create_slot2(name)];
          }
        }
        for (const attribute of this.attributes) {
          const name = this.$$g_p(attribute.name);
          if (!(name in this.$$d)) {
            this.$$d[name] = get_custom_element_value(name, attribute.value, this.$$p_d, "toProp");
          }
        }
        this.$$c = new this.$$ctor({
          target: this.shadowRoot || this,
          props: {
            ...this.$$d,
            $$slots,
            $$scope: {
              ctx: []
            }
          }
        });
        const reflect_attributes = () => {
          this.$$r = true;
          for (const key in this.$$p_d) {
            this.$$d[key] = this.$$c.$$.ctx[this.$$c.$$.props[key]];
            if (this.$$p_d[key].reflect) {
              const attribute_value = get_custom_element_value(
                key,
                this.$$d[key],
                this.$$p_d,
                "toAttribute"
              );
              if (attribute_value == null) {
                this.removeAttribute(key);
              } else {
                this.setAttribute(this.$$p_d[key].attribute || key, attribute_value);
              }
            }
          }
          this.$$r = false;
        };
        this.$$c.$$.after_update.push(reflect_attributes);
        reflect_attributes();
        for (const type in this.$$l) {
          for (const listener of this.$$l[type]) {
            const unsub = this.$$c.$on(type, listener);
            this.$$l_u.set(listener, unsub);
          }
        }
        this.$$l = {};
      }
    }
    // We don't need this when working within Svelte code, but for compatibility of people using this outside of Svelte
    // and setting attributes through setAttribute etc, this is helpful
    attributeChangedCallback(attr2, _oldValue, newValue) {
      var _a;
      if (this.$$r)
        return;
      attr2 = this.$$g_p(attr2);
      this.$$d[attr2] = get_custom_element_value(attr2, newValue, this.$$p_d, "toProp");
      (_a = this.$$c) == null ? void 0 : _a.$set({ [attr2]: this.$$d[attr2] });
    }
    disconnectedCallback() {
      this.$$cn = false;
      Promise.resolve().then(() => {
        if (!this.$$cn) {
          this.$$c.$destroy();
          this.$$c = void 0;
        }
      });
    }
    $$g_p(attribute_name) {
      return Object.keys(this.$$p_d).find(
        (key) => this.$$p_d[key].attribute === attribute_name || !this.$$p_d[key].attribute && key.toLowerCase() === attribute_name
      ) || attribute_name;
    }
  };
}
function get_custom_element_value(prop, value, props_definition, transform) {
  var _a;
  const type = (_a = props_definition[prop]) == null ? void 0 : _a.type;
  value = type === "Boolean" && typeof value !== "boolean" ? value != null : value;
  if (!transform || !props_definition[prop]) {
    return value;
  } else if (transform === "toAttribute") {
    switch (type) {
      case "Object":
      case "Array":
        return value == null ? null : JSON.stringify(value);
      case "Boolean":
        return value ? "" : null;
      case "Number":
        return value == null ? null : value;
      default:
        return value;
    }
  } else {
    switch (type) {
      case "Object":
      case "Array":
        return value && JSON.parse(value);
      case "Boolean":
        return value;
      case "Number":
        return value != null ? +value : value;
      default:
        return value;
    }
  }
}
var SvelteComponent = class {
  constructor() {
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$");
    /**
     * ### PRIVATE API
     *
     * Do not use, may change at any time
     *
     * @type {any}
     */
    __publicField(this, "$$set");
  }
  /** @returns {void} */
  $destroy() {
    destroy_component(this, 1);
    this.$destroy = noop;
  }
  /**
   * @template {Extract<keyof Events, string>} K
   * @param {K} type
   * @param {((e: Events[K]) => void) | null | undefined} callback
   * @returns {() => void}
   */
  $on(type, callback) {
    if (!is_function(callback)) {
      return noop;
    }
    const callbacks = this.$$.callbacks[type] || (this.$$.callbacks[type] = []);
    callbacks.push(callback);
    return () => {
      const index = callbacks.indexOf(callback);
      if (index !== -1)
        callbacks.splice(index, 1);
    };
  }
  /**
   * @param {Partial<Props>} props
   * @returns {void}
   */
  $set(props) {
    if (this.$$set && !is_empty(props)) {
      this.$$.skip_bound = true;
      this.$$set(props);
      this.$$.skip_bound = false;
    }
  }
};

// node_modules/svelte/src/shared/version.js
var PUBLIC_VERSION = "4";

// node_modules/svelte/src/runtime/internal/disclose-version/index.js
if (typeof window !== "undefined")
  (window.__svelte || (window.__svelte = { v: /* @__PURE__ */ new Set() })).v.add(PUBLIC_VERSION);

// src/views/components/MultiSelect.svelte
function add_css(target) {
  append_styles(target, "svelte-168eg05", ".multi-select-root.svelte-168eg05.svelte-168eg05{display:flex;flex-direction:column;gap:0.5rem;flex:1;--button-size:1.5rem}.badge.svelte-168eg05.svelte-168eg05{--icon-size:var(--icon-xs);--icon-stroke:var(--icon-xs-stroke-width);display:flex;align-items:center;background-color:var(--pill-background);border:var(--pill-border-width) solid var(--pill-border-color);border-radius:var(--pill-radius);color:var(--pill-color);cursor:var(--cursor);font-weight:var(--pill-weight);padding-top:var(--pill-padding-y);padding-bottom:var(--pill-padding-y);padding-left:var(--pill-padding-x);padding-right:var(--pill-padding-x);line-height:1;max-width:100%;gap:var(--size-4-2);justify-content:center;align-items:center}.hidden.svelte-168eg05.svelte-168eg05{visibility:hidden}.hidden.svelte-168eg05 span.svelte-168eg05{height:var(--button-size)}.badge.svelte-168eg05 span.svelte-168eg05{white-space:nowrap;overflow:hidden;text-overflow:ellipsis;min-width:1rem}.badges.svelte-168eg05.svelte-168eg05{display:flex;flex-wrap:wrap;gap:8px;min-height:2rem;padding:0.5rem 0 0 0}button.svelte-168eg05.svelte-168eg05{background:none;border:none;color:inherit;font:inherit;line-height:inherit;padding:0;-webkit-appearance:none;-moz-appearance:none;-o-appearance:none;appearance:none;box-shadow:none;border:none;cursor:pointer;height:var(--button-size);width:var(--button-size)}");
}
function get_each_context(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[9] = list[i];
  return child_ctx;
}
function get_each_context_1(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[12] = list[i];
  return child_ctx;
}
function create_each_block_1(ctx) {
  let span;
  let t_value = (
    /*error*/
    ctx[12] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
      attr(span, "class", "invalid");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*$errors*/
      4 && t_value !== (t_value = /*error*/
      ctx2[12] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_else_block(ctx) {
  let div;
  return {
    c() {
      div = element("div");
      div.innerHTML = `<span class="svelte-168eg05">Nothing selected</span> `;
      attr(div, "class", "badge hidden svelte-168eg05");
    },
    m(target, anchor) {
      insert(target, div, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_each_block(ctx) {
  let div;
  let span;
  let t0_value = (
    /*value*/
    ctx[9] + ""
  );
  let t0;
  let t1;
  let button;
  let t2;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[8](
        /*value*/
        ctx[9]
      )
    );
  }
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
      button = element("button");
      button.innerHTML = `<svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-x"><line x1="18" y1="6" x2="6" y2="18"></line><line x1="6" y1="6" x2="18" y2="18"></line></svg>`;
      t2 = space();
      attr(span, "class", "svelte-168eg05");
      attr(button, "class", "svelte-168eg05");
      attr(div, "class", "badge svelte-168eg05");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, span);
      append5(span, t0);
      append5(div, t1);
      append5(div, button);
      append5(div, t2);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*$values*/
      8 && t0_value !== (t0_value = /*value*/
      ctx[9] + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment(ctx) {
  let div1;
  let input;
  let createInput_action;
  let t0;
  let t1;
  let div0;
  let mounted;
  let dispose;
  let each_value_1 = ensure_array_like(
    /*$errors*/
    ctx[2]
  );
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks_1[i] = create_each_block_1(get_each_context_1(ctx, each_value_1, i));
  }
  let each_value = ensure_array_like(
    /*$values*/
    ctx[3]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block(get_each_context(ctx, each_value, i));
  }
  let each1_else = null;
  if (!each_value.length) {
    each1_else = create_else_block(ctx);
  }
  return {
    c() {
      div1 = element("div");
      input = element("input");
      t0 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      if (each1_else) {
        each1_else.c();
      }
      attr(input, "type", "text");
      attr(input, "class", "form-control");
      attr(input, "placeholder", "Select");
      toggle_class(
        input,
        "invalid",
        /*$errors*/
        ctx[2].length > 0
      );
      attr(div0, "class", "badges svelte-168eg05");
      attr(div1, "class", "multi-select-root svelte-168eg05");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append5(div1, input);
      append5(div1, t0);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div1, null);
        }
      }
      append5(div1, t1);
      append5(div1, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      if (each1_else) {
        each1_else.m(div0, null);
      }
      if (!mounted) {
        dispose = action_destroyer(createInput_action = /*createInput*/
        ctx[4].call(null, input));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*$errors*/
      4) {
        toggle_class(
          input,
          "invalid",
          /*$errors*/
          ctx2[2].length > 0
        );
      }
      if (dirty & /*$errors*/
      4) {
        each_value_1 = ensure_array_like(
          /*$errors*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_1(ctx2, each_value_1, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
          } else {
            each_blocks_1[i] = create_each_block_1(child_ctx);
            each_blocks_1[i].c();
            each_blocks_1[i].m(div1, t1);
          }
        }
        for (; i < each_blocks_1.length; i += 1) {
          each_blocks_1[i].d(1);
        }
        each_blocks_1.length = each_value_1.length;
      }
      if (dirty & /*removeValue, $values*/
      40) {
        each_value = ensure_array_like(
          /*$values*/
          ctx2[3]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div0, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
        if (!each_value.length && each1_else) {
          each1_else.p(ctx2, dirty);
        } else if (!each_value.length) {
          each1_else = create_else_block(ctx2);
          each1_else.c();
          each1_else.m(div0, null);
        } else if (each1_else) {
          each1_else.d(1);
          each1_else = null;
        }
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
      if (each1_else)
        each1_else.d();
      mounted = false;
      dispose();
    }
  };
}
function instance($$self, $$props, $$invalidate) {
  let $errors, $$unsubscribe_errors = noop, $$subscribe_errors = () => ($$unsubscribe_errors(), $$unsubscribe_errors = subscribe(errors, ($$value) => $$invalidate(2, $errors = $$value)), errors);
  let $values, $$unsubscribe_values = noop, $$subscribe_values = () => ($$unsubscribe_values(), $$unsubscribe_values = subscribe(values, ($$value) => $$invalidate(3, $values = $$value)), values);
  $$self.$$.on_destroy.push(() => $$unsubscribe_errors());
  $$self.$$.on_destroy.push(() => $$unsubscribe_values());
  let { model } = $$props;
  let { errors } = $$props;
  $$subscribe_errors();
  let { values } = $$props;
  $$subscribe_values();
  let { setting } = $$props;
  setting.settingEl.setCssStyles({ alignItems: "baseline" });
  const { createInput, removeValue } = model;
  const click_handler = (value) => removeValue(value);
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(6, model = $$props2.model);
    if ("errors" in $$props2)
      $$subscribe_errors($$invalidate(0, errors = $$props2.errors));
    if ("values" in $$props2)
      $$subscribe_values($$invalidate(1, values = $$props2.values));
    if ("setting" in $$props2)
      $$invalidate(7, setting = $$props2.setting);
  };
  return [
    errors,
    values,
    $errors,
    $values,
    createInput,
    removeValue,
    model,
    setting,
    click_handler
  ];
}
var MultiSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance,
      create_fragment,
      safe_not_equal,
      {
        model: 6,
        errors: 0,
        values: 1,
        setting: 7
      },
      add_css
    );
  }
};
var MultiSelect_default = MultiSelect;

// src/utils/Log.ts
var import_obsidian2 = require("obsidian");
function log_notice(title, msg, titleClass, bodyClass) {
  const notice = new import_obsidian2.Notice("", 15e3);
  const el = notice.noticeEl;
  el.empty();
  const head5 = el.createEl("h6", { text: title, cls: titleClass });
  head5.setCssStyles({ marginTop: "0px" });
  const body = el.createEl("div", { text: msg, cls: bodyClass });
  el.append(head5, body);
}
function log_error(e) {
  if (e instanceof ModalFormError && e.console_msg) {
    log_notice("Modal from error: ", e.message + "\n" + e.console_msg, "var(--text-error)");
    console.error(`Modal form Error:`, e.message, "\n", e.console_msg);
  } else {
    log_notice("Modal from error", e.message);
  }
}
var notifyError = (title) => (msg) => log_notice(`\u{1F6A8} ${title} \u{1F6A8}`, msg, "notice-error");

// src/core/ResultValue.ts
function _toBulletList(value) {
  if (Array.isArray(value)) {
    return value.map((v) => `- ${v}`).join("\n");
  }
  return Object.entries(value).map(([key, value2]) => `- ${key}: ${value2}`).join("\n");
}
function isRecord(value) {
  return typeof value === "object" && value !== null && !Array.isArray(value);
}
function deepMap(value, fn) {
  if (Array.isArray(value)) {
    return value.map((v) => deepMap(v, fn));
  }
  if (isRecord(value)) {
    return Object.fromEntries(
      Object.entries(value).map(([key, value2]) => [key, deepMap(value2, fn)])
    );
  }
  return fn(value);
}
var ResultValue = class {
  constructor(value, name, notify2 = notify2) {
    this.value = value;
    this.name = name;
    this.notify = notify2;
    /** Alias for `toDataview` */
    this.toDv = this.toDataview;
    /** Alias for `toBulletList` */
    this.toBullets = this.toBulletList;
  }
  static from(value, name, notify2 = notifyError) {
    return new ResultValue(value, name, notify2);
  }
  /**
   * Returns the value as a string.
   * If the value is an array, it will be joined with a comma.
   * If the value is an object, it will be stringified.
   * This is convenient because it is the default method called automatically
   * when the value needs to be rendered as a string, so you can just drop
   * the value directly into a template without having to call this method.
   * @returns string
   */
  toString() {
    switch (typeof this.value) {
      case "string":
        return this.value;
      case "number":
      case "boolean":
        return this.value.toString();
      case "object":
        if (Array.isArray(this.value)) {
          return this.value.join(", ");
        }
        return JSON.stringify(this.value);
      default:
        return "";
    }
  }
  /**
   * Returns the value as a bullet list.
   * If the value is empty or undefined, it will return an empty string.
   * If the value is a single value, it will return as a single item bullet list.
   * If the value is an array, it will return a bullet list with each item in the array.
   * If the value is an object, it will return a bullet list with each key/value pair in the object.
   * @returns string
   */
  toBulletList() {
    switch (typeof this.value) {
      case "boolean":
      case "number":
      case "string":
        return `- ${this.value}`;
      case "object": {
        const value = this.value;
        if (value === null)
          return "";
        if (Array.isArray(value)) {
          return _toBulletList(value);
        }
        if (isRecord(value)) {
          return _toBulletList(value);
        }
        return `- ${JSON.stringify(value)}`;
      }
      default:
        return "";
    }
  }
  /**
   * Converts the value to a dataview property using the field name as the key.
   * If the value is empty or undefined, it will return an empty string and not render anything.
   */
  toDataview() {
    const value = this.value;
    if (value === void 0)
      return "";
    if (Array.isArray(value)) {
      return `[${this.name}:: ${JSON.stringify(value).slice(1, -1)}]`;
    }
    return `[${this.name}:: ${this.toString()}]`;
  }
  /**
   * Transforms the containerd value using the provided function.
   * If the value is undefined or null the function will not be called
   * and the result will be the same as the original.
   * This is useful if you want to apply somme modifications to the value
   * before rendering it, for example if none of the existing format methods suit your needs.
   * @param {function} fn the function to transform the values
   * @returns a new FormValue with the transformed value
   **/
  map(fn) {
    const safeFn = E.tryCatchK(fn, ensureError);
    const unchanged = () => this;
    return pipe2(
      this.value,
      O.fromNullable,
      O.map(safeFn),
      O.fold(
        unchanged,
        (v) => pipe2(
          v,
          E.fold(
            (e) => {
              this.notify("Error in map of " + this.name)(e.message);
              return unchanged();
            },
            (v2) => ResultValue.from(v2, this.name, this.notify)
          )
        )
      )
    );
  }
  /**
   * Convenient getter to get the value as bullets, so you don't need to call `toBulletList` manually.
   * example:
   * ```ts
   *  result.getValue("myField").bullets;
   * ```
   */
  get bullets() {
    return this.toBulletList();
  }
  /**
   * getter that returns all the string values uppercased.
   * If the value is an array, it will return an array with all the strings uppercased.
   */
  get upper() {
    return this.map(
      (v) => deepMap(v, (it) => typeof it === "string" ? it.toLocaleUpperCase() : it)
    );
  }
  /**
   * getter that returns all the string values lowercased.
   * If the value is an array, it will return an array with all the strings lowercased.
   * If the value is an object, it will return an object with all the string values lowercased.
   * @returns FormValue
   */
  get lower() {
    return this.map(
      (v) => deepMap(v, (it) => typeof it === "string" ? it.toLocaleLowerCase() : it)
    );
  }
  /**
   * getter that returns all the string values trimmed.
   * */
  get trimmed() {
    return this.map((v) => deepMap(v, (it) => typeof it === "string" ? it.trim() : it));
  }
};

// src/core/objectSelect.ts
var KeysSchema = array(coerce(string(), String));
var PickOmitSchema = object({
  pick: optional(KeysSchema),
  omit: optional(KeysSchema)
});
function picKeys(obj) {
  return (keys) => pipe2(
    obj,
    filterWithIndex2((k) => keys.includes(k))
  );
}
function omitKeys(obj) {
  return (keys) => pipe2(
    obj,
    filterWithIndex2((k) => !keys.includes(k))
  );
}
function objectSelect(obj, opts) {
  return pipe2(
    parse2(PickOmitSchema, opts, { abortEarly: true }),
    E.map(
      (opts2) => {
        const picked = pipe2(
          fromNullable2(opts2.pick),
          flatMap3(fromArray),
          map3(picKeys(obj)),
          getOrElse2(() => obj)
        );
        return pipe2(
          fromNullable2(opts2.omit),
          flatMap3(fromArray),
          map3(omitKeys(picked)),
          getOrElse2(() => picked)
        );
      }
    ),
    E.getOrElse(() => obj)
  );
}

// src/core/FormResult.ts
var import_obsidian3 = require("obsidian");
function isPrimitive(value) {
  return typeof value === "string" || typeof value === "boolean" || typeof value === "number";
}
function isPrimitiveArray(value) {
  return Array.isArray(value) && value.every(isPrimitive);
}
var FormResult = class {
  constructor(data, status) {
    this.data = data;
    this.status = status;
    // alias
    this.getV = this.getValue;
    /* == Aliases ==*/
    /** just an alias for `asFrontmatterString` */
    this.asFrontmatter = this.asFrontmatterString;
    /** just an alias for `asFrontmatterString` */
    this.asYaml = this.asFrontmatterString;
    /** just an alias for `asDataviewProperties` */
    this.asDataview = this.asDataviewProperties;
    /** just an alias for `asDataviewProperties` */
    this.asDv = this.asDataviewProperties;
  }
  static make(data, status) {
    return new Proxy(new FormResult(data, status), {
      get(target, key, receiver) {
        if (key in target || typeof key !== "string") {
          return Reflect.get(target, key, receiver);
        }
        return target.getValue(key);
      }
    });
  }
  /**
   * Transform  the current data into a frontmatter string, which is expected
   * to be enclosed in `---` when used in a markdown file.
   * This method does not add the enclosing `---` to the string,
   * so you can put it anywhere inside the frontmatter.
   * @param {Object} [options] an options object describing what options to pick or omit
   * @param {string[]} [options.pick] an array of key names to pick from the data
   * @param {string[]} [options.omit] an array of key names to omit from the data
   * @returns the data formatted as a frontmatter string
   */
  asFrontmatterString(options) {
    const data = objectSelect(this.data, options);
    return (0, import_obsidian3.stringifyYaml)(data);
  }
  /**
   * Return the current data as a block of dataview properties
   * @param {Object} [options] an options object describing what options to pick or omit
   * @param {string[]} [options.pick] an array of key names to pick from the data
   * @param {string[]} [options.omit] an array of key names to omit from the data
   * @returns string
   */
  asDataviewProperties(options) {
    const data = objectSelect(this.data, options);
    return Object.entries(data).map(([key, value]) => `${key}:: ${Array.isArray(value) ? value.map((v) => JSON.stringify(v)) : value}`).join("\n");
  }
  /**
  Returns a copy of the data contained on this result.
  */
  getData() {
    return { ...this.data };
  }
  /**
   * Returns the data formatted as a string matching the provided
   * template.
   */
  asString(template) {
    let result = template;
    for (const [key, value] of Object.entries(this.data)) {
      result = result.replace(new RegExp(`{{${key}}}`, "g"), value + "");
    }
    return result;
  }
  /**
   * Gets a single value from the data.
   * It takes an optiional mapping function thatt can be used to transform the value.
   * The function will only be called if the value exists.
   * @param {string} key the key to get the value from
   * @param {function} [mapFn] a function to transform the value
   * @returns the value transformed by the function if it was provided, the value or empty string if it doesn't exist
   */
  get(key, mapFn) {
    const value = this.data[key];
    if (value === void 0) {
      return "";
    }
    if (mapFn) {
      return mapFn(value);
    }
    if (typeof value === "object") {
      return JSON.stringify(value);
    }
    return value;
  }
  getValue(key) {
    return ResultValue.from(this.data[key], key);
  }
};

// src/core/formDataFromFormDefaults.ts
function formDataFromFormDefaults(fields, values) {
  const result = {};
  const invalidKeys = [];
  for (const [key, value] of Object.entries(values)) {
    if (Array.isArray(value) && isPrimitiveArray(value)) {
      result[key] = value;
    } else if (isPrimitive(value)) {
      result[key] = value;
    } else {
      invalidKeys.push(key);
    }
  }
  if (invalidKeys.length > 0) {
    log_error(new ModalFormError(`Invalid keys in form options: ${invalidKeys.join(", ")}`));
  }
  return pipe2(
    fields,
    A.map((field) => {
      return pipe2(
        result[field.name],
        fromNullable2,
        match2(() => field.input.type === "toggle" ? some3(false) : none2, some3),
        map3((value) => [field.name, value])
      );
    }),
    A.compact,
    fromEntries
  );
}

// src/utils/files.ts
var import_obsidian4 = require("obsidian");
var FolderDoesNotExistError = class extends Error {
};
FolderDoesNotExistError.tag = "FolderDoesNotExistError";
var NotAFolderError = class extends Error {
  constructor(file) {
    super(`File ${file.path} is not a folder`);
    this.file = file;
  }
};
NotAFolderError.tag = "NotAFolderError";
var _FileDoesNotExistError = class extends Error {
  static of(file) {
    return new _FileDoesNotExistError(`File "${file}" doesn't exist`);
  }
};
var FileDoesNotExistError = _FileDoesNotExistError;
FileDoesNotExistError.tag = "FileDoesNotExistError";
var NotAFileError = class extends Error {
  constructor(file) {
    super(`File ${file.path} is not a file`);
    this.file = file;
  }
};
NotAFileError.tag = "NotAFileError";
function resolve_tfolder(folder_str, app2) {
  return pipe2(
    (0, import_obsidian4.normalizePath)(folder_str),
    (path) => app2.vault.getAbstractFileByPath(path),
    E.fromNullable(new FolderDoesNotExistError(`Folder "${folder_str}" doesn't exist`)),
    E.flatMap((file) => {
      if (!(file instanceof import_obsidian4.TFolder)) {
        return E.left(new NotAFolderError(file));
      }
      return E.right(file);
    })
  );
}
function resolve_tfile(file_str, app2) {
  return pipe2(
    (0, import_obsidian4.normalizePath)(file_str),
    (path) => app2.vault.getAbstractFileByPath(path),
    E.fromNullable(FileDoesNotExistError.of(file_str)),
    E.flatMap((file) => {
      if (!(file instanceof import_obsidian4.TFile)) {
        return E.left(new NotAFileError(file));
      }
      return E.right(file);
    })
  );
}
function get_tfiles_from_folder(folder_str, app2) {
  return pipe2(
    resolve_tfolder(folder_str, app2),
    E.flatMap((folder) => {
      const files = [];
      import_obsidian4.Vault.recurseChildren(folder, (file) => {
        if (file instanceof import_obsidian4.TFile) {
          files.push(file);
        }
      });
      return E.right(files);
    }),
    E.map((files) => {
      return files.sort((a, b) => {
        return a.basename.localeCompare(b.basename);
      });
    })
  );
}
function isArrayOfStrings(value) {
  return Array.isArray(value) && value.every((v) => typeof v === "string");
}
var splitIfString = (value) => pipe2(
  value,
  O.fromPredicate(isString),
  O.map((s) => s.split(","))
);
function parseToArrOfStr(str) {
  return pipe2(
    str,
    O.fromNullable,
    O.chain(
      (value) => pipe2(
        value,
        splitIfString,
        /* prettier-ignore */
        O.alt(() => pipe2(
          value,
          O.fromPredicate(isArrayOfStrings)
        ))
      )
    )
  );
}
function extract_tags(cache) {
  const bodyTags = pipe2(
    cache.tags,
    O.fromNullable,
    O.map(A.map((tag) => tag.tag))
  );
  const frontmatterTags = pipe2(
    cache.frontmatter,
    O.fromNullable,
    O.chain((frontmatter) => parseToArrOfStr(frontmatter.tags))
  );
  return pipe2(
    [bodyTags, frontmatterTags],
    A.compact,
    A.flatten
  );
}
function enrich_tfile(file, app2) {
  var _a;
  const metadata = app2.metadataCache.getCache(file.path);
  return {
    ...file,
    frontmatter: (_a = metadata == null ? void 0 : metadata.frontmatter) != null ? _a : {},
    tags: pipe2(
      metadata,
      O.fromNullable,
      O.map(extract_tags),
      O.getOrElse(() => [])
    )
  };
}
function file_exists(file_str, app2) {
  return pipe2(
    (0, import_obsidian4.normalizePath)(file_str),
    (path) => app2.vault.getAbstractFileByPath(path),
    (value) => value !== null
  );
}

// src/suggesters/suggestFile.ts
var import_obsidian5 = require("obsidian");

// node_modules/fuse.js/dist/fuse.esm.js
function isArray(value) {
  return !Array.isArray ? getTag(value) === "[object Array]" : Array.isArray(value);
}
var INFINITY = 1 / 0;
function baseToString(value) {
  if (typeof value == "string") {
    return value;
  }
  let result = value + "";
  return result == "0" && 1 / value == -INFINITY ? "-0" : result;
}
function toString(value) {
  return value == null ? "" : baseToString(value);
}
function isString2(value) {
  return typeof value === "string";
}
function isNumber(value) {
  return typeof value === "number";
}
function isBoolean(value) {
  return value === true || value === false || isObjectLike(value) && getTag(value) == "[object Boolean]";
}
function isObject(value) {
  return typeof value === "object";
}
function isObjectLike(value) {
  return isObject(value) && value !== null;
}
function isDefined(value) {
  return value !== void 0 && value !== null;
}
function isBlank(value) {
  return !value.trim().length;
}
function getTag(value) {
  return value == null ? value === void 0 ? "[object Undefined]" : "[object Null]" : Object.prototype.toString.call(value);
}
var INCORRECT_INDEX_TYPE = "Incorrect 'index' type";
var LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY = (key) => `Invalid value for key ${key}`;
var PATTERN_LENGTH_TOO_LARGE = (max2) => `Pattern length exceeds max of ${max2}.`;
var MISSING_KEY_PROPERTY = (name) => `Missing ${name} property in key`;
var INVALID_KEY_WEIGHT_VALUE = (key) => `Property 'weight' in key '${key}' must be a positive integer`;
var hasOwn = Object.prototype.hasOwnProperty;
var KeyStore = class {
  constructor(keys) {
    this._keys = [];
    this._keyMap = {};
    let totalWeight = 0;
    keys.forEach((key) => {
      let obj = createKey(key);
      totalWeight += obj.weight;
      this._keys.push(obj);
      this._keyMap[obj.id] = obj;
      totalWeight += obj.weight;
    });
    this._keys.forEach((key) => {
      key.weight /= totalWeight;
    });
  }
  get(keyId) {
    return this._keyMap[keyId];
  }
  keys() {
    return this._keys;
  }
  toJSON() {
    return JSON.stringify(this._keys);
  }
};
function createKey(key) {
  let path = null;
  let id = null;
  let src = null;
  let weight = 1;
  let getFn = null;
  if (isString2(key) || isArray(key)) {
    src = key;
    path = createKeyPath(key);
    id = createKeyId(key);
  } else {
    if (!hasOwn.call(key, "name")) {
      throw new Error(MISSING_KEY_PROPERTY("name"));
    }
    const name = key.name;
    src = name;
    if (hasOwn.call(key, "weight")) {
      weight = key.weight;
      if (weight <= 0) {
        throw new Error(INVALID_KEY_WEIGHT_VALUE(name));
      }
    }
    path = createKeyPath(name);
    id = createKeyId(name);
    getFn = key.getFn;
  }
  return { path, id, weight, src, getFn };
}
function createKeyPath(key) {
  return isArray(key) ? key : key.split(".");
}
function createKeyId(key) {
  return isArray(key) ? key.join(".") : key;
}
function get(obj, path) {
  let list = [];
  let arr = false;
  const deepGet = (obj2, path2, index) => {
    if (!isDefined(obj2)) {
      return;
    }
    if (!path2[index]) {
      list.push(obj2);
    } else {
      let key = path2[index];
      const value = obj2[key];
      if (!isDefined(value)) {
        return;
      }
      if (index === path2.length - 1 && (isString2(value) || isNumber(value) || isBoolean(value))) {
        list.push(toString(value));
      } else if (isArray(value)) {
        arr = true;
        for (let i = 0, len = value.length; i < len; i += 1) {
          deepGet(value[i], path2, index + 1);
        }
      } else if (path2.length) {
        deepGet(value, path2, index + 1);
      }
    }
  };
  deepGet(obj, isString2(path) ? path.split(".") : path, 0);
  return arr ? list : list[0];
}
var MatchOptions = {
  // Whether the matches should be included in the result set. When `true`, each record in the result
  // set will include the indices of the matched characters.
  // These can consequently be used for highlighting purposes.
  includeMatches: false,
  // When `true`, the matching function will continue to the end of a search pattern even if
  // a perfect match has already been located in the string.
  findAllMatches: false,
  // Minimum number of characters that must be matched before a result is considered a match
  minMatchCharLength: 1
};
var BasicOptions = {
  // When `true`, the algorithm continues searching to the end of the input even if a perfect
  // match is found before the end of the same input.
  isCaseSensitive: false,
  // When true, the matching function will continue to the end of a search pattern even if
  includeScore: false,
  // List of properties that will be searched. This also supports nested properties.
  keys: [],
  // Whether to sort the result list, by score
  shouldSort: true,
  // Default sort function: sort by ascending score, ascending index
  sortFn: (a, b) => a.score === b.score ? a.idx < b.idx ? -1 : 1 : a.score < b.score ? -1 : 1
};
var FuzzyOptions = {
  // Approximately where in the text is the pattern expected to be found?
  location: 0,
  // At what point does the match algorithm give up. A threshold of '0.0' requires a perfect match
  // (of both letters and location), a threshold of '1.0' would match anything.
  threshold: 0.6,
  // Determines how close the match must be to the fuzzy location (specified above).
  // An exact letter match which is 'distance' characters away from the fuzzy location
  // would score as a complete mismatch. A distance of '0' requires the match be at
  // the exact location specified, a threshold of '1000' would require a perfect match
  // to be within 800 characters of the fuzzy location to be found using a 0.8 threshold.
  distance: 100
};
var AdvancedOptions = {
  // When `true`, it enables the use of unix-like search commands
  useExtendedSearch: false,
  // The get function to use when fetching an object's properties.
  // The default will search nested paths *ie foo.bar.baz*
  getFn: get,
  // When `true`, search will ignore `location` and `distance`, so it won't matter
  // where in the string the pattern appears.
  // More info: https://fusejs.io/concepts/scoring-theory.html#fuzziness-score
  ignoreLocation: false,
  // When `true`, the calculation for the relevance score (used for sorting) will
  // ignore the field-length norm.
  // More info: https://fusejs.io/concepts/scoring-theory.html#field-length-norm
  ignoreFieldNorm: false,
  // The weight to determine how much field length norm effects scoring.
  fieldNormWeight: 1
};
var Config = {
  ...BasicOptions,
  ...MatchOptions,
  ...FuzzyOptions,
  ...AdvancedOptions
};
var SPACE = /[^ ]+/g;
function norm(weight = 1, mantissa = 3) {
  const cache = /* @__PURE__ */ new Map();
  const m = Math.pow(10, mantissa);
  return {
    get(value) {
      const numTokens = value.match(SPACE).length;
      if (cache.has(numTokens)) {
        return cache.get(numTokens);
      }
      const norm2 = 1 / Math.pow(numTokens, 0.5 * weight);
      const n = parseFloat(Math.round(norm2 * m) / m);
      cache.set(numTokens, n);
      return n;
    },
    clear() {
      cache.clear();
    }
  };
}
var FuseIndex = class {
  constructor({
    getFn = Config.getFn,
    fieldNormWeight = Config.fieldNormWeight
  } = {}) {
    this.norm = norm(fieldNormWeight, 3);
    this.getFn = getFn;
    this.isCreated = false;
    this.setIndexRecords();
  }
  setSources(docs = []) {
    this.docs = docs;
  }
  setIndexRecords(records = []) {
    this.records = records;
  }
  setKeys(keys = []) {
    this.keys = keys;
    this._keysMap = {};
    keys.forEach((key, idx) => {
      this._keysMap[key.id] = idx;
    });
  }
  create() {
    if (this.isCreated || !this.docs.length) {
      return;
    }
    this.isCreated = true;
    if (isString2(this.docs[0])) {
      this.docs.forEach((doc, docIndex) => {
        this._addString(doc, docIndex);
      });
    } else {
      this.docs.forEach((doc, docIndex) => {
        this._addObject(doc, docIndex);
      });
    }
    this.norm.clear();
  }
  // Adds a doc to the end of the index
  add(doc) {
    const idx = this.size();
    if (isString2(doc)) {
      this._addString(doc, idx);
    } else {
      this._addObject(doc, idx);
    }
  }
  // Removes the doc at the specified index of the index
  removeAt(idx) {
    this.records.splice(idx, 1);
    for (let i = idx, len = this.size(); i < len; i += 1) {
      this.records[i].i -= 1;
    }
  }
  getValueForItemAtKeyId(item2, keyId) {
    return item2[this._keysMap[keyId]];
  }
  size() {
    return this.records.length;
  }
  _addString(doc, docIndex) {
    if (!isDefined(doc) || isBlank(doc)) {
      return;
    }
    let record = {
      v: doc,
      i: docIndex,
      n: this.norm.get(doc)
    };
    this.records.push(record);
  }
  _addObject(doc, docIndex) {
    let record = { i: docIndex, $: {} };
    this.keys.forEach((key, keyIndex) => {
      let value = key.getFn ? key.getFn(doc) : this.getFn(doc, key.path);
      if (!isDefined(value)) {
        return;
      }
      if (isArray(value)) {
        let subRecords = [];
        const stack = [{ nestedArrIndex: -1, value }];
        while (stack.length) {
          const { nestedArrIndex, value: value2 } = stack.pop();
          if (!isDefined(value2)) {
            continue;
          }
          if (isString2(value2) && !isBlank(value2)) {
            let subRecord = {
              v: value2,
              i: nestedArrIndex,
              n: this.norm.get(value2)
            };
            subRecords.push(subRecord);
          } else if (isArray(value2)) {
            value2.forEach((item2, k) => {
              stack.push({
                nestedArrIndex: k,
                value: item2
              });
            });
          } else
            ;
        }
        record.$[keyIndex] = subRecords;
      } else if (isString2(value) && !isBlank(value)) {
        let subRecord = {
          v: value,
          n: this.norm.get(value)
        };
        record.$[keyIndex] = subRecord;
      }
    });
    this.records.push(record);
  }
  toJSON() {
    return {
      keys: this.keys,
      records: this.records
    };
  }
};
function createIndex(keys, docs, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys.map(createKey));
  myIndex.setSources(docs);
  myIndex.create();
  return myIndex;
}
function parseIndex(data, { getFn = Config.getFn, fieldNormWeight = Config.fieldNormWeight } = {}) {
  const { keys, records } = data;
  const myIndex = new FuseIndex({ getFn, fieldNormWeight });
  myIndex.setKeys(keys);
  myIndex.setIndexRecords(records);
  return myIndex;
}
function computeScore$1(pattern, {
  errors = 0,
  currentLocation = 0,
  expectedLocation = 0,
  distance = Config.distance,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  const accuracy = errors / pattern.length;
  if (ignoreLocation) {
    return accuracy;
  }
  const proximity = Math.abs(expectedLocation - currentLocation);
  if (!distance) {
    return proximity ? 1 : accuracy;
  }
  return accuracy + proximity / distance;
}
function convertMaskToIndices(matchmask = [], minMatchCharLength = Config.minMatchCharLength) {
  let indices = [];
  let start = -1;
  let end = -1;
  let i = 0;
  for (let len = matchmask.length; i < len; i += 1) {
    let match3 = matchmask[i];
    if (match3 && start === -1) {
      start = i;
    } else if (!match3 && start !== -1) {
      end = i - 1;
      if (end - start + 1 >= minMatchCharLength) {
        indices.push([start, end]);
      }
      start = -1;
    }
  }
  if (matchmask[i - 1] && i - start >= minMatchCharLength) {
    indices.push([start, i - 1]);
  }
  return indices;
}
var MAX_BITS = 32;
function search(text3, pattern, patternAlphabet, {
  location = Config.location,
  distance = Config.distance,
  threshold = Config.threshold,
  findAllMatches = Config.findAllMatches,
  minMatchCharLength = Config.minMatchCharLength,
  includeMatches = Config.includeMatches,
  ignoreLocation = Config.ignoreLocation
} = {}) {
  if (pattern.length > MAX_BITS) {
    throw new Error(PATTERN_LENGTH_TOO_LARGE(MAX_BITS));
  }
  const patternLen = pattern.length;
  const textLen = text3.length;
  const expectedLocation = Math.max(0, Math.min(location, textLen));
  let currentThreshold = threshold;
  let bestLocation = expectedLocation;
  const computeMatches = minMatchCharLength > 1 || includeMatches;
  const matchMask = computeMatches ? Array(textLen) : [];
  let index;
  while ((index = text3.indexOf(pattern, bestLocation)) > -1) {
    let score = computeScore$1(pattern, {
      currentLocation: index,
      expectedLocation,
      distance,
      ignoreLocation
    });
    currentThreshold = Math.min(score, currentThreshold);
    bestLocation = index + patternLen;
    if (computeMatches) {
      let i = 0;
      while (i < patternLen) {
        matchMask[index + i] = 1;
        i += 1;
      }
    }
  }
  bestLocation = -1;
  let lastBitArr = [];
  let finalScore = 1;
  let binMax = patternLen + textLen;
  const mask = 1 << patternLen - 1;
  for (let i = 0; i < patternLen; i += 1) {
    let binMin = 0;
    let binMid = binMax;
    while (binMin < binMid) {
      const score2 = computeScore$1(pattern, {
        errors: i,
        currentLocation: expectedLocation + binMid,
        expectedLocation,
        distance,
        ignoreLocation
      });
      if (score2 <= currentThreshold) {
        binMin = binMid;
      } else {
        binMax = binMid;
      }
      binMid = Math.floor((binMax - binMin) / 2 + binMin);
    }
    binMax = binMid;
    let start = Math.max(1, expectedLocation - binMid + 1);
    let finish = findAllMatches ? textLen : Math.min(expectedLocation + binMid, textLen) + patternLen;
    let bitArr = Array(finish + 2);
    bitArr[finish + 1] = (1 << i) - 1;
    for (let j = finish; j >= start; j -= 1) {
      let currentLocation = j - 1;
      let charMatch = patternAlphabet[text3.charAt(currentLocation)];
      if (computeMatches) {
        matchMask[currentLocation] = +!!charMatch;
      }
      bitArr[j] = (bitArr[j + 1] << 1 | 1) & charMatch;
      if (i) {
        bitArr[j] |= (lastBitArr[j + 1] | lastBitArr[j]) << 1 | 1 | lastBitArr[j + 1];
      }
      if (bitArr[j] & mask) {
        finalScore = computeScore$1(pattern, {
          errors: i,
          currentLocation,
          expectedLocation,
          distance,
          ignoreLocation
        });
        if (finalScore <= currentThreshold) {
          currentThreshold = finalScore;
          bestLocation = currentLocation;
          if (bestLocation <= expectedLocation) {
            break;
          }
          start = Math.max(1, 2 * expectedLocation - bestLocation);
        }
      }
    }
    const score = computeScore$1(pattern, {
      errors: i + 1,
      currentLocation: expectedLocation,
      expectedLocation,
      distance,
      ignoreLocation
    });
    if (score > currentThreshold) {
      break;
    }
    lastBitArr = bitArr;
  }
  const result = {
    isMatch: bestLocation >= 0,
    // Count exact matches (those with a score of 0) to be "almost" exact
    score: Math.max(1e-3, finalScore)
  };
  if (computeMatches) {
    const indices = convertMaskToIndices(matchMask, minMatchCharLength);
    if (!indices.length) {
      result.isMatch = false;
    } else if (includeMatches) {
      result.indices = indices;
    }
  }
  return result;
}
function createPatternAlphabet(pattern) {
  let mask = {};
  for (let i = 0, len = pattern.length; i < len; i += 1) {
    const char2 = pattern.charAt(i);
    mask[char2] = (mask[char2] || 0) | 1 << len - i - 1;
  }
  return mask;
}
var BitapSearch = class {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    this.options = {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.chunks = [];
    if (!this.pattern.length) {
      return;
    }
    const addChunk = (pattern2, startIndex) => {
      this.chunks.push({
        pattern: pattern2,
        alphabet: createPatternAlphabet(pattern2),
        startIndex
      });
    };
    const len = this.pattern.length;
    if (len > MAX_BITS) {
      let i = 0;
      const remainder = len % MAX_BITS;
      const end = len - remainder;
      while (i < end) {
        addChunk(this.pattern.substr(i, MAX_BITS), i);
        i += MAX_BITS;
      }
      if (remainder) {
        const startIndex = len - MAX_BITS;
        addChunk(this.pattern.substr(startIndex), startIndex);
      }
    } else {
      addChunk(this.pattern, 0);
    }
  }
  searchIn(text3) {
    const { isCaseSensitive, includeMatches } = this.options;
    if (!isCaseSensitive) {
      text3 = text3.toLowerCase();
    }
    if (this.pattern === text3) {
      let result2 = {
        isMatch: true,
        score: 0
      };
      if (includeMatches) {
        result2.indices = [[0, text3.length - 1]];
      }
      return result2;
    }
    const {
      location,
      distance,
      threshold,
      findAllMatches,
      minMatchCharLength,
      ignoreLocation
    } = this.options;
    let allIndices = [];
    let totalScore = 0;
    let hasMatches = false;
    this.chunks.forEach(({ pattern, alphabet, startIndex }) => {
      const { isMatch, score, indices } = search(text3, pattern, alphabet, {
        location: location + startIndex,
        distance,
        threshold,
        findAllMatches,
        minMatchCharLength,
        includeMatches,
        ignoreLocation
      });
      if (isMatch) {
        hasMatches = true;
      }
      totalScore += score;
      if (isMatch && indices) {
        allIndices = [...allIndices, ...indices];
      }
    });
    let result = {
      isMatch: hasMatches,
      score: hasMatches ? totalScore / this.chunks.length : 1
    };
    if (hasMatches && includeMatches) {
      result.indices = allIndices;
    }
    return result;
  }
};
var BaseMatch = class {
  constructor(pattern) {
    this.pattern = pattern;
  }
  static isMultiMatch(pattern) {
    return getMatch(pattern, this.multiRegex);
  }
  static isSingleMatch(pattern) {
    return getMatch(pattern, this.singleRegex);
  }
  search() {
  }
};
function getMatch(pattern, exp) {
  const matches = pattern.match(exp);
  return matches ? matches[1] : null;
}
var ExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "exact";
  }
  static get multiRegex() {
    return /^="(.*)"$/;
  }
  static get singleRegex() {
    return /^=(.*)$/;
  }
  search(text3) {
    const isMatch = text3 === this.pattern;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InverseExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"$/;
  }
  static get singleRegex() {
    return /^!(.*)$/;
  }
  search(text3) {
    const index = text3.indexOf(this.pattern);
    const isMatch = index === -1;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text3.length - 1]
    };
  }
};
var PrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "prefix-exact";
  }
  static get multiRegex() {
    return /^\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^\^(.*)$/;
  }
  search(text3) {
    const isMatch = text3.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, this.pattern.length - 1]
    };
  }
};
var InversePrefixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-prefix-exact";
  }
  static get multiRegex() {
    return /^!\^"(.*)"$/;
  }
  static get singleRegex() {
    return /^!\^(.*)$/;
  }
  search(text3) {
    const isMatch = !text3.startsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text3.length - 1]
    };
  }
};
var SuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "suffix-exact";
  }
  static get multiRegex() {
    return /^"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^(.*)\$$/;
  }
  search(text3) {
    const isMatch = text3.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [text3.length - this.pattern.length, text3.length - 1]
    };
  }
};
var InverseSuffixExactMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "inverse-suffix-exact";
  }
  static get multiRegex() {
    return /^!"(.*)"\$$/;
  }
  static get singleRegex() {
    return /^!(.*)\$$/;
  }
  search(text3) {
    const isMatch = !text3.endsWith(this.pattern);
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices: [0, text3.length - 1]
    };
  }
};
var FuzzyMatch = class extends BaseMatch {
  constructor(pattern, {
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance,
    includeMatches = Config.includeMatches,
    findAllMatches = Config.findAllMatches,
    minMatchCharLength = Config.minMatchCharLength,
    isCaseSensitive = Config.isCaseSensitive,
    ignoreLocation = Config.ignoreLocation
  } = {}) {
    super(pattern);
    this._bitapSearch = new BitapSearch(pattern, {
      location,
      threshold,
      distance,
      includeMatches,
      findAllMatches,
      minMatchCharLength,
      isCaseSensitive,
      ignoreLocation
    });
  }
  static get type() {
    return "fuzzy";
  }
  static get multiRegex() {
    return /^"(.*)"$/;
  }
  static get singleRegex() {
    return /^(.*)$/;
  }
  search(text3) {
    return this._bitapSearch.searchIn(text3);
  }
};
var IncludeMatch = class extends BaseMatch {
  constructor(pattern) {
    super(pattern);
  }
  static get type() {
    return "include";
  }
  static get multiRegex() {
    return /^'"(.*)"$/;
  }
  static get singleRegex() {
    return /^'(.*)$/;
  }
  search(text3) {
    let location = 0;
    let index;
    const indices = [];
    const patternLen = this.pattern.length;
    while ((index = text3.indexOf(this.pattern, location)) > -1) {
      location = index + patternLen;
      indices.push([index, location - 1]);
    }
    const isMatch = !!indices.length;
    return {
      isMatch,
      score: isMatch ? 0 : 1,
      indices
    };
  }
};
var searchers = [
  ExactMatch,
  IncludeMatch,
  PrefixExactMatch,
  InversePrefixExactMatch,
  InverseSuffixExactMatch,
  SuffixExactMatch,
  InverseExactMatch,
  FuzzyMatch
];
var searchersLen = searchers.length;
var SPACE_RE = / +(?=(?:[^\"]*\"[^\"]*\")*[^\"]*$)/;
var OR_TOKEN = "|";
function parseQuery(pattern, options = {}) {
  return pattern.split(OR_TOKEN).map((item2) => {
    let query = item2.trim().split(SPACE_RE).filter((item3) => item3 && !!item3.trim());
    let results = [];
    for (let i = 0, len = query.length; i < len; i += 1) {
      const queryItem = query[i];
      let found = false;
      let idx = -1;
      while (!found && ++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isMultiMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          found = true;
        }
      }
      if (found) {
        continue;
      }
      idx = -1;
      while (++idx < searchersLen) {
        const searcher = searchers[idx];
        let token = searcher.isSingleMatch(queryItem);
        if (token) {
          results.push(new searcher(token, options));
          break;
        }
      }
    }
    return results;
  });
}
var MultiMatchSet = /* @__PURE__ */ new Set([FuzzyMatch.type, IncludeMatch.type]);
var ExtendedSearch = class {
  constructor(pattern, {
    isCaseSensitive = Config.isCaseSensitive,
    includeMatches = Config.includeMatches,
    minMatchCharLength = Config.minMatchCharLength,
    ignoreLocation = Config.ignoreLocation,
    findAllMatches = Config.findAllMatches,
    location = Config.location,
    threshold = Config.threshold,
    distance = Config.distance
  } = {}) {
    this.query = null;
    this.options = {
      isCaseSensitive,
      includeMatches,
      minMatchCharLength,
      findAllMatches,
      ignoreLocation,
      location,
      threshold,
      distance
    };
    this.pattern = isCaseSensitive ? pattern : pattern.toLowerCase();
    this.query = parseQuery(this.pattern, this.options);
  }
  static condition(_, options) {
    return options.useExtendedSearch;
  }
  searchIn(text3) {
    const query = this.query;
    if (!query) {
      return {
        isMatch: false,
        score: 1
      };
    }
    const { includeMatches, isCaseSensitive } = this.options;
    text3 = isCaseSensitive ? text3 : text3.toLowerCase();
    let numMatches = 0;
    let allIndices = [];
    let totalScore = 0;
    for (let i = 0, qLen = query.length; i < qLen; i += 1) {
      const searchers2 = query[i];
      allIndices.length = 0;
      numMatches = 0;
      for (let j = 0, pLen = searchers2.length; j < pLen; j += 1) {
        const searcher = searchers2[j];
        const { isMatch, indices, score } = searcher.search(text3);
        if (isMatch) {
          numMatches += 1;
          totalScore += score;
          if (includeMatches) {
            const type = searcher.constructor.type;
            if (MultiMatchSet.has(type)) {
              allIndices = [...allIndices, ...indices];
            } else {
              allIndices.push(indices);
            }
          }
        } else {
          totalScore = 0;
          numMatches = 0;
          allIndices.length = 0;
          break;
        }
      }
      if (numMatches) {
        let result = {
          isMatch: true,
          score: totalScore / numMatches
        };
        if (includeMatches) {
          result.indices = allIndices;
        }
        return result;
      }
    }
    return {
      isMatch: false,
      score: 1
    };
  }
};
var registeredSearchers = [];
function register(...args) {
  registeredSearchers.push(...args);
}
function createSearcher(pattern, options) {
  for (let i = 0, len = registeredSearchers.length; i < len; i += 1) {
    let searcherClass = registeredSearchers[i];
    if (searcherClass.condition(pattern, options)) {
      return new searcherClass(pattern, options);
    }
  }
  return new BitapSearch(pattern, options);
}
var LogicalOperator = {
  AND: "$and",
  OR: "$or"
};
var KeyType = {
  PATH: "$path",
  PATTERN: "$val"
};
var isExpression = (query) => !!(query[LogicalOperator.AND] || query[LogicalOperator.OR]);
var isPath = (query) => !!query[KeyType.PATH];
var isLeaf = (query) => !isArray(query) && isObject(query) && !isExpression(query);
var convertToExplicit = (query) => ({
  [LogicalOperator.AND]: Object.keys(query).map((key) => ({
    [key]: query[key]
  }))
});
function parse3(query, options, { auto = true } = {}) {
  const next = (query2) => {
    let keys = Object.keys(query2);
    const isQueryPath = isPath(query2);
    if (!isQueryPath && keys.length > 1 && !isExpression(query2)) {
      return next(convertToExplicit(query2));
    }
    if (isLeaf(query2)) {
      const key = isQueryPath ? query2[KeyType.PATH] : keys[0];
      const pattern = isQueryPath ? query2[KeyType.PATTERN] : query2[key];
      if (!isString2(pattern)) {
        throw new Error(LOGICAL_SEARCH_INVALID_QUERY_FOR_KEY(key));
      }
      const obj = {
        keyId: createKeyId(key),
        pattern
      };
      if (auto) {
        obj.searcher = createSearcher(pattern, options);
      }
      return obj;
    }
    let node = {
      children: [],
      operator: keys[0]
    };
    keys.forEach((key) => {
      const value = query2[key];
      if (isArray(value)) {
        value.forEach((item2) => {
          node.children.push(next(item2));
        });
      }
    });
    return node;
  };
  if (!isExpression(query)) {
    query = convertToExplicit(query);
  }
  return next(query);
}
function computeScore(results, { ignoreFieldNorm = Config.ignoreFieldNorm }) {
  results.forEach((result) => {
    let totalScore = 1;
    result.matches.forEach(({ key, norm: norm2, score }) => {
      const weight = key ? key.weight : null;
      totalScore *= Math.pow(
        score === 0 && weight ? Number.EPSILON : score,
        (weight || 1) * (ignoreFieldNorm ? 1 : norm2)
      );
    });
    result.score = totalScore;
  });
}
function transformMatches(result, data) {
  const matches = result.matches;
  data.matches = [];
  if (!isDefined(matches)) {
    return;
  }
  matches.forEach((match3) => {
    if (!isDefined(match3.indices) || !match3.indices.length) {
      return;
    }
    const { indices, value } = match3;
    let obj = {
      indices,
      value
    };
    if (match3.key) {
      obj.key = match3.key.src;
    }
    if (match3.idx > -1) {
      obj.refIndex = match3.idx;
    }
    data.matches.push(obj);
  });
}
function transformScore(result, data) {
  data.score = result.score;
}
function format(results, docs, {
  includeMatches = Config.includeMatches,
  includeScore = Config.includeScore
} = {}) {
  const transformers = [];
  if (includeMatches)
    transformers.push(transformMatches);
  if (includeScore)
    transformers.push(transformScore);
  return results.map((result) => {
    const { idx } = result;
    const data = {
      item: docs[idx],
      refIndex: idx
    };
    if (transformers.length) {
      transformers.forEach((transformer) => {
        transformer(result, data);
      });
    }
    return data;
  });
}
var Fuse = class {
  constructor(docs, options = {}, index) {
    this.options = { ...Config, ...options };
    if (this.options.useExtendedSearch && false) {
      throw new Error(EXTENDED_SEARCH_UNAVAILABLE);
    }
    this._keyStore = new KeyStore(this.options.keys);
    this.setCollection(docs, index);
  }
  setCollection(docs, index) {
    this._docs = docs;
    if (index && !(index instanceof FuseIndex)) {
      throw new Error(INCORRECT_INDEX_TYPE);
    }
    this._myIndex = index || createIndex(this.options.keys, this._docs, {
      getFn: this.options.getFn,
      fieldNormWeight: this.options.fieldNormWeight
    });
  }
  add(doc) {
    if (!isDefined(doc)) {
      return;
    }
    this._docs.push(doc);
    this._myIndex.add(doc);
  }
  remove(predicate = () => false) {
    const results = [];
    for (let i = 0, len = this._docs.length; i < len; i += 1) {
      const doc = this._docs[i];
      if (predicate(doc, i)) {
        this.removeAt(i);
        i -= 1;
        len -= 1;
        results.push(doc);
      }
    }
    return results;
  }
  removeAt(idx) {
    this._docs.splice(idx, 1);
    this._myIndex.removeAt(idx);
  }
  getIndex() {
    return this._myIndex;
  }
  search(query, { limit = -1 } = {}) {
    const {
      includeMatches,
      includeScore,
      shouldSort,
      sortFn,
      ignoreFieldNorm
    } = this.options;
    let results = isString2(query) ? isString2(this._docs[0]) ? this._searchStringList(query) : this._searchObjectList(query) : this._searchLogical(query);
    computeScore(results, { ignoreFieldNorm });
    if (shouldSort) {
      results.sort(sortFn);
    }
    if (isNumber(limit) && limit > -1) {
      results = results.slice(0, limit);
    }
    return format(results, this._docs, {
      includeMatches,
      includeScore
    });
  }
  _searchStringList(query) {
    const searcher = createSearcher(query, this.options);
    const { records } = this._myIndex;
    const results = [];
    records.forEach(({ v: text3, i: idx, n: norm2 }) => {
      if (!isDefined(text3)) {
        return;
      }
      const { isMatch, score, indices } = searcher.searchIn(text3);
      if (isMatch) {
        results.push({
          item: text3,
          idx,
          matches: [{ score, value: text3, norm: norm2, indices }]
        });
      }
    });
    return results;
  }
  _searchLogical(query) {
    const expression = parse3(query, this.options);
    const evaluate = (node, item2, idx) => {
      if (!node.children) {
        const { keyId, searcher } = node;
        const matches = this._findMatches({
          key: this._keyStore.get(keyId),
          value: this._myIndex.getValueForItemAtKeyId(item2, keyId),
          searcher
        });
        if (matches && matches.length) {
          return [
            {
              idx,
              item: item2,
              matches
            }
          ];
        }
        return [];
      }
      const res = [];
      for (let i = 0, len = node.children.length; i < len; i += 1) {
        const child = node.children[i];
        const result = evaluate(child, item2, idx);
        if (result.length) {
          res.push(...result);
        } else if (node.operator === LogicalOperator.AND) {
          return [];
        }
      }
      return res;
    };
    const records = this._myIndex.records;
    const resultMap = {};
    const results = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (isDefined(item2)) {
        let expResults = evaluate(expression, item2, idx);
        if (expResults.length) {
          if (!resultMap[idx]) {
            resultMap[idx] = { idx, item: item2, matches: [] };
            results.push(resultMap[idx]);
          }
          expResults.forEach(({ matches }) => {
            resultMap[idx].matches.push(...matches);
          });
        }
      }
    });
    return results;
  }
  _searchObjectList(query) {
    const searcher = createSearcher(query, this.options);
    const { keys, records } = this._myIndex;
    const results = [];
    records.forEach(({ $: item2, i: idx }) => {
      if (!isDefined(item2)) {
        return;
      }
      let matches = [];
      keys.forEach((key, keyIndex) => {
        matches.push(
          ...this._findMatches({
            key,
            value: item2[keyIndex],
            searcher
          })
        );
      });
      if (matches.length) {
        results.push({
          idx,
          item: item2,
          matches
        });
      }
    });
    return results;
  }
  _findMatches({ key, value, searcher }) {
    if (!isDefined(value)) {
      return [];
    }
    let matches = [];
    if (isArray(value)) {
      value.forEach(({ v: text3, i: idx, n: norm2 }) => {
        if (!isDefined(text3)) {
          return;
        }
        const { isMatch, score, indices } = searcher.searchIn(text3);
        if (isMatch) {
          matches.push({
            score,
            key,
            value: text3,
            idx,
            norm: norm2,
            indices
          });
        }
      });
    } else {
      const { v: text3, n: norm2 } = value;
      const { isMatch, score, indices } = searcher.searchIn(text3);
      if (isMatch) {
        matches.push({ score, key, value: text3, norm: norm2, indices });
      }
    }
    return matches;
  }
};
Fuse.version = "6.6.2";
Fuse.createIndex = createIndex;
Fuse.parseIndex = parseIndex;
Fuse.config = Config;
{
  Fuse.parseQuery = parse3;
}
{
  register(ExtendedSearch);
}

// src/suggesters/suggestFile.ts
var FileSuggest = class extends import_obsidian5.AbstractInputSuggest {
  constructor(app2, inputEl, strategy, folder) {
    super(app2, inputEl);
    this.app = app2;
    this.inputEl = inputEl;
    this.strategy = strategy;
    this.folder = folder;
  }
  getSuggestions(input_str) {
    const all_files = pipe2(
      get_tfiles_from_folder(this.folder, this.app),
      E.map(A.map((file) => enrich_tfile(file, this.app)))
    );
    if (E.isLeft(all_files)) {
      return [];
    }
    const lower_input_str = input_str.toLowerCase();
    if (input_str === "")
      return all_files.right;
    const fuse = new Fuse(all_files.right, {
      includeMatches: false,
      includeScore: true,
      shouldSort: true,
      keys: [
        { name: "path", weight: 2 },
        { name: "tags", weight: 1 },
        { name: "frontmatter.aliases", weight: 2 }
      ]
    });
    return fuse.search(lower_input_str).map((result) => {
      return result.item;
    });
  }
  /* This is an example structure of how a obsidian suggestion looks like in the dom
          <div class="suggestion">
              <div class="suggestion-item mod-complex is-selected">
                  <div class="suggestion-content">
                      <div class="suggestion-title">
                          <span class="suggestion-highlight">Ftima</span>
                      </div>
                      <div class="suggestion-note">Ftima</div>
                  </div>
                  <div class="suggestion-aux">
                      <span class="suggestion-flair" aria-label="Alias">
                          <svg xmlns="http://www.w3.org/2000/svg" width="24" height="24" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2" stroke-linecap="round" stroke-linejoin="round" class="svg-icon lucide-forward">
                              <polyline points="15 17 20 12 15 7"></polyline>
                              <path d="M4 18v-2a4 4 0 0 1 4-4h12"></path>
                          </svg>
                      </span>
                  </div>
              </div>
          </div>
  In the renderSuggestion the `el` is the suggestion-item div
  */
  renderSuggestion(file, el) {
    var _a;
    const text3 = this.strategy.renderSuggestion(file);
    el.addClasses(["mod-complex"]);
    const title = el.createDiv({ cls: "suggestion-title", text: text3 });
    const subtitle = el.createDiv({
      cls: "suggestion-note modal-form-suggestion",
      text: (_a = file.parent) == null ? void 0 : _a.path
    });
    const icon = el.createSpan({ cls: "suggestion-icon" });
    (0, import_obsidian5.setIcon)(icon, "folder");
    subtitle.prepend(icon);
    const body = el.createDiv({ cls: "suggestion-content" });
    body.appendChild(title);
    body.appendChild(subtitle);
    el.appendChild(body);
  }
  selectSuggestion(file) {
    this.inputEl.value = this.strategy.selectSuggestion(file);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/suggestFromDataview.ts
var import_obsidian6 = require("obsidian");

// src/suggesters/SafeDataviewQuery.ts
function sandboxedDvQuery(query) {
  if (!query.startsWith("return")) {
    query = "return " + query;
  }
  const parsed = parseFunctionBody(query, "dv", "pages");
  return (dv, pages) => pipe2(
    parsed,
    E.mapLeft(
      (err) => new ModalFormError("Error evaluating the dataview query", err.message)
    ),
    E.flatMap((fn) => fn(dv, pages)),
    E.flatMap((result) => {
      if (!Array.isArray(result)) {
        return E.left(new ModalFormError("The dataview query did not return an array"));
      }
      return E.right(result);
    })
  );
}
function executeSandboxedDvQuery(query, app2, logger = log_error) {
  var _a;
  const dv = (_a = app2.plugins.plugins.dataview) == null ? void 0 : _a.api;
  if (!dv) {
    logger(new ModalFormError("Dataview plugin is not enabled"));
    return [];
  }
  const pages = dv.pages;
  return pipe2(
    query(dv, pages),
    E.getOrElse((e) => {
      logger(e);
      return [];
    })
  );
}

// src/suggesters/createRegexFromInput.ts
var splitString = flow2(trim, split(" "));
function createRegexFromInput(input) {
  return pipe2(
    fromNullable2(input),
    map3(splitString),
    map3((parts) => parts.join(".*")),
    map3((s) => new RegExp(s, "i")),
    getOrElse2(() => new RegExp(".*"))
  );
}

// src/suggesters/suggestFromDataview.ts
var DataviewSuggest = class extends import_obsidian6.AbstractInputSuggest {
  constructor(inputEl, dvQuery, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.app = app2;
    this.sandboxedQuery = sandboxedDvQuery(dvQuery);
  }
  getSuggestions(inputStr) {
    const result = executeSandboxedDvQuery(this.sandboxedQuery, this.app);
    if (!inputStr) {
      return result;
    }
    const regex = createRegexFromInput(inputStr);
    return result.filter((r) => regex.test(r));
  }
  renderSuggestion(option, el) {
    el.setText(option);
  }
  selectSuggestion(option) {
    this.inputEl.value = option;
    this.inputEl.trigger("input");
    this.close();
  }
};

// node_modules/svelte/src/runtime/store/index.js
var subscriber_queue = [];
function readable(value, start) {
  return {
    subscribe: writable(value, start).subscribe
  };
}
function writable(value, start = noop) {
  let stop;
  const subscribers = /* @__PURE__ */ new Set();
  function set2(new_value) {
    if (safe_not_equal(value, new_value)) {
      value = new_value;
      if (stop) {
        const run_queue = !subscriber_queue.length;
        for (const subscriber of subscribers) {
          subscriber[1]();
          subscriber_queue.push(subscriber, value);
        }
        if (run_queue) {
          for (let i = 0; i < subscriber_queue.length; i += 2) {
            subscriber_queue[i][0](subscriber_queue[i + 1]);
          }
          subscriber_queue.length = 0;
        }
      }
    }
  }
  function update3(fn) {
    set2(fn(value));
  }
  function subscribe3(run3, invalidate = noop) {
    const subscriber = [run3, invalidate];
    subscribers.add(subscriber);
    if (subscribers.size === 1) {
      stop = start(set2, update3) || noop;
    }
    run3(value);
    return () => {
      subscribers.delete(subscriber);
      if (subscribers.size === 0 && stop) {
        stop();
        stop = null;
      }
    };
  }
  return { set: set2, update: update3, subscribe: subscribe3 };
}
function derived(stores, fn, initial_value) {
  const single = !Array.isArray(stores);
  const stores_array = single ? [stores] : stores;
  if (!stores_array.every(Boolean)) {
    throw new Error("derived() expects stores as input, got a falsy value");
  }
  const auto = fn.length < 2;
  return readable(initial_value, (set2, update3) => {
    let started = false;
    const values = [];
    let pending = 0;
    let cleanup = noop;
    const sync = () => {
      if (pending) {
        return;
      }
      cleanup();
      const result = fn(single ? values[0] : values, set2, update3);
      if (auto) {
        set2(result);
      } else {
        cleanup = is_function(result) ? result : noop;
      }
    };
    const unsubscribers = stores_array.map(
      (store, i) => subscribe(
        store,
        (value) => {
          values[i] = value;
          pending &= ~(1 << i);
          if (started) {
            sync();
          }
        },
        () => {
          pending |= 1 << i;
        }
      )
    );
    started = true;
    sync();
    return function stop() {
      run_all(unsubscribers);
      cleanup();
      started = false;
    };
  });
}

// src/store/formStore.ts
function requiredRule(fieldName, message) {
  return { tag: "required", message: message != null ? message : `'${fieldName}' is required` };
}
function FieldFailed(field, failedRule) {
  return { ...field, rules: failedRule, errors: [failedRule.message] };
}
function nonEmptyValue(s) {
  switch (typeof s) {
    case "string":
      return s.length > 0 ? some3(s) : none2;
    case "number":
    case "boolean":
      return some3(s);
    case "object":
      return Array.isArray(s) ? s.length > 0 ? some3(s) : none2 : none2;
    default:
      return absurd(s);
  }
}
function parseField(field) {
  if (!field.rules)
    return right3(field);
  const rule = field.rules;
  switch (rule.tag) {
    case "required":
      return pipe2(
        field.value,
        chain2(nonEmptyValue),
        match2(
          () => left3(FieldFailed(field, rule)),
          (value) => right3(field)
        )
      );
    default:
      return absurd(rule.tag);
  }
}
function parseForm(fields) {
  const { right: ok, left: failed } = pipe2(
    fields,
    Object.values,
    map2(parseField),
    separate
  );
  if (failed.length > 0)
    return left3(failed);
  return right3(
    pipe2(
      ok,
      map2(
        (field) => pipe2(
          field.value,
          map3((value) => [field.name, value])
        )
      ),
      compact,
      fromEntries
    )
  );
}
function makeFormEngine(onSubmit, defaultValues = {}) {
  const formStore = writable({ fields: {} });
  function setFormField(name) {
    function initField(errors = [], rules) {
      formStore.update((form) => {
        return {
          ...form,
          fields: {
            ...form.fields,
            [name]: { value: fromNullable2(defaultValues[name]), name, errors, rules }
          }
        };
      });
    }
    function setValue(value) {
      formStore.update((form) => {
        const field = form.fields[name];
        if (!field) {
          console.error(new Error(`Field ${name} does not exist`));
          return form;
        }
        return {
          ...form,
          fields: {
            ...form.fields,
            [name]: { ...field, value: some3(value), errors: [] }
          }
        };
      });
    }
    return { initField, setValue };
  }
  function setErrors(failedFields) {
    formStore.update((form) => {
      return pipe2(
        failedFields,
        reduce2(form, (form2, field) => {
          return {
            ...form2,
            fields: { ...form2.fields, [field.name]: field }
          };
        })
      );
    });
  }
  return {
    subscribe: formStore.subscribe,
    isValid: derived(
      formStore,
      ({ fields }) => pipe2(
        fields,
        toEntries,
        some2(([_, f]) => f.errors.length > 0),
        (x) => !x
      )
    ),
    triggerSubmit() {
      const formState = get_store_value(formStore);
      pipe2(
        formState.fields,
        parseForm,
        match(setErrors, onSubmit)
      );
    },
    addField: (field) => {
      const { initField: setField, setValue } = setFormField(field.name);
      setField(
        [],
        field.isRequired ? requiredRule(field.label || field.name) : void 0
      );
      const fieldStore = derived(
        formStore,
        ({ fields }) => fields[field.name]
      );
      const fieldValueStore = {
        subscribe(cb) {
          return fieldStore.subscribe(
            (x) => pipe2(
              x,
              fromNullable2,
              chain2((x2) => x2.value),
              map3(cb)
            )
          );
        },
        set(value) {
          setValue(value);
        },
        update: (updater) => {
          formStore.update((form) => {
            const current = form.fields[field.name];
            if (!current) {
              console.error(
                new Error(`Field ${field.name} does not exist`)
              );
              return form;
            }
            const newValue = pipe2(
              current.value,
              map3(updater)
            );
            return {
              ...form,
              fields: {
                ...form.fields,
                [field.name]: {
                  ...current,
                  value: newValue,
                  errors: []
                }
              }
            };
          });
        }
      };
      return {
        value: fieldValueStore,
        errors: derived(
          formStore,
          ({ fields }) => {
            var _a, _b;
            return (_b = (_a = fields[field.name]) == null ? void 0 : _a.errors) != null ? _b : [];
          }
        )
      };
    }
  };
}

// src/suggesters/suggestFolder.ts
var import_obsidian7 = require("obsidian");
var FolderSuggest = class extends import_obsidian7.AbstractInputSuggest {
  constructor(inputEl, app2) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.app = app2;
  }
  getSuggestions(inputStr) {
    const abstractFiles = this.app.vault.getAllLoadedFiles();
    const lowerCaseInputStr = inputStr.toLowerCase();
    const folders = abstractFiles.reduce((acc, folder) => {
      if (folder instanceof import_obsidian7.TFolder && folder.path.toLowerCase().contains(lowerCaseInputStr)) {
        acc.push(folder);
      }
      return acc;
    }, []);
    return folders;
  }
  renderSuggestion(file, el) {
    el.setText(file.path);
  }
  selectSuggestion(file) {
    this.inputEl.value = file.path;
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/StringSuggest.ts
var import_obsidian8 = require("obsidian");
var StringSuggest = class extends import_obsidian8.AbstractInputSuggest {
  constructor(inputEl, content, onSelectCb, app2, allowUnknownValues = false) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.onSelectCb = onSelectCb;
    this.allowUnknownValues = allowUnknownValues;
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLocaleLowerCase();
    const candidates = this.allowUnknownValues && inputStr !== "" ? [...this.content, inputStr] : Array.from(this.content);
    return candidates.filter(
      (content) => content.toLocaleLowerCase().contains(lowerCaseInputStr)
    );
  }
  renderSuggestion(content, el) {
    el.setText(content);
  }
  selectSuggestion(content, evt) {
    this.onSelectCb(content);
    this.inputEl.value = "";
    this.close();
    this.inputEl.focus();
  }
};

// src/views/components/MultiSelectModel.ts
function MultiSelectModel(fieldInput, app2, values) {
  const source = fieldInput.source;
  const removeValue = (value) => values.update(
    (xs) => pipe2(
      xs,
      A.filter((x) => x !== value)
    )
  );
  switch (source) {
    case "dataview":
    case "fixed": {
      const remainingOptions = new Set(
        source === "fixed" ? fieldInput.multi_select_options : executeSandboxedDvQuery(sandboxedDvQuery(fieldInput.query), app2)
      );
      return {
        createInput(element2) {
          new StringSuggest(
            element2,
            remainingOptions,
            (selected) => {
              remainingOptions.delete(selected);
              values.update((x) => [...x, selected]);
            },
            app2,
            fieldInput.allowUnknownValues
          );
        },
        removeValue(value) {
          remainingOptions.add(value);
          removeValue(value);
        }
      };
    }
    case "notes": {
      return {
        createInput(element2) {
          new FileSuggest(
            app2,
            element2,
            {
              renderSuggestion(file) {
                return file.basename;
              },
              selectSuggestion(file) {
                values.update((x) => [...x, file.basename]);
                return "";
              }
            },
            fieldInput.folder
          );
        },
        removeValue
      };
    }
    default:
      return absurd(source);
  }
}
function MultiSelectTags(fieldInput, app2, values) {
  const remainingOptions = new Set(
    Object.keys(app2.metadataCache.getTags()).map(
      (tag) => tag.slice(1)
    )
  );
  return {
    createInput(element2) {
      new StringSuggest(
        element2,
        remainingOptions,
        (selected) => {
          remainingOptions.delete(selected);
          values.update((x) => [...x, selected]);
        },
        app2,
        true
      );
    },
    removeValue(value) {
      remainingOptions.add(value);
      values.update(
        (x) => pipe2(
          x,
          A.filter((x2) => x2 !== value)
        )
      );
    }
  };
}

// src/FormModal.ts
var notify = throttle(
  (msg) => log_notice("\u26A0\uFE0F  The form has errors \u26A0\uFE0F", msg, "notice-warning"),
  2e3
);
var notifyError2 = (title) => throttle((msg) => log_notice(`\u{1F6A8} ${title} \u{1F6A8}`, msg, "notice-error"), 2e3);
var FormModal = class extends import_obsidian9.Modal {
  constructor(app2, modalDefinition, onSubmit, options) {
    var _a;
    super(app2);
    this.modalDefinition = modalDefinition;
    this.onSubmit = onSubmit;
    this.svelteComponents = [];
    this.subscriptions = [];
    this.initialFormValues = formDataFromFormDefaults(
      modalDefinition.fields,
      (_a = options == null ? void 0 : options.values) != null ? _a : {}
    );
    this.formEngine = makeFormEngine((result) => {
      this.onSubmit(FormResult.make(result, "ok"));
      this.close();
    }, this.initialFormValues);
  }
  onOpen() {
    const { contentEl } = this;
    contentEl.addClass("modal-form");
    if (this.modalDefinition.customClassname)
      contentEl.addClass(this.modalDefinition.customClassname);
    contentEl.createEl("h1", { text: this.modalDefinition.title });
    this.modalDefinition.fields.forEach((definition) => {
      var _a;
      const name = definition.label || definition.name;
      const required = (_a = definition.isRequired) != null ? _a : false;
      const fieldBase = new import_obsidian9.Setting(contentEl).setName(`${name} ${required ? "*" : ""}`.trim()).setDesc(definition.description);
      const fieldInput = definition.input;
      const type = fieldInput.type;
      const initialValue = this.initialFormValues[definition.name];
      const fieldStore = this.formEngine.addField(definition);
      const subToErrors = (input) => {
        this.subscriptions.push(
          fieldStore.errors.subscribe((errs) => {
            errs.length > 0 ? console.log("errors", errs) : void 0;
            errs.forEach(notify);
            input.setCustomValidity(errs.join("\n"));
          })
        );
      };
      switch (type) {
        case "textarea": {
          fieldBase.setClass("modal-form-textarea");
          return fieldBase.addTextArea((textEl) => {
            textEl.onChange(fieldStore.value.set);
            subToErrors(textEl.inputEl);
            if (typeof initialValue === "string") {
              textEl.setValue(initialValue);
            }
            textEl.inputEl.rows = 6;
            if (import_obsidian9.Platform.isIosApp)
              textEl.inputEl.style.width = "100%";
            else if (import_obsidian9.Platform.isDesktopApp) {
              textEl.inputEl.rows = 10;
            }
          });
        }
        case "email":
        case "tel":
        case "date":
        case "time":
        case "text":
          return fieldBase.addText((text3) => {
            text3.inputEl.type = type;
            subToErrors(text3.inputEl);
            text3.onChange(fieldStore.value.set);
            initialValue !== void 0 && text3.setValue(String(initialValue));
          });
        case "number":
          return fieldBase.addText((text3) => {
            text3.inputEl.type = "number";
            text3.inputEl.step = "any";
            subToErrors(text3.inputEl);
            text3.onChange((val) => {
              if (val !== "") {
                fieldStore.value.set(Number(val) + "");
              }
            });
            initialValue !== void 0 && text3.setValue(String(initialValue));
          });
        case "datetime":
          return fieldBase.addText((text3) => {
            text3.inputEl.type = "datetime-local";
            initialValue !== void 0 && text3.setValue(String(initialValue));
            subToErrors(text3.inputEl);
            text3.onChange(fieldStore.value.set);
          });
        case "toggle":
          return fieldBase.addToggle((toggle) => {
            toggle.setValue(!!initialValue);
            return toggle.onChange(fieldStore.value.set);
          });
        case "note":
          return fieldBase.addText((element2) => {
            new FileSuggest(
              this.app,
              element2.inputEl,
              {
                renderSuggestion(file) {
                  return file.basename;
                },
                selectSuggestion(file) {
                  return file.basename;
                }
              },
              fieldInput.folder
            );
            subToErrors(element2.inputEl);
            element2.onChange(fieldStore.value.set);
          });
        case "folder":
          return fieldBase.addText((element2) => {
            new FolderSuggest(element2.inputEl, this.app);
            subToErrors(element2.inputEl);
            element2.onChange(fieldStore.value.set);
          });
        case "slider":
          return fieldBase.addSlider((slider) => {
            slider.setLimits(fieldInput.min, fieldInput.max, 1);
            slider.setDynamicTooltip();
            if (typeof initialValue === "number") {
              slider.setValue(initialValue);
            } else {
              slider.setValue(fieldInput.min);
            }
            slider.onChange(fieldStore.value.set);
          });
        case "multiselect": {
          fieldStore.value.set(initialValue != null ? initialValue : []);
          this.svelteComponents.push(
            new MultiSelect_default({
              target: fieldBase.controlEl,
              props: {
                model: MultiSelectModel(
                  fieldInput,
                  this.app,
                  fieldStore.value
                ),
                values: fieldStore.value,
                errors: fieldStore.errors,
                setting: fieldBase
              }
            })
          );
          return;
        }
        case "tag": {
          fieldStore.value.set(initialValue != null ? initialValue : []);
          this.svelteComponents.push(
            new MultiSelect_default({
              target: fieldBase.controlEl,
              props: {
                values: fieldStore.value,
                setting: fieldBase,
                errors: fieldStore.errors,
                model: MultiSelectTags(
                  fieldInput,
                  this.app,
                  fieldStore.value
                )
              }
            })
          );
          return;
        }
        case "dataview": {
          const query = fieldInput.query;
          return fieldBase.addText((element2) => {
            new DataviewSuggest(element2.inputEl, query, this.app);
            element2.onChange(fieldStore.value.set);
            subToErrors(element2.inputEl);
          });
        }
        case "select": {
          const source = fieldInput.source;
          switch (source) {
            case "fixed":
              return fieldBase.addDropdown((element2) => {
                fieldInput.options.forEach((option) => {
                  element2.addOption(option.value, option.label);
                });
                fieldStore.value.set(element2.getValue());
                element2.onChange(fieldStore.value.set);
              });
            case "notes":
              return fieldBase.addDropdown((element2) => {
                const files = get_tfiles_from_folder(fieldInput.folder, this.app);
                pipe2(
                  files,
                  E.map(
                    (files2) => files2.reduce((acc, option) => {
                      acc[option.basename] = option.basename;
                      return acc;
                    }, {})
                  ),
                  E.mapLeft((err) => {
                    log_error(err);
                    return err;
                  }),
                  E.map((options) => {
                    element2.addOptions(options);
                  })
                );
                fieldStore.value.set(element2.getValue());
                element2.onChange(fieldStore.value.set);
              });
            default:
              absurd2(source);
          }
          break;
        }
        case "document_block": {
          const functionBody = fieldInput.body;
          const functionParsed = parseFunctionBody(
            functionBody,
            "form"
          );
          const domNode = fieldBase.infoEl.createDiv();
          const sub = this.formEngine.subscribe((form) => {
            pipe2(
              functionParsed,
              E.chainW(
                (fn) => pipe2(
                  form.fields,
                  filterMap3((field) => field.value),
                  fn
                )
              ),
              E.match(
                (error2) => {
                  console.error(error2);
                  notifyError2("Error in document block")(String(error2));
                },
                (newText) => domNode.setText((0, import_obsidian9.sanitizeHTMLToDom)(newText))
              )
            );
          });
          return this.subscriptions.push(sub);
        }
        default:
          return absurd2(type);
      }
    });
    new import_obsidian9.Setting(contentEl).addButton(
      (btn) => btn.setButtonText("Submit").setCta().onClick(this.formEngine.triggerSubmit)
    );
    const submitEnterCallback = (evt) => {
      if ((evt.ctrlKey || evt.metaKey) && evt.key === "Enter") {
        evt.preventDefault();
        this.formEngine.triggerSubmit();
      }
    };
    contentEl.addEventListener("keydown", submitEnterCallback);
  }
  onClose() {
    const { contentEl } = this;
    this.svelteComponents.forEach((component) => component.$destroy());
    this.subscriptions.forEach((subscription) => subscription());
    contentEl.empty();
    this.initialFormValues = {};
  }
};

// src/API.ts
function isPickOption(opts) {
  return "pick" in opts && Array.isArray(opts.pick);
}
function isOmitOption(opts) {
  return "omit" in opts && Array.isArray(opts.omit);
}
var API = class {
  /**
   * Constructor for the API class
   * @param {App} app - The application instance
   * @param {typeof ModalFormPlugin} plugin - The plugin instance
   */
  constructor(app2, plugin) {
    this.app = app2;
    this.plugin = plugin;
    /**
     * What this plugin considers its standard library
     * Because it is bundled with the plugin anyway, I think
     * it makes sense to expose it to the user
     */
    this.std = std_exports;
    this.util = {
      getAliases: flow2(
        (name) => resolve_tfile(name, this.app),
        E.map((f) => this.app.metadataCache.getCache(f.path)),
        E.chainW(E.fromNullable(new Error("No cache found"))),
        E.map((tf) => (0, import_obsidian10.parseFrontMatterAliases)(tf.frontmatter)),
        E.match(
          () => [],
          (aliases) => aliases
        )
      ),
      getFile: flow2(
        resolve_tfile,
        E.map((f) => enrich_tfile(f, this.app))
      )
    };
  }
  /**
   * Opens a modal form with the provided form definition
   * @param {FormDefinition} formDefinition - The form definition to use
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   */
  openModalForm(formDefinition, options) {
    return new Promise((resolve) => {
      new FormModal(this.app, formDefinition, resolve, options).open();
    });
  }
  exampleForm(options) {
    return this.openModalForm(exampleModalDefinition, options);
  }
  getFormByName(name) {
    var _a;
    const form = (_a = this.plugin.settings) == null ? void 0 : _a.formDefinitions.find((form2) => form2.name === name);
    if (form instanceof MigrationError) {
      log_notice(
        "\u{1F6AB} The form you tried to load has an invalid format",
        `The form "${name}" has an invalid format.We tried to automatically convert it but it failed, please fix it manually in the forms manager.
            `
      );
      return void 0;
    } else {
      return form;
    }
  }
  /**
   * Opens a named form
   * @param {string} name - The name of the form to open
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form definition is not found
   */
  namedForm(name, options) {
    const formDefinition = this.getFormByName(name);
    if (formDefinition) {
      return this.openModalForm(formDefinition, options);
    } else {
      const error2 = new ModalFormError(`Form definition ${name} not found`);
      log_error(error2);
      return Promise.reject(error2);
    }
  }
  /**
   * Opens a named form, limiting/filtering the fields included
   * @param {string} name - The name of the form to open
   * @param {limitOptions} limitOpts - The options to apply when filtering fields 
   * @param {FormOptions} formOpts - Form options to use when opening the form once filtered
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form definition is not found
   */
  limitedForm(name, limitOpts, formOpts) {
    const formDefinition = this.getFormByName(name);
    let newFormDefinition;
    if (formDefinition) {
      if (isOmitOption(limitOpts)) {
        const omit = limitOpts.omit;
        newFormDefinition = {
          ...formDefinition,
          fields: formDefinition.fields.filter((field) => !omit.includes(field.name))
        };
      } else if (isPickOption(limitOpts)) {
        newFormDefinition = {
          ...formDefinition,
          fields: formDefinition.fields.filter((field) => limitOpts.pick.includes(field.name))
        };
      } else {
        throw new ModalFormError(
          "Invalid limit options provided to limitedForm",
          `GOT: ${JSON.stringify(limitOpts)}`
        );
      }
      return this.openModalForm(newFormDefinition, formOpts);
    } else {
      const error2 = new ModalFormError(`Form definition ${name} not found`);
      log_error(error2);
      return Promise.reject(error2);
    }
  }
  /**
   * Opens a form with the provided form reference
   * @param {string | FormDefinition} formReference - The form reference, either a form name of an existing form or an inline form definition
   * @returns {Promise<FormResult>} - A promise that resolves with the form result
   * @throws {ModalFormError} - Throws an error if the form reference is not found
   */
  openForm(formReference, options) {
    if (typeof formReference === "string") {
      return this.namedForm(formReference, options);
    } else {
      return this.openModalForm(formReference, options);
    }
  }
};

// src/views/EditFormView.ts
var import_obsidian15 = require("obsidian");

// src/core/formDefinition.ts
var InputTypeReadable = {
  text: "Text",
  number: "Number",
  tag: "Tags",
  email: "Email",
  tel: "Phone",
  date: "Date",
  time: "Time",
  datetime: "DateTime",
  textarea: "Text area",
  toggle: "Toggle",
  note: "Note",
  folder: "Folder",
  slider: "Slider",
  select: "Select",
  dataview: "Dataview",
  multiselect: "Multiselect",
  document_block: "Document block"
};
function validateFields(fields) {
  const result = safeParse(FieldListSchema, fields);
  if (result.success) {
    return [];
  }
  console.error("Fields issues", result.issues);
  return result.issues.map((issue) => {
    var _a, _b, _c, _d;
    return {
      message: issue.message,
      path: (_a = issue.path) == null ? void 0 : _a.map((item2) => item2.key).join("."),
      index: (_d = (_c = (_b = issue.path) == null ? void 0 : _b[0]) == null ? void 0 : _c.key) != null ? _d : 0
    };
  });
}
function isValidFormDefinition(input) {
  if (!is(FormDefinitionBasicSchema, input)) {
    return false;
  }
  const fieldsAreValid = is(FieldListSchema, input.fields);
  if (!fieldsAreValid) {
    return false;
  }
  return true;
}
function duplicateForm(formName, forms) {
  return pipe2(
    forms,
    A.findFirstMap((f) => {
      if (f instanceof MigrationError) {
        return O.none;
      }
      if (f.name === formName) {
        return O.some(f);
      }
      return O.none;
    }),
    O.map((f) => {
      let newName = f.name + "-copy";
      let i = 1;
      while (forms.some((f2) => f2.name === newName)) {
        newName = f.name + "-copy-" + i;
        i++;
      }
      return { ...f, name: newName };
    }),
    O.map((f) => {
      return [...forms, f];
    }),
    O.getOrElse(() => forms)
  );
}

// src/views/FormBuilder.svelte
var import_obsidian14 = require("obsidian");

// src/views/components/FormRow.svelte
function add_css2(target) {
  append_styles(target, "svelte-1xgum2", ".field-goup.svelte-1xgum2{display:flex;flex-direction:column;gap:0.5rem}.hidden-label.svelte-1xgum2{white-space:nowrap;overflow:hidden;visibility:hidden}");
}
function create_fragment2(ctx) {
  let div;
  let label_1;
  let t0;
  let t1;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[4].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[3],
    null
  );
  return {
    c() {
      div = element("div");
      label_1 = element("label");
      t0 = text(
        /*label*/
        ctx[0]
      );
      t1 = space();
      if (default_slot)
        default_slot.c();
      attr(
        label_1,
        "for",
        /*id*/
        ctx[1]
      );
      attr(label_1, "class", "svelte-1xgum2");
      toggle_class(
        label_1,
        "hidden-label",
        /*hideLabel*/
        ctx[2]
      );
      attr(div, "class", "field-goup svelte-1xgum2");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, label_1);
      append5(label_1, t0);
      append5(div, t1);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*label*/
      1)
        set_data(
          t0,
          /*label*/
          ctx2[0]
        );
      if (!current || dirty & /*id*/
      2) {
        attr(
          label_1,
          "for",
          /*id*/
          ctx2[1]
        );
      }
      if (!current || dirty & /*hideLabel*/
      4) {
        toggle_class(
          label_1,
          "hidden-label",
          /*hideLabel*/
          ctx2[2]
        );
      }
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        8)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[3],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[3]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[3],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance2($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { label } = $$props;
  let { id } = $$props;
  let { hideLabel = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("label" in $$props2)
      $$invalidate(0, label = $$props2.label);
    if ("id" in $$props2)
      $$invalidate(1, id = $$props2.id);
    if ("hideLabel" in $$props2)
      $$invalidate(2, hideLabel = $$props2.hideLabel);
    if ("$$scope" in $$props2)
      $$invalidate(3, $$scope = $$props2.$$scope);
  };
  return [label, id, hideLabel, $$scope, slots];
}
var FormRow = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance2, create_fragment2, safe_not_equal, { label: 0, id: 1, hideLabel: 2 }, add_css2);
  }
};
var FormRow_default = FormRow;

// src/views/components/Code.svelte
function add_css3(target) {
  append_styles(target, "svelte-1ovxcwm", "pre.svelte-1ovxcwm{background-color:var(--background-secondary);border-radius:var(--border-radius);padding:0.5rem}code.svelte-1ovxcwm{font-family:var(--font-family-monospace)}code.allowWrap.svelte-1ovxcwm{white-space:pre-wrap}div.svelte-1ovxcwm{display:flex}");
}
function create_fragment3(ctx) {
  let div;
  let pre;
  let code;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      pre = element("pre");
      code = element("code");
      if (default_slot)
        default_slot.c();
      attr(code, "class", "svelte-1ovxcwm");
      toggle_class(
        code,
        "allowWrap",
        /*allowWrap*/
        ctx[0]
      );
      attr(pre, "class", "svelte-1ovxcwm");
      attr(div, "class", "svelte-1ovxcwm");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, pre);
      append5(pre, code);
      if (default_slot) {
        default_slot.m(code, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
      if (!current || dirty & /*allowWrap*/
      1) {
        toggle_class(
          code,
          "allowWrap",
          /*allowWrap*/
          ctx2[0]
        );
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance3($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { allowWrap = false } = $$props;
  $$self.$$set = ($$props2) => {
    if ("allowWrap" in $$props2)
      $$invalidate(0, allowWrap = $$props2.allowWrap);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [allowWrap, $$scope, slots];
}
var Code = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance3, create_fragment3, safe_not_equal, { allowWrap: 0 }, add_css3);
  }
};
var Code_default = Code;

// src/views/components/inputBuilderDataview.svelte
function add_css4(target) {
  append_styles(target, "svelte-ddsol2", "h6.svelte-ddsol2{margin-bottom:0}");
}
function create_if_block(ctx) {
  let div;
  let t;
  return {
    c() {
      div = element("div");
      t = text(
        /*error*/
        ctx[1]
      );
      attr(div, "class", "modal-form-error-message");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*error*/
      2)
        set_data(
          t,
          /*error*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
    }
  };
}
function create_default_slot_1(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*preview*/
        ctx[2]
      );
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*preview*/
      4)
        set_data(
          t,
          /*preview*/
          ctx2[2]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_default_slot(ctx) {
  let span;
  let t8;
  let textarea;
  let t9;
  let h6;
  let t11;
  let t12;
  let code2;
  let current;
  let mounted;
  let dispose;
  let if_block = (
    /*error*/
    ctx[1] && create_if_block(ctx)
  );
  code2 = new Code_default({
    props: {
      allowWrap: true,
      $$slots: { default: [create_default_slot_1] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      span = element("span");
      span.innerHTML = `This is a <a href="https://blacksmithgu.github.io/obsidian-dataview/api/intro/">Dataview</a>
        query that will be used to populate the input suggestions. You should provide a query that returns
        a list of strings, for example:
        <pre class="language-js"><code>dv.pages(&#39;#tag&#39;).map(p =&gt; p.file.name)</code></pre>
        It is recommended to take advantage of<a href="https://blacksmithgu.github.io/obsidian-dataview/api/data-array">Swizzling</a>
        to write shorter queries:
        <pre class="language-js"><code>dv.pages(&#39;#tag&#39;).file.name</code></pre>`;
      t8 = space();
      textarea = element("textarea");
      t9 = space();
      h6 = element("h6");
      h6.textContent = "Results preview";
      t11 = space();
      if (if_block)
        if_block.c();
      t12 = space();
      create_component(code2.$$.fragment);
      attr(span, "class", "modal-form-hint");
      attr(
        textarea,
        "id",
        /*id*/
        ctx[3]
      );
      attr(textarea, "name", "dataview_query");
      attr(textarea, "class", "form-control");
      attr(textarea, "rows", "3");
      attr(textarea, "placeholder", "dv.pages('#tag').map(p => p.file.name)");
      attr(h6, "class", "svelte-ddsol2");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      insert(target, t8, anchor);
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      insert(target, t9, anchor);
      insert(target, h6, anchor);
      insert(target, t11, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, t12, anchor);
      mount_component(code2, target, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[6]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (!current || dirty & /*id*/
      8) {
        attr(
          textarea,
          "id",
          /*id*/
          ctx2[3]
        );
      }
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx2[0]
        );
      }
      if (
        /*error*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block(ctx2);
          if_block.c();
          if_block.m(t12.parentNode, t12);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      const code2_changes = {};
      if (dirty & /*$$scope, preview*/
      516) {
        code2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      code2.$set(code2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(code2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(code2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t8);
        detach(textarea);
        detach(t9);
        detach(h6);
        detach(t11);
        detach(t12);
      }
      if (if_block)
        if_block.d(detaching);
      destroy_component(code2, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment4(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Dataview Query",
      id: (
        /*id*/
        ctx[3]
      ),
      $$slots: { default: [create_default_slot] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      8)
        formrow_changes.id = /*id*/
        ctx2[3];
      if (dirty & /*$$scope, preview, error, id, value*/
      527) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function instance4($$self, $$props, $$invalidate) {
  let id;
  let preview;
  let { index } = $$props;
  let { value = "" } = $$props;
  let { app: app2 } = $$props;
  let error2 = "";
  const logger = (err) => $$invalidate(1, error2 = err.message);
  const makePreview = function(query) {
    $$invalidate(1, error2 = "");
    return pipe2(query, sandboxedDvQuery, (query2) => executeSandboxedDvQuery(query2, app2, logger));
  };
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(4, index = $$props2.index);
    if ("value" in $$props2)
      $$invalidate(0, value = $$props2.value);
    if ("app" in $$props2)
      $$invalidate(5, app2 = $$props2.app);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    16) {
      $:
        $$invalidate(3, id = `dataview_${index}`);
    }
    if ($$self.$$.dirty & /*value*/
    1) {
      $:
        $$invalidate(2, preview = makePreview(value));
    }
  };
  return [value, error2, preview, id, index, app2, textarea_input_handler];
}
var InputBuilderDataview = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance4, create_fragment4, safe_not_equal, { index: 4, value: 0, app: 5 }, add_css4);
  }
};
var inputBuilderDataview_default = InputBuilderDataview;

// src/views/components/InputBuilderSelect.svelte
var import_obsidian12 = require("obsidian");

// src/views/components/InputFolder.svelte
var import_obsidian11 = require("obsidian");
function create_fragment5(ctx) {
  let div;
  let label;
  let t;
  let searchFolder_action;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      label = element("label");
      t = text("Source Folder");
      attr(
        label,
        "for",
        /*id*/
        ctx[0]
      );
      attr(div, "class", "modal-form flex column gap1 remove-padding remove-border fix-suggest");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, label);
      append5(label, t);
      if (!mounted) {
        dispose = action_destroyer(searchFolder_action = /*searchFolder*/
        ctx[1].call(null, div));
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*id*/
      1) {
        attr(
          label,
          "for",
          /*id*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function instance5($$self, $$props, $$invalidate) {
  let id;
  let { index } = $$props;
  let { folder = "" } = $$props;
  let { notifyChange } = $$props;
  function searchFolder(element2) {
    new import_obsidian11.Setting(element2).addSearch((search2) => {
      search2.setPlaceholder("Select a folder");
      search2.setValue(folder);
      new FolderSuggest(search2.inputEl, app);
      search2.onChange((value) => {
        $$invalidate(2, folder = value);
        notifyChange();
      });
    });
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(3, index = $$props2.index);
    if ("folder" in $$props2)
      $$invalidate(2, folder = $$props2.folder);
    if ("notifyChange" in $$props2)
      $$invalidate(4, notifyChange = $$props2.notifyChange);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    8) {
      $:
        $$invalidate(0, id = `input_folder_${index}`);
    }
  };
  return [id, searchFolder, folder, index, notifyChange];
}
var InputFolder = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance5, create_fragment5, safe_not_equal, { index: 3, folder: 2, notifyChange: 4 });
  }
};
var InputFolder_default = InputFolder;

// src/views/components/InputBuilderSelect.svelte
function add_css5(target) {
  append_styles(target, "svelte-15a6dqv", "button.svelte-15a6dqv:disabled{opacity:0.5;cursor:forbidden}.unknown-checkbox.svelte-15a6dqv{display:flex;flex-direction:column;align-items:flex-start}");
}
function get_each_context2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[24] = list[i];
  child_ctx[26] = list;
  child_ctx[27] = i;
  const constants_0 = `${/*options_id*/
  child_ctx[10]}_option_${/*idx*/
  child_ctx[27]}`;
  child_ctx[25] = constants_0;
  return child_ctx;
}
function get_else_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = `${/*options_id*/
  child_ctx[10]}_option_label_${/*idx*/
  child_ctx[27]}`;
  child_ctx[28] = constants_0;
  return child_ctx;
}
function create_if_block_5(ctx) {
  let option_1;
  return {
    c() {
      option_1 = element("option");
      option_1.textContent = "Dataview";
      option_1.__value = "dataview";
      set_input_value(option_1, option_1.__value);
    },
    m(target, anchor) {
      insert(target, option_1, anchor);
    },
    d(detaching) {
      if (detaching) {
        detach(option_1);
      }
    }
  };
}
function create_if_block_4(ctx) {
  let label;
  let span0;
  let input;
  let t0;
  let t1;
  let span1;
  let mounted;
  let dispose;
  return {
    c() {
      label = element("label");
      span0 = element("span");
      input = element("input");
      t0 = text("\n                Allow unknown values.");
      t1 = space();
      span1 = element("span");
      span1.textContent = "If checked, the user will be able to type any value in the input even if it is not\n                in the list of options.";
      attr(input, "type", "checkbox");
      attr(span1, "class", "modal-form-hint");
      attr(label, "class", "unknown-checkbox svelte-15a6dqv");
    },
    m(target, anchor) {
      insert(target, label, anchor);
      append5(label, span0);
      append5(span0, input);
      input.checked = /*allowUnknownValues*/
      ctx[3];
      append5(span0, t0);
      append5(label, t1);
      append5(label, span1);
      if (!mounted) {
        dispose = listen(
          input,
          "change",
          /*input_change_handler*/
          ctx[14]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*allowUnknownValues*/
      8) {
        input.checked = /*allowUnknownValues*/
        ctx2[3];
      }
    },
    d(detaching) {
      if (detaching) {
        detach(label);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_7(ctx) {
  let select;
  let option0;
  let option1;
  let t2;
  let if_block1_anchor;
  let mounted;
  let dispose;
  let if_block0 = (
    /*is_multi*/
    ctx[8] && create_if_block_5(ctx)
  );
  let if_block1 = (
    /*showAllowUnknownValuesOption*/
    ctx[9] && create_if_block_4(ctx)
  );
  return {
    c() {
      select = element("select");
      option0 = element("option");
      option0.textContent = "Static";
      option1 = element("option");
      option1.textContent = "Notes";
      if (if_block0)
        if_block0.c();
      t2 = space();
      if (if_block1)
        if_block1.c();
      if_block1_anchor = empty3();
      option0.__value = "fixed";
      set_input_value(option0, option0.__value);
      option1.__value = "notes";
      set_input_value(option1, option1.__value);
      attr(
        select,
        "id",
        /*id*/
        ctx[11]
      );
      if (
        /*source*/
        ctx[0] === void 0
      )
        add_render_callback(() => (
          /*select_change_handler*/
          ctx[13].call(select)
        ));
    },
    m(target, anchor) {
      insert(target, select, anchor);
      append5(select, option0);
      append5(select, option1);
      if (if_block0)
        if_block0.m(select, null);
      select_option(
        select,
        /*source*/
        ctx[0],
        true
      );
      insert(target, t2, anchor);
      if (if_block1)
        if_block1.m(target, anchor);
      insert(target, if_block1_anchor, anchor);
      if (!mounted) {
        dispose = listen(
          select,
          "change",
          /*select_change_handler*/
          ctx[13]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (
        /*is_multi*/
        ctx2[8]
      ) {
        if (if_block0) {
        } else {
          if_block0 = create_if_block_5(ctx2);
          if_block0.c();
          if_block0.m(select, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty & /*id*/
      2048) {
        attr(
          select,
          "id",
          /*id*/
          ctx2[11]
        );
      }
      if (dirty & /*source*/
      1) {
        select_option(
          select,
          /*source*/
          ctx2[0]
        );
      }
      if (
        /*showAllowUnknownValuesOption*/
        ctx2[9]
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
        } else {
          if_block1 = create_if_block_4(ctx2);
          if_block1.c();
          if_block1.m(if_block1_anchor.parentNode, if_block1_anchor);
        }
      } else if (if_block1) {
        if_block1.d(1);
        if_block1 = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(select);
        detach(t2);
        detach(if_block1_anchor);
      }
      if (if_block0)
        if_block0.d();
      if (if_block1)
        if_block1.d(detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block_3(ctx) {
  let inputbuilderdataview;
  let updating_value;
  let current;
  function inputbuilderdataview_value_binding(value) {
    ctx[23](value);
  }
  let inputbuilderdataview_props = {
    index: (
      /*index*/
      ctx[5]
    ),
    app: (
      /*app*/
      ctx[6]
    )
  };
  if (
    /*query*/
    ctx[1] !== void 0
  ) {
    inputbuilderdataview_props.value = /*query*/
    ctx[1];
  }
  inputbuilderdataview = new inputBuilderDataview_default({ props: inputbuilderdataview_props });
  binding_callbacks.push(() => bind2(inputbuilderdataview, "value", inputbuilderdataview_value_binding));
  return {
    c() {
      create_component(inputbuilderdataview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdataview, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputbuilderdataview_changes = {};
      if (dirty & /*index*/
      32)
        inputbuilderdataview_changes.index = /*index*/
        ctx2[5];
      if (dirty & /*app*/
      64)
        inputbuilderdataview_changes.app = /*app*/
        ctx2[6];
      if (!updating_value && dirty & /*query*/
      2) {
        updating_value = true;
        inputbuilderdataview_changes.value = /*query*/
        ctx2[1];
        add_flush_callback(() => updating_value = false);
      }
      inputbuilderdataview.$set(inputbuilderdataview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdataview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdataview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdataview, detaching);
    }
  };
}
function create_if_block_2(ctx) {
  let inputfolder;
  let updating_folder;
  let current;
  function inputfolder_folder_binding(value) {
    ctx[22](value);
  }
  let inputfolder_props = {
    index: (
      /*index*/
      ctx[5]
    ),
    notifyChange: (
      /*notifyChange*/
      ctx[7]
    )
  };
  if (
    /*folder*/
    ctx[2] !== void 0
  ) {
    inputfolder_props.folder = /*folder*/
    ctx[2];
  }
  inputfolder = new InputFolder_default({ props: inputfolder_props });
  binding_callbacks.push(() => bind2(inputfolder, "folder", inputfolder_folder_binding));
  return {
    c() {
      create_component(inputfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputfolder, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const inputfolder_changes = {};
      if (dirty & /*index*/
      32)
        inputfolder_changes.index = /*index*/
        ctx2[5];
      if (dirty & /*notifyChange*/
      128)
        inputfolder_changes.notifyChange = /*notifyChange*/
        ctx2[7];
      if (!updating_folder && dirty & /*folder*/
      4) {
        updating_folder = true;
        inputfolder_changes.folder = /*folder*/
        ctx2[2];
        add_flush_callback(() => updating_folder = false);
      }
      inputfolder.$set(inputfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputfolder, detaching);
    }
  };
}
function create_if_block2(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Options",
      id: (
        /*options_id*/
        ctx[10]
      ),
      $$slots: { default: [create_default_slot2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow_changes.id = /*options_id*/
        ctx2[10];
      if (dirty & /*$$scope, options, options_id, notifyChange, is_multi*/
      536872336) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot_6(ctx) {
  let button;
  let button_disabled_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[16](
        /*idx*/
        ctx[27]
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = /*idx*/
      ctx[27] === 0;
      attr(button, "class", "svelte-15a6dqv");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian12.setIcon.call(null, button, "arrow-up")),
          listen(button, "click", click_handler_1)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_default_slot_5(ctx) {
  let button;
  let button_disabled_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[17](
        /*idx*/
        ctx[27]
      )
    );
  }
  return {
    c() {
      var _a;
      button = element("button");
      attr(button, "type", "button");
      button.disabled = button_disabled_value = /*idx*/
      ctx[27] === /*options*/
      ((_a = ctx[4]) == null ? void 0 : _a.length) - 1;
      attr(button, "class", "svelte-15a6dqv");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian12.setIcon.call(null, button, "arrow-down")),
          listen(button, "click", click_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      var _a;
      ctx = new_ctx;
      if (dirty & /*options*/
      16 && button_disabled_value !== (button_disabled_value = /*idx*/
      ctx[27] === /*options*/
      ((_a = ctx[4]) == null ? void 0 : _a.length) - 1)) {
        button.disabled = button_disabled_value;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_else_block2(ctx) {
  let formrow0;
  let formrow1;
  let current;
  formrow0 = new FormRow_default({
    props: {
      label: "Label",
      id: (
        /*label_id*/
        ctx[28]
      ),
      $$slots: { default: [create_default_slot_4] },
      $$scope: { ctx }
    }
  });
  formrow1 = new FormRow_default({
    props: {
      label: "Value",
      id: (
        /*value_id*/
        ctx[25]
      ),
      $$slots: { default: [create_default_slot_3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow0.$$.fragment);
      create_component(formrow1.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow0, target, anchor);
      mount_component(formrow1, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow0_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow0_changes.id = /*label_id*/
        ctx2[28];
      if (dirty & /*$$scope, options_id, options*/
      536871952) {
        formrow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow0.$set(formrow0_changes);
      const formrow1_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow1_changes.id = /*value_id*/
        ctx2[25];
      if (dirty & /*$$scope, options_id, options*/
      536871952) {
        formrow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow1.$set(formrow1_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow0.$$.fragment, local);
      transition_in(formrow1.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow0.$$.fragment, local);
      transition_out(formrow1.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow0, detaching);
      destroy_component(formrow1, detaching);
    }
  };
}
function create_if_block_1(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Value",
      id: (
        /*value_id*/
        ctx[25]
      ),
      $$slots: { default: [create_default_slot_2] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow_changes.id = /*value_id*/
        ctx2[25];
      if (dirty & /*$$scope, options_id, options*/
      536871952) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot_4(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler_1() {
    ctx[19].call(
      input,
      /*each_value*/
      ctx[26],
      /*idx*/
      ctx[27]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Label");
      attr(input, "id", input_id_value = /*label_id*/
      ctx[28]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[24].label
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      1024 && input_id_value !== (input_id_value = /*label_id*/
      ctx[28])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      16 && input.value !== /*option*/
      ctx[24].label) {
        set_input_value(
          input,
          /*option*/
          ctx[24].label
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_3(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler_2() {
    ctx[20].call(
      input,
      /*each_value*/
      ctx[26],
      /*idx*/
      ctx[27]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Value");
      attr(input, "id", input_id_value = /*value_id*/
      ctx[25]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[24].value
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler_2);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      1024 && input_id_value !== (input_id_value = /*value_id*/
      ctx[25])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      16 && input.value !== /*option*/
      ctx[24].value) {
        set_input_value(
          input,
          /*option*/
          ctx[24].value
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_2(ctx) {
  let input;
  let input_id_value;
  let mounted;
  let dispose;
  function input_input_handler() {
    ctx[18].call(
      input,
      /*each_value*/
      ctx[26],
      /*idx*/
      ctx[27]
    );
  }
  return {
    c() {
      input = element("input");
      attr(input, "type", "text");
      attr(input, "placeholder", "Value");
      attr(input, "id", input_id_value = /*value_id*/
      ctx[25]);
    },
    m(target, anchor) {
      insert(target, input, anchor);
      set_input_value(
        input,
        /*option*/
        ctx[24]
      );
      if (!mounted) {
        dispose = listen(input, "input", input_input_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      1024 && input_id_value !== (input_id_value = /*value_id*/
      ctx[25])) {
        attr(input, "id", input_id_value);
      }
      if (dirty & /*options*/
      16 && input.value !== /*option*/
      ctx[24]) {
        set_input_value(
          input,
          /*option*/
          ctx[24]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(input);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_default_slot_12(ctx) {
  let button;
  let button_id_value;
  let setIcon_action;
  let mounted;
  let dispose;
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[21](
        /*idx*/
        ctx[27]
      )
    );
  }
  return {
    c() {
      button = element("button");
      attr(button, "id", button_id_value = "button" + /*value_id*/
      ctx[25]);
      attr(button, "type", "button");
      attr(button, "class", "svelte-15a6dqv");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      if (!mounted) {
        dispose = [
          action_destroyer(setIcon_action = import_obsidian12.setIcon.call(null, button, "trash")),
          listen(button, "click", click_handler_3)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*options_id*/
      1024 && button_id_value !== (button_id_value = "button" + /*value_id*/
      ctx[25])) {
        attr(button, "id", button_id_value);
      }
    },
    d(detaching) {
      if (detaching) {
        detach(button);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_each_block2(ctx) {
  let div;
  let formrow0;
  let t0;
  let formrow1;
  let t1;
  let current_block_type_index;
  let if_block;
  let t2;
  let formrow2;
  let t3;
  let current;
  formrow0 = new FormRow_default({
    props: {
      label: "Button",
      id: "button-up" + /*value_id*/
      ctx[25],
      hideLabel: true,
      $$slots: { default: [create_default_slot_6] },
      $$scope: { ctx }
    }
  });
  formrow1 = new FormRow_default({
    props: {
      label: "Button",
      id: "button-down" + /*value_id*/
      ctx[25],
      hideLabel: true,
      $$slots: { default: [create_default_slot_5] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block_1, create_else_block2];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if ("string" == typeof /*option*/
    ctx2[24])
      return 0;
    return 1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 1)
      return get_else_ctx(ctx2);
    return ctx2;
  }
  current_block_type_index = select_block_type_1(ctx, -1);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  formrow2 = new FormRow_default({
    props: {
      label: "Delete",
      id: "button" + /*value_id*/
      ctx[25],
      hideLabel: true,
      $$slots: { default: [create_default_slot_12] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      create_component(formrow0.$$.fragment);
      t0 = space();
      create_component(formrow1.$$.fragment);
      t1 = space();
      if_block.c();
      t2 = space();
      create_component(formrow2.$$.fragment);
      t3 = space();
      attr(div, "class", "modal-form flex row gap1");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(formrow0, div, null);
      append5(div, t0);
      mount_component(formrow1, div, null);
      append5(div, t1);
      if_blocks[current_block_type_index].m(div, null);
      append5(div, t2);
      mount_component(formrow2, div, null);
      append5(div, t3);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow0_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow0_changes.id = "button-up" + /*value_id*/
        ctx2[25];
      if (dirty & /*$$scope*/
      536870912) {
        formrow0_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow0.$set(formrow0_changes);
      const formrow1_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow1_changes.id = "button-down" + /*value_id*/
        ctx2[25];
      if (dirty & /*$$scope, options*/
      536870928) {
        formrow1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow1.$set(formrow1_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(select_block_ctx(ctx2, current_block_type_index), dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx2, current_block_type_index));
          if_block.c();
        } else {
          if_block.p(select_block_ctx(ctx2, current_block_type_index), dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div, t2);
      }
      const formrow2_changes = {};
      if (dirty & /*options_id*/
      1024)
        formrow2_changes.id = "button" + /*value_id*/
        ctx2[25];
      if (dirty & /*$$scope, options_id, options, notifyChange*/
      536872080) {
        formrow2_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow2.$set(formrow2_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow0.$$.fragment, local);
      transition_in(formrow1.$$.fragment, local);
      transition_in(if_block);
      transition_in(formrow2.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow0.$$.fragment, local);
      transition_out(formrow1.$$.fragment, local);
      transition_out(if_block);
      transition_out(formrow2.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(formrow0);
      destroy_component(formrow1);
      if_blocks[current_block_type_index].d();
      destroy_component(formrow2);
    }
  };
}
function create_default_slot2(ctx) {
  let button;
  let t1;
  let each_1_anchor;
  let current;
  let mounted;
  let dispose;
  let each_value = ensure_array_like(
    /*options*/
    ctx[4] || []
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block2(get_each_context2(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      button = element("button");
      button.textContent = "Add more options";
      t1 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty3();
      attr(button, "type", "button");
      attr(button, "class", "svelte-15a6dqv");
    },
    m(target, anchor) {
      insert(target, button, anchor);
      insert(target, t1, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = listen(
          button,
          "click",
          /*click_handler*/
          ctx[15]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*options_id, options, notifyChange, moveOption*/
      5264) {
        each_value = ensure_array_like(
          /*options*/
          ctx2[4] || []
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context2(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block2(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(button);
        detach(t1);
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
      mounted = false;
      dispose();
    }
  };
}
function create_fragment6(ctx) {
  let formrow;
  let t;
  let current_block_type_index;
  let if_block;
  let if_block_anchor;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Source",
      id: (
        /*id*/
        ctx[11]
      ),
      $$slots: { default: [create_default_slot_7] },
      $$scope: { ctx }
    }
  });
  const if_block_creators = [create_if_block2, create_if_block_2, create_if_block_3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*source*/
      ctx2[0] === "fixed"
    )
      return 0;
    if (
      /*source*/
      ctx2[0] === "notes"
    )
      return 1;
    if (
      /*source*/
      ctx2[0] === "dataview"
    )
      return 2;
    return -1;
  }
  if (~(current_block_type_index = select_block_type(ctx, -1))) {
    if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  }
  return {
    c() {
      create_component(formrow.$$.fragment);
      t = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      insert(target, t, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(target, anchor);
      }
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      2048)
        formrow_changes.id = /*id*/
        ctx2[11];
      if (dirty & /*$$scope, allowUnknownValues, showAllowUnknownValuesOption, id, source, is_multi*/
      536873737) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(ctx2, dirty);
        }
      } else {
        if (if_block) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block = if_blocks[current_block_type_index];
          if (!if_block) {
            if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
            if_block.c();
          } else {
            if_block.p(ctx2, dirty);
          }
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        } else {
          if_block = null;
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(t);
        detach(if_block_anchor);
      }
      destroy_component(formrow, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d(detaching);
      }
    }
  };
}
function instance6($$self, $$props, $$invalidate) {
  let id;
  let options_id;
  let showAllowUnknownValuesOption;
  let { index } = $$props;
  let { source = "fixed" } = $$props;
  let { query = "" } = $$props;
  let { folder } = $$props;
  let { allowUnknownValues = false } = $$props;
  let { options = [] } = $$props;
  let { app: app2 } = $$props;
  let { notifyChange } = $$props;
  let { is_multi } = $$props;
  function moveOption(from, direction) {
    const to = direction === "up" ? from - 1 : from + 1;
    if (to < 0 || to >= options.length)
      return;
    const tmp = options[from];
    const target = options[to];
    if (!target || !tmp)
      return;
    $$invalidate(4, options[from] = target, options);
    $$invalidate(4, options[to] = tmp, options);
    $$invalidate(4, options);
    notifyChange();
  }
  function select_change_handler() {
    source = select_value(this);
    $$invalidate(0, source);
  }
  function input_change_handler() {
    allowUnknownValues = this.checked;
    $$invalidate(3, allowUnknownValues);
  }
  const click_handler = () => {
    if (is_multi) {
      options == null ? void 0 : options.push("");
    } else {
      options == null ? void 0 : options.push({ value: "", label: "" });
    }
    $$invalidate(4, options);
    notifyChange();
  };
  const click_handler_1 = (idx) => moveOption(idx, "up");
  const click_handler_2 = (idx) => moveOption(idx, "down");
  function input_input_handler(each_value, idx) {
    each_value[idx] = this.value;
    $$invalidate(4, options);
  }
  function input_input_handler_1(each_value, idx) {
    each_value[idx].label = this.value;
    $$invalidate(4, options);
  }
  function input_input_handler_2(each_value, idx) {
    each_value[idx].value = this.value;
    $$invalidate(4, options);
  }
  const click_handler_3 = (idx) => {
    $$invalidate(4, options = options == null ? void 0 : options.filter((_, i) => i !== idx));
    notifyChange();
  };
  function inputfolder_folder_binding(value) {
    folder = value;
    $$invalidate(2, folder);
  }
  function inputbuilderdataview_value_binding(value) {
    query = value;
    $$invalidate(1, query);
  }
  $$self.$$set = ($$props2) => {
    if ("index" in $$props2)
      $$invalidate(5, index = $$props2.index);
    if ("source" in $$props2)
      $$invalidate(0, source = $$props2.source);
    if ("query" in $$props2)
      $$invalidate(1, query = $$props2.query);
    if ("folder" in $$props2)
      $$invalidate(2, folder = $$props2.folder);
    if ("allowUnknownValues" in $$props2)
      $$invalidate(3, allowUnknownValues = $$props2.allowUnknownValues);
    if ("options" in $$props2)
      $$invalidate(4, options = $$props2.options);
    if ("app" in $$props2)
      $$invalidate(6, app2 = $$props2.app);
    if ("notifyChange" in $$props2)
      $$invalidate(7, notifyChange = $$props2.notifyChange);
    if ("is_multi" in $$props2)
      $$invalidate(8, is_multi = $$props2.is_multi);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    32) {
      $:
        $$invalidate(11, id = `builder_select_${index}`);
    }
    if ($$self.$$.dirty & /*index*/
    32) {
      $:
        $$invalidate(10, options_id = `builder_select_options_btn_${index}`);
    }
    if ($$self.$$.dirty & /*is_multi, source*/
    257) {
      $:
        $$invalidate(9, showAllowUnknownValuesOption = is_multi && canAllowUnknownValues("multiselect", source));
    }
  };
  return [
    source,
    query,
    folder,
    allowUnknownValues,
    options,
    index,
    app2,
    notifyChange,
    is_multi,
    showAllowUnknownValuesOption,
    options_id,
    id,
    moveOption,
    select_change_handler,
    input_change_handler,
    click_handler,
    click_handler_1,
    click_handler_2,
    input_input_handler,
    input_input_handler_1,
    input_input_handler_2,
    click_handler_3,
    inputfolder_folder_binding,
    inputbuilderdataview_value_binding
  ];
}
var InputBuilderSelect = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance6,
      create_fragment6,
      safe_not_equal,
      {
        index: 5,
        source: 0,
        query: 1,
        folder: 2,
        allowUnknownValues: 3,
        options: 4,
        app: 6,
        notifyChange: 7,
        is_multi: 8
      },
      add_css5
    );
  }
};
var InputBuilderSelect_default = InputBuilderSelect;

// src/views/components/Toggle.svelte
function create_fragment7(ctx) {
  let div;
  let input;
  let mounted;
  let dispose;
  return {
    c() {
      div = element("div");
      input = element("input");
      attr(input, "type", "checkbox");
      attr(
        input,
        "tabindex",
        /*tabindex*/
        ctx[1]
      );
      attr(div, "class", "checkbox-container");
      toggle_class(
        div,
        "is-enabled",
        /*checked*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, input);
      input.checked = /*checked*/
      ctx[0];
      if (!mounted) {
        dispose = [
          listen(
            input,
            "change",
            /*input_change_handler*/
            ctx[2]
          ),
          listen(
            div,
            "click",
            /*click_handler*/
            ctx[3]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tabindex*/
      2) {
        attr(
          input,
          "tabindex",
          /*tabindex*/
          ctx2[1]
        );
      }
      if (dirty & /*checked*/
      1) {
        input.checked = /*checked*/
        ctx2[0];
      }
      if (dirty & /*checked*/
      1) {
        toggle_class(
          div,
          "is-enabled",
          /*checked*/
          ctx2[0]
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance7($$self, $$props, $$invalidate) {
  let { checked = false } = $$props;
  let { tabindex = 0 } = $$props;
  function input_change_handler() {
    checked = this.checked;
    $$invalidate(0, checked);
  }
  const click_handler = () => $$invalidate(0, checked = !checked);
  $$self.$$set = ($$props2) => {
    if ("checked" in $$props2)
      $$invalidate(0, checked = $$props2.checked);
    if ("tabindex" in $$props2)
      $$invalidate(1, tabindex = $$props2.tabindex);
  };
  return [checked, tabindex, input_change_handler, click_handler];
}
var Toggle = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance7, create_fragment7, safe_not_equal, { checked: 0, tabindex: 1 });
  }
};
var Toggle_default = Toggle;

// node_modules/parser-ts/es6/ParseResult.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var success = function(value, next, start) {
  return right3({
    value,
    next,
    start
  });
};
var error = function(input, expected2, fatal) {
  if (expected2 === void 0) {
    expected2 = [];
  }
  if (fatal === void 0) {
    fatal = false;
  }
  return left3({
    input,
    expected: expected2,
    fatal
  });
};
var withExpected = function(err, expected2) {
  return __assign(__assign({}, err), { expected: expected2 });
};
var extend = function(err1, err2) {
  return getSemigroup3().concat(err1, err2);
};
var getSemigroup3 = function() {
  return {
    concat: function(x, y) {
      if (x.input.cursor < y.input.cursor)
        return last().concat(x, y);
      if (x.input.cursor > y.input.cursor)
        return first().concat(x, y);
      return struct({
        input: first(),
        fatal: first(),
        expected: getMonoid()
      }).concat(x, y);
    }
  };
};

// node_modules/parser-ts/es6/Stream.js
var stream = function(buffer, cursor) {
  if (cursor === void 0) {
    cursor = 0;
  }
  return {
    buffer,
    cursor
  };
};
var get2 = function(s) {
  return lookup2(s.cursor, s.buffer);
};
var atEnd = function(s) {
  return s.cursor >= s.buffer.length;
};
var getAndNext = function(s) {
  return pipe(get2(s), map3(function(a) {
    return { value: a, next: { buffer: s.buffer, cursor: s.cursor + 1 } };
  }));
};

// node_modules/parser-ts/es6/Parser.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s)
        if (Object.prototype.hasOwnProperty.call(s, p))
          t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
var succeed = function(a) {
  return function(i) {
    return success(a, i, i);
  };
};
var fail = function() {
  return function(i) {
    return error(i);
  };
};
var failAt = function(i) {
  return function() {
    return error(i);
  };
};
var sat = function(predicate) {
  return pipe(withStart(item()), chain3(function(_a) {
    var a = _a[0], start = _a[1];
    return predicate(a) ? of4(a) : failAt(start);
  }));
};
var expected = function(p, message) {
  return function(i) {
    return pipe(p(i), mapLeft(function(err) {
      return withExpected(err, [message]);
    }));
  };
};
var item = function() {
  return function(i) {
    return pipe(getAndNext(i), fold2(function() {
      return error(i);
    }, function(_a) {
      var value = _a.value, next = _a.next;
      return success(value, next, i);
    }));
  };
};
var seq = function(fa, f) {
  return function(i) {
    return pipe(fa(i), chain(function(s) {
      return pipe(f(s.value)(s.next), chain(function(next) {
        return success(next.value, next.next, i);
      }));
    }));
  };
};
var either = function(p, f) {
  return function(i) {
    var e = p(i);
    if (isRight2(e)) {
      return e;
    }
    if (e.left.fatal) {
      return e;
    }
    return pipe(f()(i), mapLeft(function(err) {
      return extend(e.left, err);
    }));
  };
};
var withStart = function(p) {
  return function(i) {
    return pipe(p(i), map(function(s) {
      return __assign2(__assign2({}, s), { value: [s.value, i] });
    }));
  };
};
var maybe = function(M) {
  return alt2(function() {
    return of4(M.empty);
  });
};
var eof = function() {
  return expected(function(i) {
    return atEnd(i) ? success(void 0, i, i) : error(i);
  }, "end of file");
};
var many = function(p) {
  return pipe(many1(p), alt2(function() {
    return of4([]);
  }));
};
var many1 = function(parser) {
  return pipe(parser, chain3(function(head5) {
    return chainRec_(of3(head5), function(acc) {
      return pipe(parser, map5(function(a) {
        return left3(append4(a)(acc));
      }), alt2(function() {
        return of4(right3(acc));
      }));
    });
  }));
};
var sepBy = function(sep, p) {
  var nil = of4([]);
  return pipe(sepBy1(sep, p), alt2(function() {
    return nil;
  }));
};
var sepBy1 = function(sep, p) {
  return pipe(p, chain3(function(head5) {
    return pipe(many(pipe(sep, apSecond(p))), map5(function(tail4) {
      return prepend3(head5)(tail4);
    }));
  }));
};
var between = function(left4, right4) {
  return function(p) {
    return pipe(left4, chain3(function() {
      return p;
    }), chainFirst(function() {
      return right4;
    }));
  };
};
var surroundedBy = function(bound) {
  return between(bound, bound);
};
var lookAhead = function(p) {
  return function(i) {
    return pipe(p(i), chain(function(next) {
      return success(next.value, i, i);
    }));
  };
};
var optional2 = function(parser) {
  return pipe(parser, map5(some3), alt2(function() {
    return succeed(none2);
  }));
};
var many1Till = function(parser, terminator) {
  return pipe(parser, chain3(function(x) {
    return chainRec_(of2(x), function(acc) {
      return pipe(terminator, map5(function() {
        return right3(acc);
      }), alt2(function() {
        return pipe(parser, map5(function(a) {
          return left3(append3(a)(acc));
        }));
      }));
    });
  }));
};
var map_ = function(ma, f) {
  return function(i) {
    return pipe(ma(i), map(function(s) {
      return __assign2(__assign2({}, s), { value: f(s.value) });
    }));
  };
};
var ap_ = function(mab, ma) {
  return chain_(mab, function(f) {
    return map_(ma, f);
  });
};
var chain_ = function(ma, f) {
  return seq(ma, f);
};
var chainRec_ = function(a, f) {
  var split2 = function(start) {
    return function(result) {
      return isLeft2(result.value) ? left3({ value: result.value.left, stream: result.next }) : right3(success(result.value.right, result.next, start));
    };
  };
  return function(start) {
    return tailRec({ value: a, stream: start }, function(state) {
      var result = f(state.value)(state.stream);
      if (isLeft2(result)) {
        return right3(error(state.stream, result.left.expected, result.left.fatal));
      }
      return split2(start)(result.right);
    });
  };
};
var alt_ = function(fa, that) {
  return either(fa, that);
};
var map5 = function(f) {
  return function(fa) {
    return map_(fa, f);
  };
};
var apFirst = function(fb) {
  return function(fa) {
    return ap_(map_(fa, function(a) {
      return function() {
        return a;
      };
    }), fb);
  };
};
var apSecond = function(fb) {
  return function(fa) {
    return ap_(map_(fa, function() {
      return function(b) {
        return b;
      };
    }), fb);
  };
};
var of4 = succeed;
var chain3 = function(f) {
  return function(ma) {
    return chain_(ma, f);
  };
};
var chainFirst = function(f) {
  return function(ma) {
    return chain_(ma, function(a) {
      return map_(f(a), function() {
        return a;
      });
    });
  };
};
var alt2 = function(that) {
  return function(fa) {
    return alt_(fa, that);
  };
};
var URI4 = "Parser";
var getSemigroup4 = function(S) {
  return {
    concat: function(x, y) {
      return ap_(map_(x, function(x2) {
        return function(y2) {
          return S.concat(x2, y2);
        };
      }), y);
    }
  };
};
var getMonoid3 = function(M) {
  return __assign2(__assign2({}, getSemigroup4(M)), { empty: succeed(M.empty) });
};
var ChainRec = {
  URI: URI4,
  map: map_,
  ap: ap_,
  chain: chain_,
  chainRec: chainRec_
};

// node_modules/parser-ts/es6/char.js
var maybe2 = maybe(Monoid);
var char = function(c) {
  return expected(sat(function(s) {
    return s === c;
  }), '"'.concat(c, '"'));
};
var notChar = function(c) {
  return expected(sat(function(c1) {
    return c1 !== c;
  }), 'anything but "'.concat(c, '"'));
};
var many2 = function(parser) {
  return maybe2(many12(parser));
};
var many12 = function(parser) {
  return pipe(many1(parser), map5(function(nea) {
    return nea.join("");
  }));
};
var isDigit = function(c) {
  return "0123456789".indexOf(c) !== -1;
};
var digit = expected(sat(isDigit), "a digit");
var spaceRe = /^\s$/;
var isSpace = function(c) {
  return spaceRe.test(c);
};
var space2 = expected(sat(isSpace), "a whitespace");
var isUnderscore = function(c) {
  return c === "_";
};
var isLetter = function(c) {
  return /[a-z]/.test(c.toLowerCase());
};
var isAlphanum = function(c) {
  return isLetter(c) || isDigit(c) || isUnderscore(c);
};
var alphanum = expected(sat(isAlphanum), "a word character");
var letter = expected(sat(isLetter), "a letter");
var isUnicodeLetter = function(c) {
  return c.toLowerCase() !== c.toUpperCase();
};
var unicodeLetter = expected(sat(isUnicodeLetter), "an unicode letter");
var isUpper = function(c) {
  return isLetter(c) && c === c.toUpperCase();
};
var upper = expected(sat(isUpper), "an upper case letter");
var isLower = function(c) {
  return isLetter(c) && c === c.toLowerCase();
};
var lower = expected(sat(isLower), "a lower case letter");
var notDigit = expected(sat(not(isDigit)), "a non-digit");
var notSpace = expected(sat(not(isSpace)), "a non-whitespace character");
var notAlphanum = expected(sat(not(isAlphanum)), "a non-word character");
var notLetter = expected(sat(not(isLetter)), "a non-letter character");
var notUpper = expected(sat(not(isUpper)), "anything but an upper case letter");
var notLower = expected(sat(not(isLower)), "anything but a lower case letter");

// node_modules/fp-ts/es6/Monoid.js
var concatAll4 = function(M) {
  return concatAll2(M)(M.empty);
};
var monoidVoid = {
  concat: semigroupVoid.concat,
  empty: void 0
};
var monoidAll = {
  concat: semigroupAll.concat,
  empty: true
};
var monoidAny = {
  concat: semigroupAny.concat,
  empty: false
};
var monoidString = {
  concat: semigroupString.concat,
  empty: ""
};
var monoidSum = {
  concat: semigroupSum.concat,
  empty: 0
};
var monoidProduct = {
  concat: semigroupProduct.concat,
  empty: 1
};

// node_modules/parser-ts/es6/string.js
var string2 = function(s) {
  return expected(ChainRec.chainRec(s, function(acc) {
    return pipe(charAt(0, acc), fold2(function() {
      return of4(right3(s));
    }, function(c) {
      return pipe(char(c), chain3(function() {
        return of4(left3(acc.slice(1)));
      }));
    }));
  }), JSON.stringify(s));
};
var fold3 = concatAll4(getMonoid3(Monoid));
var maybe3 = maybe(Monoid);
var many3 = function(parser) {
  return maybe3(many13(parser));
};
var many13 = function(parser) {
  return pipe(many1(parser), map5(function(nea) {
    return nea.join("");
  }));
};
var charAt = function(index, s) {
  return index >= 0 && index < s.length ? some3(s.charAt(index)) : none2;
};
var spaces = many2(space2);
var spaces1 = many12(space2);
var notSpaces = many2(notSpace);
var notSpaces1 = many12(notSpace);
var fromString = function(s) {
  var n = +s;
  return isNaN(n) || s === "" ? none2 : some3(n);
};
var int = expected(pipe(fold3([maybe3(char("-")), many12(digit)]), map5(function(s) {
  return +s;
})), "an integer");
var float = expected(pipe(fold3([maybe3(char("-")), many2(digit), maybe3(fold3([char("."), many12(digit)]))]), chain3(function(s) {
  return pipe(fromString(s), fold2(function() {
    return fail();
  }, succeed));
})), "a float");
var doubleQuotedString = surroundedBy(char('"'))(many3(either(string2('\\"'), function() {
  return notChar('"');
})));
function run2(string3) {
  return function(p) {
    return p(stream(string3.split("")));
  };
}

// src/core/template/templateParser.ts
var import_obsidian13 = require("obsidian");
function TemplateText(value) {
  return { _tag: "text", value };
}
function TemplateVariable(value) {
  return { _tag: "variable", value };
}
function FrontmatterCommand(pick = [], omit = []) {
  return { _tag: "frontmatter-command", pick, omit };
}
var EofStr = pipe2(
  eof(),
  map5(() => "")
);
var open = fold3([string2("{{"), spaces]);
var close = expected(fold3([spaces, string2("}}")]), 'closing variable tag: "}}"');
var identifier = many13(alphanum);
var templateIdentifier = pipe2(
  identifier,
  between(open, close),
  map5(TemplateVariable)
);
var commandOpen = fold3([string2("{#"), spaces]);
var commandClose = expected(fold3([spaces, string2("#}")]), 'a closing command tag: "#}"');
var sepByComma = sepBy(fold3([char(","), spaces]), identifier);
var commandOptionParser = (option) => pipe2(
  fold3([string2(option), spaces]),
  // dam prettier
  apSecond(sepByComma)
);
var frontmatterCommandParser = pipe2(
  fold3([string2("frontmatter"), spaces]),
  apSecond(optional2(commandOptionParser("pick:")))
  //P.apFirst(S.spaces),
  // P.chain(commandOptionParser("pick:")),
);
var commandParser = pipe2(
  frontmatterCommandParser,
  between(commandOpen, commandClose),
  map5((value) => {
    return pipe2(
      value,
      O.fold(() => [], identity),
      FrontmatterCommand
    );
  })
);
var OpenOrEof = pipe2(
  open,
  alt2(() => commandOpen),
  alt2(() => EofStr)
);
var anythingUntilOpenOrEOF = many1Till(item(), lookAhead(OpenOrEof));
var text2 = pipe2(
  anythingUntilOpenOrEOF,
  map5((value) => TemplateText(value.join("")))
);
var TextOrVariable = pipe2(
  templateIdentifier,
  alt2(() => commandParser),
  alt2(() => text2)
);
var Template = pipe2(
  many(TextOrVariable),
  // dam prettier
  apFirst(eof())
);
function parseTemplate(template) {
  return pipe2(
    Template,
    run2(template),
    fold(
      ({ expected: expected2 }) => left3(`Expected ${expected2.join(" or ")}`),
      (result) => right3(result.value)
    )
  );
}
function templateVariables(parsedTemplate) {
  return pipe2(
    parsedTemplate,
    fold(
      () => [],
      filterMap((token) => {
        if (token._tag === "variable") {
          return O.some(token.value);
        }
        return O.none;
      })
    )
  );
}
function templateError(parsedTemplate) {
  return pipe2(
    parsedTemplate,
    fold(
      (error2) => error2,
      () => void 0
    )
  );
}
function tokenToString(token) {
  const tag = token._tag;
  switch (tag) {
    case "text":
      return token.value;
    case "variable":
      return `{{${token.value}}}`;
    case "frontmatter-command":
      return `{{# frontmatter pick: ${token.pick.join(", ")}, omit: ${token.omit.join(
        ", "
      )} #}}`;
    default:
      return absurd(tag);
  }
}
function matchToken(onText, onVariable, onCommand) {
  return (token) => {
    switch (token._tag) {
      case "text":
        return onText(token.value);
      case "variable":
        return onVariable(token.value);
      case "frontmatter-command":
        return onCommand(token);
      default:
        return absurd(token);
    }
  };
}
function parsedTemplateToString(parsedTemplate) {
  return pipe2(
    // prettier shut up
    parsedTemplate,
    foldMap2(Monoid)(tokenToString)
  );
}
function asFrontmatterString(data) {
  return ({ pick, omit }) => pipe2(
    data,
    filterMapWithIndex3((key, value) => {
      if (pick.length === 0)
        return O.some(value);
      return pick.includes(key) ? O.some(value) : O.none;
    }),
    filterMapWithIndex3((key, value) => !omit.includes(key) ? O.some(value) : O.none),
    import_obsidian13.stringifyYaml
  );
}
function executeTemplate(parsedTemplate, formData) {
  const toFrontmatter = asFrontmatterString(formData);
  return pipe2(
    parsedTemplate,
    filterMap(
      matchToken(
        O.some,
        (key) => O.fromNullable(formData[key]),
        (command) => pipe2(
          //prettier
          command,
          toFrontmatter,
          O.some
        )
      )
    ),
    foldMap2(Monoid)(String)
  );
}

// src/views/components/TemplateEditor.svelte
function add_css6(target) {
  append_styles(target, "svelte-1daddci", ".fields-list.svelte-1daddci{padding-top:1rem}textarea.svelte-1daddci{font-family:var(--font-family-monospace);width:100%}");
}
function get_each_context3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[11] = list[i];
  return child_ctx;
}
function create_default_slot_13(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*exampleText*/
        ctx[5]
      );
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_each_block3(ctx) {
  let li;
  let code;
  let t0_value = (
    /*field*/
    ctx[11] + ""
  );
  let t0;
  let t1;
  let t2_value = (
    /*usedVariables*/
    ctx[4].includes(
      /*field*/
      ctx[11]
    ) ? "\u2705" : ""
  );
  let t2;
  let t3;
  return {
    c() {
      li = element("li");
      code = element("code");
      t0 = text(t0_value);
      t1 = space();
      t2 = text(t2_value);
      t3 = space();
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append5(li, code);
      append5(code, t0);
      append5(li, t1);
      append5(li, t2);
      append5(li, t3);
    },
    p(ctx2, dirty) {
      if (dirty & /*fieldNames*/
      4 && t0_value !== (t0_value = /*field*/
      ctx2[11] + ""))
        set_data(t0, t0_value);
      if (dirty & /*usedVariables, fieldNames*/
      20 && t2_value !== (t2_value = /*usedVariables*/
      ctx2[4].includes(
        /*field*/
        ctx2[11]
      ) ? "\u2705" : ""))
        set_data(t2, t2_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_if_block3(ctx) {
  let div1;
  let div0;
  let t1;
  let code;
  let current;
  code = new Code_default({
    props: {
      $$slots: { default: [create_default_slot3] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "The template is invalid:";
      t1 = space();
      create_component(code.$$.fragment);
      attr(div0, "class", "invalid");
      attr(div1, "class", "error-wrapper");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append5(div1, div0);
      append5(div1, t1);
      mount_component(code, div1, null);
      current = true;
    },
    p(ctx2, dirty) {
      const code_changes = {};
      if (dirty & /*$$scope, templateErrorMessage*/
      16392) {
        code_changes.$$scope = { dirty, ctx: ctx2 };
      }
      code.$set(code_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(code.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(code.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(code);
    }
  };
}
function create_default_slot3(ctx) {
  let t;
  return {
    c() {
      t = text(
        /*templateErrorMessage*/
        ctx[3]
      );
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p(ctx2, dirty) {
      if (dirty & /*templateErrorMessage*/
      8)
        set_data(
          t,
          /*templateErrorMessage*/
          ctx2[3]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_fragment8(ctx) {
  let h6;
  let t0;
  let t1;
  let t2;
  let p;
  let t3;
  let code0;
  let t5;
  let t6;
  let div1;
  let div0;
  let t8;
  let code1;
  let t9;
  let button;
  let t10;
  let button_disabled_value;
  let t11;
  let div2;
  let t12;
  let ul;
  let t13;
  let textarea;
  let textarea_rows_value;
  let t14;
  let if_block_anchor;
  let current;
  let mounted;
  let dispose;
  code1 = new Code_default({
    props: {
      $$slots: { default: [create_default_slot_13] },
      $$scope: { ctx }
    }
  });
  let each_value = ensure_array_like(
    /*fieldNames*/
    ctx[2]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block3(get_each_context3(ctx, each_value, i));
  }
  let if_block = (
    /*templateErrorMessage*/
    ctx[3] && create_if_block3(ctx)
  );
  return {
    c() {
      h6 = element("h6");
      t0 = text("Template for ");
      t1 = text(
        /*formName*/
        ctx[1]
      );
      t2 = space();
      p = element("p");
      t3 = text("Templates are used when you create a note directly from a form. You can put\n    any text you want and reference the form fields using the ");
      code0 = element("code");
      code0.textContent = `${`{{name}}`}`;
      t5 = text("\n    syntax.");
      t6 = space();
      div1 = element("div");
      div0 = element("div");
      div0.textContent = "For example:";
      t8 = space();
      create_component(code1.$$.fragment);
      t9 = space();
      button = element("button");
      t10 = text("Save template");
      t11 = space();
      div2 = element("div");
      t12 = text("Available fields:\n    ");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t13 = space();
      textarea = element("textarea");
      t14 = space();
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
      attr(button, "class", "btn btn-primary");
      button.disabled = button_disabled_value = !!/*templateErrorMessage*/
      ctx[3];
      attr(div2, "class", "fields-list svelte-1daddci");
      attr(textarea, "rows", textarea_rows_value = 10);
      attr(textarea, "class", "form-control svelte-1daddci");
      attr(textarea, "placeholder", "Enter template here");
    },
    m(target, anchor) {
      insert(target, h6, anchor);
      append5(h6, t0);
      append5(h6, t1);
      insert(target, t2, anchor);
      insert(target, p, anchor);
      append5(p, t3);
      append5(p, code0);
      append5(p, t5);
      insert(target, t6, anchor);
      insert(target, div1, anchor);
      append5(div1, div0);
      append5(div1, t8);
      mount_component(code1, div1, null);
      insert(target, t9, anchor);
      insert(target, button, anchor);
      append5(button, t10);
      insert(target, t11, anchor);
      insert(target, div2, anchor);
      append5(div2, t12);
      append5(div2, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
      insert(target, t13, anchor);
      insert(target, textarea, anchor);
      set_input_value(
        textarea,
        /*templateString*/
        ctx[0]
      );
      insert(target, t14, anchor);
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            button,
            "click",
            /*handleSave*/
            ctx[6]
          ),
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[9]
          )
        ];
        mounted = true;
      }
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*formName*/
      2)
        set_data(
          t1,
          /*formName*/
          ctx2[1]
        );
      const code1_changes = {};
      if (dirty & /*$$scope*/
      16384) {
        code1_changes.$$scope = { dirty, ctx: ctx2 };
      }
      code1.$set(code1_changes);
      if (!current || dirty & /*templateErrorMessage*/
      8 && button_disabled_value !== (button_disabled_value = !!/*templateErrorMessage*/
      ctx2[3])) {
        button.disabled = button_disabled_value;
      }
      if (dirty & /*usedVariables, fieldNames*/
      20) {
        each_value = ensure_array_like(
          /*fieldNames*/
          ctx2[2]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context3(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
      if (dirty & /*templateString*/
      1) {
        set_input_value(
          textarea,
          /*templateString*/
          ctx2[0]
        );
      }
      if (
        /*templateErrorMessage*/
        ctx2[3]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty & /*templateErrorMessage*/
          8) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block3(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(code1.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(code1.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h6);
        detach(t2);
        detach(p);
        detach(t6);
        detach(div1);
        detach(t9);
        detach(button);
        detach(t11);
        detach(div2);
        detach(t13);
        detach(textarea);
        detach(t14);
        detach(if_block_anchor);
      }
      destroy_component(code1);
      destroy_each(each_blocks, detaching);
      if (if_block)
        if_block.d(detaching);
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance8($$self, $$props, $$invalidate) {
  let parsedTemplate;
  let usedVariables;
  let templateErrorMessage;
  let { templateString } = $$props;
  let { formName } = $$props;
  let { fieldNames } = $$props;
  let { saveTemplate } = $$props;
  const firstField = fieldNames[0];
  const exampleText = `Example text {{${firstField}}}`;
  const handleSave = () => {
    pipe2(parsedTemplate, E.map(saveTemplate));
  };
  function textarea_input_handler() {
    templateString = this.value;
    $$invalidate(0, templateString);
  }
  $$self.$$set = ($$props2) => {
    if ("templateString" in $$props2)
      $$invalidate(0, templateString = $$props2.templateString);
    if ("formName" in $$props2)
      $$invalidate(1, formName = $$props2.formName);
    if ("fieldNames" in $$props2)
      $$invalidate(2, fieldNames = $$props2.fieldNames);
    if ("saveTemplate" in $$props2)
      $$invalidate(7, saveTemplate = $$props2.saveTemplate);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*templateString*/
    1) {
      $:
        $$invalidate(8, parsedTemplate = parseTemplate(templateString));
    }
    if ($$self.$$.dirty & /*parsedTemplate*/
    256) {
      $:
        $$invalidate(4, usedVariables = templateVariables(parsedTemplate));
    }
    if ($$self.$$.dirty & /*parsedTemplate*/
    256) {
      $:
        $$invalidate(3, templateErrorMessage = templateError(parsedTemplate));
    }
  };
  return [
    templateString,
    formName,
    fieldNames,
    templateErrorMessage,
    usedVariables,
    exampleText,
    handleSave,
    saveTemplate,
    parsedTemplate,
    textarea_input_handler
  ];
}
var TemplateEditor = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance8,
      create_fragment8,
      safe_not_equal,
      {
        templateString: 0,
        formName: 1,
        fieldNames: 2,
        saveTemplate: 7
      },
      add_css6
    );
  }
};
var TemplateEditor_default = TemplateEditor;

// src/views/components/Tabs.svelte
function add_css7(target) {
  append_styles(target, "svelte-1uurynp", '.tabs.svelte-1uurynp{display:flex;flex-direction:row;justify-content:flex-start;padding-top:0.15rem}.tab.svelte-1uurynp{background:none;cursor:pointer;font-size:1rem;color:var(--gray-700);border:none;outline:none;cursor:pointer;padding:1rem;border-radius:10px 10px 0 0;box-shadow:none;text-transform:capitalize;position:relative}.tab.svelte-1uurynp::after{position:absolute;right:-0.5px;width:1px;background-color:var(--tab-divider-color);content:" ";height:20px}button.svelte-1uurynp{appearance:none;border:none}.tab-outer.svelte-1uurynp{padding:1px 0px 3.5px;border-radius:var(--tab-radius-active)}.tab-outer.active.svelte-1uurynp{color:var(--tab-text-color-focused-active);background-color:var(--tab-background-active)}.tabs.svelte-1uurynp{background-color:var(--background-secondary)}.tab-outer.svelte-1uurynp:hover{background-color:var(--background-modifier-border) !important}');
}
function get_each_context4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[3] = list[i];
  return child_ctx;
}
function create_each_block4(ctx) {
  let div;
  let button;
  let t0_value = (
    /*tab*/
    ctx[3] + ""
  );
  let t0;
  let t1;
  let mounted;
  let dispose;
  function click_handler() {
    return (
      /*click_handler*/
      ctx[2](
        /*tab*/
        ctx[3]
      )
    );
  }
  return {
    c() {
      div = element("div");
      button = element("button");
      t0 = text(t0_value);
      t1 = space();
      attr(button, "class", "tab svelte-1uurynp");
      attr(div, "class", "tab-outer svelte-1uurynp");
      toggle_class(
        div,
        "active",
        /*tab*/
        ctx[3] === /*activeTab*/
        ctx[0]
      );
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, button);
      append5(button, t0);
      append5(div, t1);
      if (!mounted) {
        dispose = listen(button, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty & /*tabs*/
      2 && t0_value !== (t0_value = /*tab*/
      ctx[3] + ""))
        set_data(t0, t0_value);
      if (dirty & /*tabs, activeTab*/
      3) {
        toggle_class(
          div,
          "active",
          /*tab*/
          ctx[3] === /*activeTab*/
          ctx[0]
        );
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      mounted = false;
      dispose();
    }
  };
}
function create_fragment9(ctx) {
  let div;
  let each_value = ensure_array_like(
    /*tabs*/
    ctx[1]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block4(get_each_context4(ctx, each_value, i));
  }
  return {
    c() {
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(div, "class", "tabs svelte-1uurynp");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
    },
    p(ctx2, [dirty]) {
      if (dirty & /*tabs, activeTab*/
      3) {
        each_value = ensure_array_like(
          /*tabs*/
          ctx2[1]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context4(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block4(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(div, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function instance9($$self, $$props, $$invalidate) {
  let { activeTab } = $$props;
  let { tabs } = $$props;
  const click_handler = (tab) => {
    $$invalidate(0, activeTab = tab);
  };
  $$self.$$set = ($$props2) => {
    if ("activeTab" in $$props2)
      $$invalidate(0, activeTab = $$props2.activeTab);
    if ("tabs" in $$props2)
      $$invalidate(1, tabs = $$props2.tabs);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*activeTab*/
    1) {
      $:
        console.log(activeTab);
    }
  };
  return [activeTab, tabs, click_handler];
}
var Tabs = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance9, create_fragment9, safe_not_equal, { activeTab: 0, tabs: 1 }, add_css7);
  }
};
var Tabs_default = Tabs;

// src/views/components/InputBuilderDocumentBlock.svelte
function create_if_block4(ctx) {
  let t0;
  let div;
  let t1;
  return {
    c() {
      t0 = text("Your function body has errors:\n            ");
      div = element("div");
      t1 = text(
        /*errors*/
        ctx[1]
      );
      attr(div, "class", "modal-form-error-message");
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, div, anchor);
      append5(div, t1);
    },
    p(ctx2, dirty) {
      if (dirty & /*errors*/
      2)
        set_data(
          t1,
          /*errors*/
          ctx2[1]
        );
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(div);
      }
    }
  };
}
function create_default_slot4(ctx) {
  let span;
  let t0;
  let code;
  let t2;
  let pre;
  let t4;
  let textarea;
  let t5;
  let mounted;
  let dispose;
  let if_block = (
    /*errors*/
    ctx[1] && create_if_block4(ctx)
  );
  return {
    c() {
      span = element("span");
      t0 = text("This is a document block input. It is not meant to be used as a normal\n        input, instead it is to render some instructions to the user. It is\n        expected to be a function body that returns a string. Within the\n        function body, you can access the form data using the ");
      code = element("code");
      code.textContent = "form";
      t2 = text("\n        variable. For example:\n        ");
      pre = element("pre");
      pre.textContent = `${placeholder}`;
      t4 = space();
      textarea = element("textarea");
      t5 = space();
      if (if_block)
        if_block.c();
      attr(pre, "class", "language-js");
      attr(textarea, "name", "document_block");
      attr(textarea, "class", "form-control");
      attr(textarea, "rows", "3");
      attr(textarea, "placeholder", placeholder);
      attr(span, "class", "modal-form-hint");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t0);
      append5(span, code);
      append5(span, t2);
      append5(span, pre);
      append5(span, t4);
      append5(span, textarea);
      set_input_value(
        textarea,
        /*body*/
        ctx[0]
      );
      append5(span, t5);
      if (if_block)
        if_block.m(span, null);
      if (!mounted) {
        dispose = listen(
          textarea,
          "input",
          /*textarea_input_handler*/
          ctx[4]
        );
        mounted = true;
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*body*/
      1) {
        set_input_value(
          textarea,
          /*body*/
          ctx2[0]
        );
      }
      if (
        /*errors*/
        ctx2[1]
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
        } else {
          if_block = create_if_block4(ctx2);
          if_block.c();
          if_block.m(span, null);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_fragment10(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Document block",
      id: (
        /*id*/
        ctx[2]
      ),
      $$slots: { default: [create_default_slot4] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, [dirty]) {
      const formrow_changes = {};
      if (dirty & /*id*/
      4)
        formrow_changes.id = /*id*/
        ctx2[2];
      if (dirty & /*$$scope, errors, body*/
      35) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
var placeholder = "return `Hello ${form.name}!`";
function instance10($$self, $$props, $$invalidate) {
  let id;
  let errors;
  let { body = "" } = $$props;
  let { index } = $$props;
  function textarea_input_handler() {
    body = this.value;
    $$invalidate(0, body);
  }
  $$self.$$set = ($$props2) => {
    if ("body" in $$props2)
      $$invalidate(0, body = $$props2.body);
    if ("index" in $$props2)
      $$invalidate(3, index = $$props2.index);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*index*/
    8) {
      $:
        $$invalidate(2, id = "document_block_" + index);
    }
    if ($$self.$$.dirty & /*body*/
    1) {
      $:
        $$invalidate(1, errors = pipe2(parseFunctionBody(body), E.fold((e) => e.message, () => "")));
    }
    if ($$self.$$.dirty & /*errors*/
    2) {
      $:
        console.log(errors);
    }
  };
  return [body, errors, id, index, textarea_input_handler];
}
var InputBuilderDocumentBlock = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance10, create_fragment10, safe_not_equal, { body: 0, index: 3 });
  }
};
var InputBuilderDocumentBlock_default = InputBuilderDocumentBlock;

// src/views/FormBuilder.svelte
function add_css8(target) {
  append_styles(target, "svelte-8lqyxl", ".wrapper.svelte-8lqyxl,.body.svelte-8lqyxl{flex:1;display:flex;flex-direction:column}.wrapper.svelte-8lqyxl{max-height:100%;min-height:100%;height:100%;overflow:hidden}.body.svelte-8lqyxl{padding-top:0.5rem;overflow-y:scroll}.header.svelte-8lqyxl{box-shadow:var(--shadow-bottom) var(--divider-color);padding:1rem}@media(min-width: 100rem){.body.svelte-8lqyxl{overflow-y:hidden}.fields.svelte-8lqyxl{flex:1;height:100%}form.svelte-8lqyxl{display:flex;flex-direction:column;height:100%;overflow:hidden}}.template.svelte-8lqyxl{padding:1rem}.fields.svelte-8lqyxl{overflow-y:auto;padding:1rem}.flex.svelte-8lqyxl{display:flex}.column.svelte-8lqyxl{flex-direction:column}.gap1.svelte-8lqyxl{gap:0.5rem}.gap2.svelte-8lqyxl{gap:1rem}fieldset.svelte-8lqyxl{border:none;padding:0}.hint.svelte-8lqyxl{color:var(--color-base-70)}.error.svelte-8lqyxl{color:var(--text-error);font-weight:bold}button.svelte-8lqyxl:disabled{opacity:0.5;cursor:forbidden}@media(min-width: 58rem){.md-row.svelte-8lqyxl{flex-direction:row}}");
}
function get_each_context5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[45] = list[i];
  child_ctx[48] = list;
  child_ctx[49] = i;
  const constants_0 = `desc_${/*index*/
  child_ctx[49]}`;
  child_ctx[46] = constants_0;
  const constants_1 = `delete_${/*index*/
  child_ctx[49]}`;
  child_ctx[47] = constants_1;
  return child_ctx;
}
function get_if_ctx(ctx) {
  const child_ctx = ctx.slice();
  const constants_0 = `min_${/*index*/
  child_ctx[49]}`;
  child_ctx[50] = constants_0;
  const constants_1 = `max_${/*index*/
  child_ctx[49]}`;
  child_ctx[51] = constants_1;
  return child_ctx;
}
function get_each_context_12(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[52] = list[i];
  return child_ctx;
}
function get_each_context_2(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[55] = list[i];
  return child_ctx;
}
function create_else_block3(ctx) {
  let form;
  let fieldset0;
  let label0;
  let t1;
  let span0;
  let t3;
  let input0;
  let t4;
  let label1;
  let t6;
  let span1;
  let t8;
  let input1;
  let t9;
  let label2;
  let span2;
  let input2;
  let t12;
  let div;
  let button0;
  let t14;
  let button1;
  let t15;
  let button1_disabled_value;
  let t16;
  let button2;
  let t17;
  let button2_disabled_value;
  let t18;
  let button3;
  let t20;
  let t21;
  let fieldset1;
  let h3;
  let t23;
  let current_block_type_index;
  let if_block1;
  let current;
  let mounted;
  let dispose;
  let if_block0 = (
    /*errors*/
    ctx[7].length > 0 && create_if_block_9(ctx)
  );
  const if_block_creators = [create_if_block_12, create_else_block_1];
  const if_blocks = [];
  function select_block_type_1(ctx2, dirty) {
    if (
      /*definition*/
      ctx2[0].fields.length > 0
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type_1(ctx, [-1, -1]);
  if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      form = element("form");
      fieldset0 = element("fieldset");
      label0 = element("label");
      label0.textContent = "Form unique name";
      t1 = space();
      span0 = element("span");
      span0.textContent = "This name will identify this form uniquely, and will be the value you need\n                        to provide when calling the method openForm";
      t3 = space();
      input0 = element("input");
      t4 = space();
      label1 = element("label");
      label1.textContent = "Form title";
      t6 = space();
      span1 = element("span");
      span1.textContent = "This is the title that will be shown in the modal when the form is visible";
      t8 = space();
      input1 = element("input");
      t9 = space();
      label2 = element("label");
      label2.textContent = "Custom class Name";
      span2 = element("span");
      span2.textContent = "In case you want to add a class name to the modal form to customize it";
      input2 = element("input");
      t12 = space();
      div = element("div");
      button0 = element("button");
      button0.textContent = "Add more fields";
      t14 = space();
      button1 = element("button");
      t15 = text("Preview");
      t16 = space();
      button2 = element("button");
      t17 = text("Save and close");
      t18 = space();
      button3 = element("button");
      button3.textContent = "Cancel";
      t20 = space();
      if (if_block0)
        if_block0.c();
      t21 = space();
      fieldset1 = element("fieldset");
      h3 = element("h3");
      h3.textContent = "Fields";
      t23 = space();
      if_block1.c();
      attr(label0, "for", "name");
      attr(span0, "class", "hint svelte-8lqyxl");
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Name");
      attr(input0, "id", "name");
      attr(label1, "for", "title");
      attr(span1, "class", "hint svelte-8lqyxl");
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Title");
      attr(input1, "id", "title");
      attr(label2, "for", "customClassname");
      attr(span2, "class", "hint svelte-8lqyxl");
      attr(input2, "type", "text");
      attr(input2, "id", "customClassname");
      attr(button0, "type", "button");
      attr(button0, "class", "svelte-8lqyxl");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = !/*isValid*/
      ctx[8];
      attr(button1, "class", "svelte-8lqyxl");
      attr(button2, "class", "mod-cta svelte-8lqyxl");
      attr(button2, "type", "submit");
      button2.disabled = button2_disabled_value = !/*isValid*/
      ctx[8];
      attr(button3, "type", "button");
      attr(button3, "class", "mod-warning svelte-8lqyxl");
      attr(div, "class", "flex row gap2 svelte-8lqyxl");
      attr(fieldset0, "class", "flex column gap2 header svelte-8lqyxl");
      attr(fieldset1, "class", "flex column gap2 fields svelte-8lqyxl");
      attr(form, "class", "svelte-8lqyxl");
    },
    m(target, anchor) {
      insert(target, form, anchor);
      append5(form, fieldset0);
      append5(fieldset0, label0);
      append5(fieldset0, t1);
      append5(fieldset0, span0);
      append5(fieldset0, t3);
      append5(fieldset0, input0);
      set_input_value(
        input0,
        /*definition*/
        ctx[0].name
      );
      append5(fieldset0, t4);
      append5(fieldset0, label1);
      append5(fieldset0, t6);
      append5(fieldset0, span1);
      append5(fieldset0, t8);
      append5(fieldset0, input1);
      set_input_value(
        input1,
        /*definition*/
        ctx[0].title
      );
      append5(fieldset0, t9);
      append5(fieldset0, label2);
      append5(fieldset0, span2);
      append5(fieldset0, input2);
      set_input_value(
        input2,
        /*definition*/
        ctx[0].customClassname
      );
      append5(fieldset0, t12);
      append5(fieldset0, div);
      append5(div, button0);
      append5(div, t14);
      append5(div, button1);
      append5(button1, t15);
      append5(div, t16);
      append5(div, button2);
      append5(button2, t17);
      append5(div, t18);
      append5(div, button3);
      append5(fieldset0, t20);
      if (if_block0)
        if_block0.m(fieldset0, null);
      append5(form, t21);
      append5(form, fieldset1);
      append5(fieldset1, h3);
      append5(fieldset1, t23);
      if_blocks[current_block_type_index].m(fieldset1, null);
      current = true;
      if (!mounted) {
        dispose = [
          listen(
            input0,
            "input",
            /*input0_input_handler*/
            ctx[17]
          ),
          listen(
            input1,
            "input",
            /*input1_input_handler*/
            ctx[18]
          ),
          listen(
            input2,
            "input",
            /*input2_input_handler*/
            ctx[19]
          ),
          listen(
            button0,
            "click",
            /*click_handler*/
            ctx[20]
          ),
          listen(
            button1,
            "click",
            /*handlePreview*/
            ctx[13]
          ),
          listen(button3, "click", function() {
            if (is_function(
              /*onCancel*/
              ctx[2]
            ))
              ctx[2].apply(this, arguments);
          }),
          listen(form, "submit", prevent_default(
            /*handleSubmit*/
            ctx[11]
          ))
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && input0.value !== /*definition*/
      ctx[0].name) {
        set_input_value(
          input0,
          /*definition*/
          ctx[0].name
        );
      }
      if (dirty[0] & /*definition*/
      1 && input1.value !== /*definition*/
      ctx[0].title) {
        set_input_value(
          input1,
          /*definition*/
          ctx[0].title
        );
      }
      if (dirty[0] & /*definition*/
      1 && input2.value !== /*definition*/
      ctx[0].customClassname) {
        set_input_value(
          input2,
          /*definition*/
          ctx[0].customClassname
        );
      }
      if (!current || dirty[0] & /*isValid*/
      256 && button1_disabled_value !== (button1_disabled_value = !/*isValid*/
      ctx[8])) {
        button1.disabled = button1_disabled_value;
      }
      if (!current || dirty[0] & /*isValid*/
      256 && button2_disabled_value !== (button2_disabled_value = !/*isValid*/
      ctx[8])) {
        button2.disabled = button2_disabled_value;
      }
      if (
        /*errors*/
        ctx[7].length > 0
      ) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
        } else {
          if_block0 = create_if_block_9(ctx);
          if_block0.c();
          if_block0.m(fieldset0, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_1(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block1 = if_blocks[current_block_type_index];
        if (!if_block1) {
          if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
          if_block1.c();
        } else {
          if_block1.p(ctx, dirty);
        }
        transition_in(if_block1, 1);
        if_block1.m(fieldset1, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(form);
      }
      if (if_block0)
        if_block0.d();
      if_blocks[current_block_type_index].d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block5(ctx) {
  let div;
  let templateeditor;
  let current;
  templateeditor = new TemplateEditor_default({
    props: {
      formName: (
        /*definition*/
        ctx[0].name
      ),
      fieldNames: (
        /*fieldNames*/
        ctx[6]
      ),
      saveTemplate: (
        /*saveTemplate*/
        ctx[12]
      ),
      templateString: (
        /*definition*/
        ctx[0].template ? parsedTemplateToString(
          /*definition*/
          ctx[0].template.parsedTemplate
        ) : ""
      )
    }
  });
  return {
    c() {
      div = element("div");
      create_component(templateeditor.$$.fragment);
      attr(div, "class", "template svelte-8lqyxl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      mount_component(templateeditor, div, null);
      current = true;
    },
    p(ctx2, dirty) {
      const templateeditor_changes = {};
      if (dirty[0] & /*definition*/
      1)
        templateeditor_changes.formName = /*definition*/
        ctx2[0].name;
      if (dirty[0] & /*fieldNames*/
      64)
        templateeditor_changes.fieldNames = /*fieldNames*/
        ctx2[6];
      if (dirty[0] & /*definition*/
      1)
        templateeditor_changes.templateString = /*definition*/
        ctx2[0].template ? parsedTemplateToString(
          /*definition*/
          ctx2[0].template.parsedTemplate
        ) : "";
      templateeditor.$set(templateeditor_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(templateeditor.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(templateeditor.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(templateeditor);
    }
  };
}
function create_if_block_9(ctx) {
  let h3;
  let t2;
  let ul;
  let each_value_2 = ensure_array_like(
    /*errors*/
    ctx[7]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks[i] = create_each_block_2(get_each_context_2(ctx, each_value_2, i));
  }
  return {
    c() {
      h3 = element("h3");
      h3.innerHTML = `<span class="error svelte-8lqyxl">Form is invalid</span>, check the following:`;
      t2 = space();
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(h3, "margin", "0");
      set_style(ul, "margin", "0");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t2, anchor);
      insert(target, ul, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*activeFieldIndex, errors*/
      160) {
        each_value_2 = ensure_array_like(
          /*errors*/
          ctx2[7]
        );
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_2(ctx2, each_value_2, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_2(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_2.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t2);
        detach(ul);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_10(ctx) {
  let t0;
  let t1_value = (
    /*error*/
    ctx[55].path + ""
  );
  let t1;
  return {
    c() {
      t0 = text("at ");
      t1 = text(t1_value);
    },
    m(target, anchor) {
      insert(target, t0, anchor);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*errors*/
      128 && t1_value !== (t1_value = /*error*/
      ctx2[55].path + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(t0);
        detach(t1);
      }
    }
  };
}
function create_each_block_2(ctx) {
  let li;
  let t0_value = (
    /*error*/
    ctx[55].message + ""
  );
  let t0;
  let t1;
  let t2;
  let button;
  let t4;
  let mounted;
  let dispose;
  let if_block = (
    /*error*/
    ctx[55].path && create_if_block_10(ctx)
  );
  function click_handler_1() {
    return (
      /*click_handler_1*/
      ctx[21](
        /*error*/
        ctx[55]
      )
    );
  }
  return {
    c() {
      li = element("li");
      t0 = text(t0_value);
      t1 = space();
      if (if_block)
        if_block.c();
      t2 = space();
      button = element("button");
      button.textContent = "Go to problem";
      t4 = space();
      attr(button, "type", "button");
      attr(button, "class", "svelte-8lqyxl");
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append5(li, t0);
      append5(li, t1);
      if (if_block)
        if_block.m(li, null);
      append5(li, t2);
      append5(li, button);
      append5(li, t4);
      if (!mounted) {
        dispose = listen(button, "click", click_handler_1);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*errors*/
      128 && t0_value !== (t0_value = /*error*/
      ctx[55].message + ""))
        set_data(t0, t0_value);
      if (
        /*error*/
        ctx[55].path
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block_10(ctx);
          if_block.c();
          if_block.m(li, t2);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      dispose();
    }
  };
}
function create_else_block_1(ctx) {
  let t;
  return {
    c() {
      t = text("No fields yet");
    },
    m(target, anchor) {
      insert(target, t, anchor);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(t);
      }
    }
  };
}
function create_if_block_12(ctx) {
  let each_1_anchor;
  let current;
  let each_value = ensure_array_like(
    /*definition*/
    ctx[0].fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block5(get_each_context5(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*definition, duplicateField, moveField, onChange, app, activeFieldIndex*/
      1579) {
        each_value = ensure_array_like(
          /*definition*/
          ctx2[0].fields
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context5(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block5(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_if_block_8(ctx) {
  let formrow;
  let current;
  formrow = new FormRow_default({
    props: {
      label: "Make required",
      id: `required_${/*index*/
      ctx[49]}`,
      $$slots: { default: [create_default_slot5] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(formrow.$$.fragment);
    },
    m(target, anchor) {
      mount_component(formrow, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const formrow_changes = {};
      if (dirty[0] & /*definition*/
      1 | dirty[1] & /*$$scope*/
      134217728) {
        formrow_changes.$$scope = { dirty, ctx: ctx2 };
      }
      formrow.$set(formrow_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(formrow.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(formrow.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(formrow, detaching);
    }
  };
}
function create_default_slot5(ctx) {
  let toggle;
  let updating_checked;
  let current;
  function toggle_checked_binding(value) {
    ctx[24](
      value,
      /*field*/
      ctx[45]
    );
  }
  let toggle_props = { tabindex: (
    /*index*/
    ctx[49]
  ) };
  if (
    /*field*/
    ctx[45].isRequired !== void 0
  ) {
    toggle_props.checked = /*field*/
    ctx[45].isRequired;
  }
  toggle = new Toggle_default({ props: toggle_props });
  binding_callbacks.push(() => bind2(toggle, "checked", toggle_checked_binding));
  return {
    c() {
      create_component(toggle.$$.fragment);
    },
    m(target, anchor) {
      mount_component(toggle, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const toggle_changes = {};
      if (!updating_checked && dirty[0] & /*definition*/
      1) {
        updating_checked = true;
        toggle_changes.checked = /*field*/
        ctx[45].isRequired;
        add_flush_callback(() => updating_checked = false);
      }
      toggle.$set(toggle_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(toggle.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(toggle.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(toggle, detaching);
    }
  };
}
function create_each_block_12(ctx) {
  let option;
  let t_value = (
    /*type*/
    ctx[52][1] + ""
  );
  let t;
  let option_value_value;
  return {
    c() {
      option = element("option");
      t = text(t_value);
      option.__value = option_value_value = /*type*/
      ctx[52][0];
      set_input_value(option, option.__value);
    },
    m(target, anchor) {
      insert(target, option, anchor);
      append5(option, t);
    },
    p: noop,
    d(detaching) {
      if (detaching) {
        detach(option);
      }
    }
  };
}
function create_if_block_7(ctx) {
  let inputbuilderdocumentblock;
  let updating_body;
  let current;
  function inputbuilderdocumentblock_body_binding(value) {
    ctx[39](
      value,
      /*field*/
      ctx[45]
    );
  }
  let inputbuilderdocumentblock_props = { index: (
    /*index*/
    ctx[49]
  ) };
  if (
    /*field*/
    ctx[45].input.body !== void 0
  ) {
    inputbuilderdocumentblock_props.body = /*field*/
    ctx[45].input.body;
  }
  inputbuilderdocumentblock = new InputBuilderDocumentBlock_default({ props: inputbuilderdocumentblock_props });
  binding_callbacks.push(() => bind2(inputbuilderdocumentblock, "body", inputbuilderdocumentblock_body_binding));
  return {
    c() {
      create_component(inputbuilderdocumentblock.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdocumentblock, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderdocumentblock_changes = {};
      if (!updating_body && dirty[0] & /*definition*/
      1) {
        updating_body = true;
        inputbuilderdocumentblock_changes.body = /*field*/
        ctx[45].input.body;
        add_flush_callback(() => updating_body = false);
      }
      inputbuilderdocumentblock.$set(inputbuilderdocumentblock_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdocumentblock.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdocumentblock.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdocumentblock, detaching);
    }
  };
}
function create_if_block_6(ctx) {
  let inputbuilderdataview;
  let updating_value;
  let current;
  function inputbuilderdataview_value_binding(value) {
    ctx[38](
      value,
      /*field*/
      ctx[45]
    );
  }
  let inputbuilderdataview_props = {
    index: (
      /*index*/
      ctx[49]
    ),
    app: (
      /*app*/
      ctx[3]
    )
  };
  if (
    /*field*/
    ctx[45].input.query !== void 0
  ) {
    inputbuilderdataview_props.value = /*field*/
    ctx[45].input.query;
  }
  inputbuilderdataview = new inputBuilderDataview_default({ props: inputbuilderdataview_props });
  binding_callbacks.push(() => bind2(inputbuilderdataview, "value", inputbuilderdataview_value_binding));
  return {
    c() {
      create_component(inputbuilderdataview.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderdataview, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderdataview_changes = {};
      if (dirty[0] & /*app*/
      8)
        inputbuilderdataview_changes.app = /*app*/
        ctx[3];
      if (!updating_value && dirty[0] & /*definition*/
      1) {
        updating_value = true;
        inputbuilderdataview_changes.value = /*field*/
        ctx[45].input.query;
        add_flush_callback(() => updating_value = false);
      }
      inputbuilderdataview.$set(inputbuilderdataview_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderdataview.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderdataview.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderdataview, detaching);
    }
  };
}
function create_if_block_52(ctx) {
  let inputfolder;
  let updating_folder;
  let current;
  function inputfolder_folder_binding(value) {
    ctx[37](
      value,
      /*field*/
      ctx[45]
    );
  }
  let inputfolder_props = {
    index: (
      /*index*/
      ctx[49]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    )
  };
  if (
    /*field*/
    ctx[45].input.folder !== void 0
  ) {
    inputfolder_props.folder = /*field*/
    ctx[45].input.folder;
  }
  inputfolder = new InputFolder_default({ props: inputfolder_props });
  binding_callbacks.push(() => bind2(inputfolder, "folder", inputfolder_folder_binding));
  return {
    c() {
      create_component(inputfolder.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputfolder, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputfolder_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputfolder_changes.notifyChange = /*onChange*/
        ctx[1];
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputfolder_changes.folder = /*field*/
        ctx[45].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      inputfolder.$set(inputfolder_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputfolder.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputfolder.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputfolder, detaching);
    }
  };
}
function create_if_block_42(ctx) {
  let div0;
  let label0;
  let label0_for_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let div1;
  let label1;
  let label1_for_value;
  let t4;
  let input1;
  let input1_id_value;
  let mounted;
  let dispose;
  function input0_input_handler_2() {
    ctx[35].call(
      input0,
      /*each_value*/
      ctx[48],
      /*index*/
      ctx[49]
    );
  }
  function input1_input_handler_2() {
    ctx[36].call(
      input1,
      /*each_value*/
      ctx[48],
      /*index*/
      ctx[49]
    );
  }
  return {
    c() {
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Min";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Max";
      t4 = space();
      input1 = element("input");
      attr(label0, "for", label0_for_value = /*min_id*/
      ctx[50]);
      attr(input0, "type", "number");
      attr(input0, "placeholder", "0");
      attr(input0, "id", input0_id_value = /*min_id*/
      ctx[50]);
      attr(div0, "class", "flex column gap1 svelte-8lqyxl");
      attr(label1, "for", label1_for_value = /*max_id*/
      ctx[51]);
      attr(input1, "type", "number");
      attr(input1, "placeholder", "10");
      attr(input1, "id", input1_id_value = /*max_id*/
      ctx[51]);
      attr(div1, "class", "flex column gap1 svelte-8lqyxl");
    },
    m(target, anchor) {
      insert(target, div0, anchor);
      append5(div0, label0);
      append5(div0, t1);
      append5(div0, input0);
      set_input_value(
        input0,
        /*field*/
        ctx[45].input.min
      );
      insert(target, t2, anchor);
      insert(target, div1, anchor);
      append5(div1, label1);
      append5(div1, t4);
      append5(div1, input1);
      set_input_value(
        input1,
        /*field*/
        ctx[45].input.max
      );
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler_2),
          listen(input1, "input", input1_input_handler_2)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && to_number(input0.value) !== /*field*/
      ctx[45].input.min) {
        set_input_value(
          input0,
          /*field*/
          ctx[45].input.min
        );
      }
      if (dirty[0] & /*definition*/
      1 && to_number(input1.value) !== /*field*/
      ctx[45].input.max) {
        set_input_value(
          input1,
          /*field*/
          ctx[45].input.max
        );
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div0);
        detach(t2);
        detach(div1);
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_if_block_32(ctx) {
  let inputbuilderselect;
  let updating_source;
  let updating_options;
  let updating_folder;
  let updating_query;
  let updating_allowUnknownValues;
  let current;
  function inputbuilderselect_source_binding_1(value) {
    ctx[30](
      value,
      /*field*/
      ctx[45]
    );
  }
  function inputbuilderselect_options_binding_1(value) {
    ctx[31](
      value,
      /*field*/
      ctx[45]
    );
  }
  function inputbuilderselect_folder_binding_1(value) {
    ctx[32](
      value,
      /*field*/
      ctx[45]
    );
  }
  function inputbuilderselect_query_binding(value) {
    ctx[33](
      value,
      /*field*/
      ctx[45]
    );
  }
  function inputbuilderselect_allowUnknownValues_binding(value) {
    ctx[34](
      value,
      /*field*/
      ctx[45]
    );
  }
  let inputbuilderselect_props = {
    index: (
      /*index*/
      ctx[49]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    ),
    is_multi: true,
    app: (
      /*app*/
      ctx[3]
    )
  };
  if (
    /*field*/
    ctx[45].input.source !== void 0
  ) {
    inputbuilderselect_props.source = /*field*/
    ctx[45].input.source;
  }
  if (
    /*field*/
    ctx[45].input.multi_select_options !== void 0
  ) {
    inputbuilderselect_props.options = /*field*/
    ctx[45].input.multi_select_options;
  }
  if (
    /*field*/
    ctx[45].input.folder !== void 0
  ) {
    inputbuilderselect_props.folder = /*field*/
    ctx[45].input.folder;
  }
  if (
    /*field*/
    ctx[45].input.query !== void 0
  ) {
    inputbuilderselect_props.query = /*field*/
    ctx[45].input.query;
  }
  if (
    /*field*/
    ctx[45].input.allowUnknownValues !== void 0
  ) {
    inputbuilderselect_props.allowUnknownValues = /*field*/
    ctx[45].input.allowUnknownValues;
  }
  inputbuilderselect = new InputBuilderSelect_default({ props: inputbuilderselect_props });
  binding_callbacks.push(() => bind2(inputbuilderselect, "source", inputbuilderselect_source_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "options", inputbuilderselect_options_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "folder", inputbuilderselect_folder_binding_1));
  binding_callbacks.push(() => bind2(inputbuilderselect, "query", inputbuilderselect_query_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "allowUnknownValues", inputbuilderselect_allowUnknownValues_binding));
  return {
    c() {
      create_component(inputbuilderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderselect, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderselect_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputbuilderselect_changes.notifyChange = /*onChange*/
        ctx[1];
      if (dirty[0] & /*app*/
      8)
        inputbuilderselect_changes.app = /*app*/
        ctx[3];
      if (!updating_source && dirty[0] & /*definition*/
      1) {
        updating_source = true;
        inputbuilderselect_changes.source = /*field*/
        ctx[45].input.source;
        add_flush_callback(() => updating_source = false);
      }
      if (!updating_options && dirty[0] & /*definition*/
      1) {
        updating_options = true;
        inputbuilderselect_changes.options = /*field*/
        ctx[45].input.multi_select_options;
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputbuilderselect_changes.folder = /*field*/
        ctx[45].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      if (!updating_query && dirty[0] & /*definition*/
      1) {
        updating_query = true;
        inputbuilderselect_changes.query = /*field*/
        ctx[45].input.query;
        add_flush_callback(() => updating_query = false);
      }
      if (!updating_allowUnknownValues && dirty[0] & /*definition*/
      1) {
        updating_allowUnknownValues = true;
        inputbuilderselect_changes.allowUnknownValues = /*field*/
        ctx[45].input.allowUnknownValues;
        add_flush_callback(() => updating_allowUnknownValues = false);
      }
      inputbuilderselect.$set(inputbuilderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderselect, detaching);
    }
  };
}
function create_if_block_22(ctx) {
  let inputbuilderselect;
  let updating_source;
  let updating_options;
  let updating_folder;
  let current;
  function inputbuilderselect_source_binding(value) {
    ctx[27](
      value,
      /*field*/
      ctx[45]
    );
  }
  function inputbuilderselect_options_binding(value) {
    ctx[28](
      value,
      /*field*/
      ctx[45]
    );
  }
  function inputbuilderselect_folder_binding(value) {
    ctx[29](
      value,
      /*field*/
      ctx[45]
    );
  }
  let inputbuilderselect_props = {
    index: (
      /*index*/
      ctx[49]
    ),
    notifyChange: (
      /*onChange*/
      ctx[1]
    ),
    is_multi: false,
    allowUnknownValues: false,
    app: (
      /*app*/
      ctx[3]
    )
  };
  if (
    /*field*/
    ctx[45].input.source !== void 0
  ) {
    inputbuilderselect_props.source = /*field*/
    ctx[45].input.source;
  }
  if (
    /*field*/
    ctx[45].input.options !== void 0
  ) {
    inputbuilderselect_props.options = /*field*/
    ctx[45].input.options;
  }
  if (
    /*field*/
    ctx[45].input.folder !== void 0
  ) {
    inputbuilderselect_props.folder = /*field*/
    ctx[45].input.folder;
  }
  inputbuilderselect = new InputBuilderSelect_default({ props: inputbuilderselect_props });
  binding_callbacks.push(() => bind2(inputbuilderselect, "source", inputbuilderselect_source_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "options", inputbuilderselect_options_binding));
  binding_callbacks.push(() => bind2(inputbuilderselect, "folder", inputbuilderselect_folder_binding));
  return {
    c() {
      create_component(inputbuilderselect.$$.fragment);
    },
    m(target, anchor) {
      mount_component(inputbuilderselect, target, anchor);
      current = true;
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      const inputbuilderselect_changes = {};
      if (dirty[0] & /*onChange*/
      2)
        inputbuilderselect_changes.notifyChange = /*onChange*/
        ctx[1];
      if (dirty[0] & /*app*/
      8)
        inputbuilderselect_changes.app = /*app*/
        ctx[3];
      if (!updating_source && dirty[0] & /*definition*/
      1) {
        updating_source = true;
        inputbuilderselect_changes.source = /*field*/
        ctx[45].input.source;
        add_flush_callback(() => updating_source = false);
      }
      if (!updating_options && dirty[0] & /*definition*/
      1) {
        updating_options = true;
        inputbuilderselect_changes.options = /*field*/
        ctx[45].input.options;
        add_flush_callback(() => updating_options = false);
      }
      if (!updating_folder && dirty[0] & /*definition*/
      1) {
        updating_folder = true;
        inputbuilderselect_changes.folder = /*field*/
        ctx[45].input.folder;
        add_flush_callback(() => updating_folder = false);
      }
      inputbuilderselect.$set(inputbuilderselect_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(inputbuilderselect.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(inputbuilderselect.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(inputbuilderselect, detaching);
    }
  };
}
function create_each_block5(ctx) {
  let div3;
  let div0;
  let label0;
  let label0_for_value;
  let t1;
  let input0;
  let input0_id_value;
  let t2;
  let div1;
  let label1;
  let label1_for_value;
  let t4;
  let input1;
  let input1_id_value;
  let t5;
  let show_if = ["text", "email", "tel", "number", "note", "tag", "dataview", "multiselect"].includes(
    /*field*/
    ctx[45].input.type
  );
  let t6;
  let div2;
  let label2;
  let label2_for_value;
  let scrollWhenActive_action;
  let t9;
  let div6;
  let div4;
  let label3;
  let label3_for_value;
  let t11;
  let input2;
  let input2_id_value;
  let t12;
  let div5;
  let label4;
  let label4_for_value;
  let t14;
  let select;
  let select_id_value;
  let t15;
  let div7;
  let current_block_type_index;
  let if_block1;
  let t16;
  let div8;
  let button0;
  let button0_disabled_value;
  let setIcon_action;
  let t17;
  let button1;
  let button1_disabled_value;
  let setIcon_action_1;
  let t18;
  let button2;
  let t20;
  let button3;
  let button3_id_value;
  let setIcon_action_2;
  let t21;
  let hr;
  let current;
  let mounted;
  let dispose;
  function input0_input_handler_1() {
    ctx[22].call(
      input0,
      /*each_value*/
      ctx[48],
      /*index*/
      ctx[49]
    );
  }
  function input1_input_handler_1() {
    ctx[23].call(
      input1,
      /*each_value*/
      ctx[48],
      /*index*/
      ctx[49]
    );
  }
  let if_block0 = show_if && create_if_block_8(ctx);
  function input2_input_handler_1() {
    ctx[25].call(
      input2,
      /*each_value*/
      ctx[48],
      /*index*/
      ctx[49]
    );
  }
  let each_value_1 = ensure_array_like(Object.entries(InputTypeReadable));
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_12(get_each_context_12(ctx, each_value_1, i));
  }
  function select_change_handler() {
    ctx[26].call(
      select,
      /*each_value*/
      ctx[48],
      /*index*/
      ctx[49]
    );
  }
  const if_block_creators = [
    create_if_block_22,
    create_if_block_32,
    create_if_block_42,
    create_if_block_52,
    create_if_block_6,
    create_if_block_7
  ];
  const if_blocks = [];
  function select_block_type_2(ctx2, dirty) {
    if (
      /*field*/
      ctx2[45].input.type === "select"
    )
      return 0;
    if (
      /*field*/
      ctx2[45].input.type === "multiselect"
    )
      return 1;
    if (
      /*field*/
      ctx2[45].input.type === "slider"
    )
      return 2;
    if (
      /*field*/
      ctx2[45].input.type === "note"
    )
      return 3;
    if (
      /*field*/
      ctx2[45].input.type === "dataview"
    )
      return 4;
    if (
      /*field*/
      ctx2[45].input.type === "document_block"
    )
      return 5;
    return -1;
  }
  function select_block_ctx(ctx2, index) {
    if (index === 2)
      return get_if_ctx(ctx2);
    return ctx2;
  }
  if (~(current_block_type_index = select_block_type_2(ctx, [-1, -1]))) {
    if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
  }
  function click_handler_2() {
    return (
      /*click_handler_2*/
      ctx[40](
        /*index*/
        ctx[49]
      )
    );
  }
  function click_handler_3() {
    return (
      /*click_handler_3*/
      ctx[41](
        /*index*/
        ctx[49]
      )
    );
  }
  function click_handler_4() {
    return (
      /*click_handler_4*/
      ctx[42](
        /*index*/
        ctx[49]
      )
    );
  }
  function click_handler_5() {
    return (
      /*click_handler_5*/
      ctx[43](
        /*index*/
        ctx[49]
      )
    );
  }
  return {
    c() {
      div3 = element("div");
      div0 = element("div");
      label0 = element("label");
      label0.textContent = "Name";
      t1 = space();
      input0 = element("input");
      t2 = space();
      div1 = element("div");
      label1 = element("label");
      label1.textContent = "Label";
      t4 = space();
      input1 = element("input");
      t5 = space();
      if (if_block0)
        if_block0.c();
      t6 = space();
      div2 = element("div");
      label2 = element("label");
      label2.textContent = `delete ${/*index*/
      ctx[49]}`;
      t9 = space();
      div6 = element("div");
      div4 = element("div");
      label3 = element("label");
      label3.textContent = "Description";
      t11 = space();
      input2 = element("input");
      t12 = space();
      div5 = element("div");
      label4 = element("label");
      label4.textContent = "Type";
      t14 = space();
      select = element("select");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t15 = space();
      div7 = element("div");
      if (if_block1)
        if_block1.c();
      t16 = space();
      div8 = element("div");
      button0 = element("button");
      t17 = space();
      button1 = element("button");
      t18 = space();
      button2 = element("button");
      button2.textContent = "Duplicate";
      t20 = space();
      button3 = element("button");
      t21 = space();
      hr = element("hr");
      attr(label0, "for", label0_for_value = `name_${/*index*/
      ctx[49]}`);
      attr(input0, "type", "text");
      attr(input0, "placeholder", "Name");
      attr(input0, "id", input0_id_value = `name_${/*index*/
      ctx[49]}`);
      attr(div0, "class", "flex column gap1 svelte-8lqyxl");
      attr(label1, "for", label1_for_value = `label_${/*index*/
      ctx[49]}`);
      attr(input1, "type", "text");
      attr(input1, "placeholder", "Label");
      attr(input1, "id", input1_id_value = `label_${/*index*/
      ctx[49]}`);
      attr(div1, "class", "flex column gap1 svelte-8lqyxl");
      attr(label2, "for", label2_for_value = /*delete_id*/
      ctx[47]);
      set_style(label2, "visibility", "hidden");
      set_style(label2, "overflow", "hidden");
      set_style(label2, "white-space", "nowrap");
      attr(div2, "class", "flex column gap1 svelte-8lqyxl");
      attr(div3, "class", "flex column md-row gap2 svelte-8lqyxl");
      attr(label3, "for", label3_for_value = /*desc_id*/
      ctx[46]);
      attr(input2, "type", "text");
      attr(input2, "placeholder", "Description");
      attr(input2, "id", input2_id_value = /*desc_id*/
      ctx[46]);
      attr(div4, "class", "flex column gap1 svelte-8lqyxl");
      attr(label4, "for", label4_for_value = `type_${/*index*/
      ctx[49]}`);
      attr(select, "id", select_id_value = `type_${/*index*/
      ctx[49]}`);
      if (
        /*field*/
        ctx[45].input.type === void 0
      )
        add_render_callback(select_change_handler);
      attr(div5, "class", "flex column gap1 svelte-8lqyxl");
      attr(div6, "class", "flex column md-row gap2 svelte-8lqyxl");
      attr(div7, "class", "flex gap1 svelte-8lqyxl");
      attr(button0, "type", "button");
      button0.disabled = button0_disabled_value = /*index*/
      ctx[49] === 0;
      attr(button0, "class", "svelte-8lqyxl");
      attr(button1, "type", "button");
      button1.disabled = button1_disabled_value = /*index*/
      ctx[49] === /*definition*/
      ctx[0].fields.length - 1;
      attr(button1, "class", "svelte-8lqyxl");
      attr(button2, "type", "button");
      attr(button2, "class", "svelte-8lqyxl");
      attr(button3, "type", "button");
      attr(button3, "id", button3_id_value = /*delete_id*/
      ctx[47]);
      attr(button3, "class", "svelte-8lqyxl");
      attr(div8, "class", "flex gap1 svelte-8lqyxl");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append5(div3, div0);
      append5(div0, label0);
      append5(div0, t1);
      append5(div0, input0);
      set_input_value(
        input0,
        /*field*/
        ctx[45].name
      );
      append5(div3, t2);
      append5(div3, div1);
      append5(div1, label1);
      append5(div1, t4);
      append5(div1, input1);
      set_input_value(
        input1,
        /*field*/
        ctx[45].label
      );
      append5(div3, t5);
      if (if_block0)
        if_block0.m(div3, null);
      append5(div3, t6);
      append5(div3, div2);
      append5(div2, label2);
      insert(target, t9, anchor);
      insert(target, div6, anchor);
      append5(div6, div4);
      append5(div4, label3);
      append5(div4, t11);
      append5(div4, input2);
      set_input_value(
        input2,
        /*field*/
        ctx[45].description
      );
      append5(div6, t12);
      append5(div6, div5);
      append5(div5, label4);
      append5(div5, t14);
      append5(div5, select);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(select, null);
        }
      }
      select_option(
        select,
        /*field*/
        ctx[45].input.type,
        true
      );
      insert(target, t15, anchor);
      insert(target, div7, anchor);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].m(div7, null);
      }
      insert(target, t16, anchor);
      insert(target, div8, anchor);
      append5(div8, button0);
      append5(div8, t17);
      append5(div8, button1);
      append5(div8, t18);
      append5(div8, button2);
      append5(div8, t20);
      append5(div8, button3);
      insert(target, t21, anchor);
      insert(target, hr, anchor);
      current = true;
      if (!mounted) {
        dispose = [
          listen(input0, "input", input0_input_handler_1),
          listen(input1, "input", input1_input_handler_1),
          action_destroyer(scrollWhenActive_action = scrollWhenActive.call(
            null,
            div3,
            /*index*/
            ctx[49] === /*activeFieldIndex*/
            ctx[5]
          )),
          listen(input2, "input", input2_input_handler_1),
          listen(select, "change", select_change_handler),
          action_destroyer(setIcon_action = import_obsidian14.setIcon.call(null, button0, "arrow-up")),
          listen(button0, "click", click_handler_2),
          action_destroyer(setIcon_action_1 = import_obsidian14.setIcon.call(null, button1, "arrow-down")),
          listen(button1, "click", click_handler_3),
          listen(button2, "click", click_handler_4),
          action_destroyer(setIcon_action_2 = import_obsidian14.setIcon.call(null, button3, "trash")),
          listen(button3, "click", click_handler_5)
        ];
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if (dirty[0] & /*definition*/
      1 && input0.value !== /*field*/
      ctx[45].name) {
        set_input_value(
          input0,
          /*field*/
          ctx[45].name
        );
      }
      if (dirty[0] & /*definition*/
      1 && input1.value !== /*field*/
      ctx[45].label) {
        set_input_value(
          input1,
          /*field*/
          ctx[45].label
        );
      }
      if (dirty[0] & /*definition*/
      1)
        show_if = ["text", "email", "tel", "number", "note", "tag", "dataview", "multiselect"].includes(
          /*field*/
          ctx[45].input.type
        );
      if (show_if) {
        if (if_block0) {
          if_block0.p(ctx, dirty);
          if (dirty[0] & /*definition*/
          1) {
            transition_in(if_block0, 1);
          }
        } else {
          if_block0 = create_if_block_8(ctx);
          if_block0.c();
          transition_in(if_block0, 1);
          if_block0.m(div3, t6);
        }
      } else if (if_block0) {
        group_outros();
        transition_out(if_block0, 1, 1, () => {
          if_block0 = null;
        });
        check_outros();
      }
      if (scrollWhenActive_action && is_function(scrollWhenActive_action.update) && dirty[0] & /*activeFieldIndex*/
      32)
        scrollWhenActive_action.update.call(
          null,
          /*index*/
          ctx[49] === /*activeFieldIndex*/
          ctx[5]
        );
      if (dirty[0] & /*definition*/
      1 && input2.value !== /*field*/
      ctx[45].description) {
        set_input_value(
          input2,
          /*field*/
          ctx[45].description
        );
      }
      if (dirty & /*Object*/
      0) {
        each_value_1 = ensure_array_like(Object.entries(InputTypeReadable));
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_12(ctx, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_12(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(select, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_1.length;
      }
      if (dirty[0] & /*definition*/
      1) {
        select_option(
          select,
          /*field*/
          ctx[45].input.type
        );
      }
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type_2(ctx, dirty);
      if (current_block_type_index === previous_block_index) {
        if (~current_block_type_index) {
          if_blocks[current_block_type_index].p(select_block_ctx(ctx, current_block_type_index), dirty);
        }
      } else {
        if (if_block1) {
          group_outros();
          transition_out(if_blocks[previous_block_index], 1, 1, () => {
            if_blocks[previous_block_index] = null;
          });
          check_outros();
        }
        if (~current_block_type_index) {
          if_block1 = if_blocks[current_block_type_index];
          if (!if_block1) {
            if_block1 = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](select_block_ctx(ctx, current_block_type_index));
            if_block1.c();
          } else {
            if_block1.p(select_block_ctx(ctx, current_block_type_index), dirty);
          }
          transition_in(if_block1, 1);
          if_block1.m(div7, null);
        } else {
          if_block1 = null;
        }
      }
      if (!current || dirty[0] & /*definition*/
      1 && button1_disabled_value !== (button1_disabled_value = /*index*/
      ctx[49] === /*definition*/
      ctx[0].fields.length - 1)) {
        button1.disabled = button1_disabled_value;
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block0);
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(if_block0);
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div3);
        detach(t9);
        detach(div6);
        detach(t15);
        detach(div7);
        detach(t16);
        detach(div8);
        detach(t21);
        detach(hr);
      }
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (~current_block_type_index) {
        if_blocks[current_block_type_index].d();
      }
      mounted = false;
      run_all(dispose);
    }
  };
}
function create_fragment11(ctx) {
  let div1;
  let tabs;
  let updating_activeTab;
  let t;
  let div0;
  let current_block_type_index;
  let if_block;
  let current;
  function tabs_activeTab_binding(value) {
    ctx[16](value);
  }
  let tabs_props = { tabs: ["form", "template"] };
  if (
    /*currentTab*/
    ctx[4] !== void 0
  ) {
    tabs_props.activeTab = /*currentTab*/
    ctx[4];
  }
  tabs = new Tabs_default({ props: tabs_props });
  binding_callbacks.push(() => bind2(tabs, "activeTab", tabs_activeTab_binding));
  const if_block_creators = [create_if_block5, create_else_block3];
  const if_blocks = [];
  function select_block_type(ctx2, dirty) {
    if (
      /*currentTab*/
      ctx2[4] === "template"
    )
      return 0;
    return 1;
  }
  current_block_type_index = select_block_type(ctx, [-1, -1]);
  if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx);
  return {
    c() {
      div1 = element("div");
      create_component(tabs.$$.fragment);
      t = space();
      div0 = element("div");
      if_block.c();
      attr(div0, "class", "body svelte-8lqyxl");
      attr(div1, "class", "wrapper modal-form svelte-8lqyxl");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      mount_component(tabs, div1, null);
      append5(div1, t);
      append5(div1, div0);
      if_blocks[current_block_type_index].m(div0, null);
      current = true;
    },
    p(ctx2, dirty) {
      const tabs_changes = {};
      if (!updating_activeTab && dirty[0] & /*currentTab*/
      16) {
        updating_activeTab = true;
        tabs_changes.activeTab = /*currentTab*/
        ctx2[4];
        add_flush_callback(() => updating_activeTab = false);
      }
      tabs.$set(tabs_changes);
      let previous_block_index = current_block_type_index;
      current_block_type_index = select_block_type(ctx2, dirty);
      if (current_block_type_index === previous_block_index) {
        if_blocks[current_block_type_index].p(ctx2, dirty);
      } else {
        group_outros();
        transition_out(if_blocks[previous_block_index], 1, 1, () => {
          if_blocks[previous_block_index] = null;
        });
        check_outros();
        if_block = if_blocks[current_block_type_index];
        if (!if_block) {
          if_block = if_blocks[current_block_type_index] = if_block_creators[current_block_type_index](ctx2);
          if_block.c();
        } else {
          if_block.p(ctx2, dirty);
        }
        transition_in(if_block, 1);
        if_block.m(div0, null);
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(tabs.$$.fragment, local);
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(tabs.$$.fragment, local);
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_component(tabs);
      if_blocks[current_block_type_index].d();
    }
  };
}
function scrollWhenActive(element2, isActive) {
  function update3(isActive2) {
    if (isActive2) {
      setTimeout(
        () => {
          element2.scrollIntoView({ behavior: "smooth", block: "center" });
        },
        100
      );
    }
  }
  update3(isActive);
  return { update: update3 };
}
function instance11($$self, $$props, $$invalidate) {
  let isValid;
  let errors;
  let activeFieldIndex;
  let fieldNames;
  let { definition = {
    title: "",
    name: "",
    version: "1",
    fields: []
  } } = $$props;
  let { onChange } = $$props;
  let { onSubmit } = $$props;
  let { onCancel } = $$props;
  let { onPreview } = $$props;
  let { app: app2 } = $$props;
  let currentTab = "form";
  function findFreeName(fieldIndex) {
    const field = definition.fields[fieldIndex];
    if (!field) {
      log_error(new ModalFormError("Unexpected error, no field at that index", fieldIndex + " leads to undefined"));
      return Date.now() + "";
    }
    let name = field.name;
    const allNames = definition.fields.map((f) => f.name);
    let i = 1;
    while (allNames.includes(name)) {
      name = `${field.name}_${i}`;
      i++;
    }
    return name;
  }
  function duplicateField(fieldIndex) {
    const field = definition.fields[fieldIndex];
    if (!field) {
      log_error(new ModalFormError("Unexpected error, no field at that index", fieldIndex + " leads to undefined"));
      return;
    }
    const newField = Object.assign(Object.assign({}, field), {
      input: structuredClone(field.input),
      name: findFreeName(fieldIndex)
    });
    definition.fields.splice(fieldIndex + 1, 0, newField);
    $$invalidate(0, definition);
    onChange();
    $$invalidate(5, activeFieldIndex = fieldIndex + 1);
  }
  function moveField(from, direction) {
    const to = direction === "up" ? from - 1 : from + 1;
    if (to < 0 || to >= definition.fields.length)
      return;
    const tmp = definition.fields[from];
    const target = definition.fields[to];
    if (!target || !tmp)
      return;
    $$invalidate(0, definition.fields[from] = target, definition);
    $$invalidate(0, definition.fields[to] = tmp, definition);
    $$invalidate(0, definition);
    onChange();
    $$invalidate(5, activeFieldIndex = to);
  }
  const handleSubmit = () => {
    if (!isValidFormDefinition(definition))
      return;
    onSubmit(definition);
  };
  function saveTemplate(parsedTemplate) {
    onSubmit(Object.assign(Object.assign({}, definition), {
      template: { parsedTemplate, createCommand: true }
    }));
  }
  const handlePreview = () => {
    if (!isValidFormDefinition(definition))
      return;
    console.log("preview of", definition);
    onPreview(definition);
  };
  function tabs_activeTab_binding(value) {
    currentTab = value;
    $$invalidate(4, currentTab);
  }
  function input0_input_handler() {
    definition.name = this.value;
    $$invalidate(0, definition);
  }
  function input1_input_handler() {
    definition.title = this.value;
    $$invalidate(0, definition);
  }
  function input2_input_handler() {
    definition.customClassname = this.value;
    $$invalidate(0, definition);
  }
  const click_handler = () => {
    $$invalidate(
      0,
      definition.fields = [
        ...definition.fields,
        {
          name: "",
          label: "",
          description: "",
          input: { type: "text", allowUnknownValues: false }
        }
      ],
      definition
    );
    $$invalidate(5, activeFieldIndex = definition.fields.length - 1);
  };
  const click_handler_1 = (error2) => {
    $$invalidate(5, activeFieldIndex = error2.index);
  };
  function input0_input_handler_1(each_value, index) {
    each_value[index].name = this.value;
    $$invalidate(0, definition);
  }
  function input1_input_handler_1(each_value, index) {
    each_value[index].label = this.value;
    $$invalidate(0, definition);
  }
  function toggle_checked_binding(value, field) {
    if ($$self.$$.not_equal(field.isRequired, value)) {
      field.isRequired = value;
      $$invalidate(0, definition);
    }
  }
  function input2_input_handler_1(each_value, index) {
    each_value[index].description = this.value;
    $$invalidate(0, definition);
  }
  function select_change_handler(each_value, index) {
    each_value[index].input.type = select_value(this);
    $$invalidate(0, definition);
  }
  function inputbuilderselect_source_binding(value, field) {
    if ($$self.$$.not_equal(field.input.source, value)) {
      field.input.source = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_options_binding(value, field) {
    if ($$self.$$.not_equal(field.input.options, value)) {
      field.input.options = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_folder_binding(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_source_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.source, value)) {
      field.input.source = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_options_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.multi_select_options, value)) {
      field.input.multi_select_options = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_folder_binding_1(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_query_binding(value, field) {
    if ($$self.$$.not_equal(field.input.query, value)) {
      field.input.query = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderselect_allowUnknownValues_binding(value, field) {
    if ($$self.$$.not_equal(field.input.allowUnknownValues, value)) {
      field.input.allowUnknownValues = value;
      $$invalidate(0, definition);
    }
  }
  function input0_input_handler_2(each_value, index) {
    each_value[index].input.min = to_number(this.value);
    $$invalidate(0, definition);
  }
  function input1_input_handler_2(each_value, index) {
    each_value[index].input.max = to_number(this.value);
    $$invalidate(0, definition);
  }
  function inputfolder_folder_binding(value, field) {
    if ($$self.$$.not_equal(field.input.folder, value)) {
      field.input.folder = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderdataview_value_binding(value, field) {
    if ($$self.$$.not_equal(field.input.query, value)) {
      field.input.query = value;
      $$invalidate(0, definition);
    }
  }
  function inputbuilderdocumentblock_body_binding(value, field) {
    if ($$self.$$.not_equal(field.input.body, value)) {
      field.input.body = value;
      $$invalidate(0, definition);
    }
  }
  const click_handler_2 = (index) => moveField(index, "up");
  const click_handler_3 = (index) => moveField(index, "down");
  const click_handler_4 = (index) => duplicateField(index);
  const click_handler_5 = (index) => {
    $$invalidate(0, definition.fields = definition.fields.filter((_, i) => i !== index), definition);
  };
  $$self.$$set = ($$props2) => {
    if ("definition" in $$props2)
      $$invalidate(0, definition = $$props2.definition);
    if ("onChange" in $$props2)
      $$invalidate(1, onChange = $$props2.onChange);
    if ("onSubmit" in $$props2)
      $$invalidate(14, onSubmit = $$props2.onSubmit);
    if ("onCancel" in $$props2)
      $$invalidate(2, onCancel = $$props2.onCancel);
    if ("onPreview" in $$props2)
      $$invalidate(15, onPreview = $$props2.onPreview);
    if ("app" in $$props2)
      $$invalidate(3, app2 = $$props2.app);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(8, isValid = isValidFormDefinition(definition));
    }
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(7, errors = validateFields(definition.fields));
    }
    if ($$self.$$.dirty[0] & /*definition*/
    1) {
      $:
        $$invalidate(6, fieldNames = pipe2(definition.fields, A.map((f) => f.name)));
    }
  };
  $:
    $$invalidate(5, activeFieldIndex = 0);
  return [
    definition,
    onChange,
    onCancel,
    app2,
    currentTab,
    activeFieldIndex,
    fieldNames,
    errors,
    isValid,
    duplicateField,
    moveField,
    handleSubmit,
    saveTemplate,
    handlePreview,
    onSubmit,
    onPreview,
    tabs_activeTab_binding,
    input0_input_handler,
    input1_input_handler,
    input2_input_handler,
    click_handler,
    click_handler_1,
    input0_input_handler_1,
    input1_input_handler_1,
    toggle_checked_binding,
    input2_input_handler_1,
    select_change_handler,
    inputbuilderselect_source_binding,
    inputbuilderselect_options_binding,
    inputbuilderselect_folder_binding,
    inputbuilderselect_source_binding_1,
    inputbuilderselect_options_binding_1,
    inputbuilderselect_folder_binding_1,
    inputbuilderselect_query_binding,
    inputbuilderselect_allowUnknownValues_binding,
    input0_input_handler_2,
    input1_input_handler_2,
    inputfolder_folder_binding,
    inputbuilderdataview_value_binding,
    inputbuilderdocumentblock_body_binding,
    click_handler_2,
    click_handler_3,
    click_handler_4,
    click_handler_5
  ];
}
var FormBuilder = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance11,
      create_fragment11,
      safe_not_equal,
      {
        definition: 0,
        onChange: 1,
        onSubmit: 14,
        onCancel: 2,
        onPreview: 15,
        app: 3
      },
      add_css8,
      [-1, -1]
    );
  }
};
var FormBuilder_default = FormBuilder;

// src/store/store.ts
var settings = writable({ ...getDefaultSettings() });
var formsStore = derived(settings, ($settings) => pipe2(
  $settings.formDefinitions,
  A.filter((form) => !(form instanceof MigrationError))
));
var { subscribe: subscribe2, update: update2, set } = settings;
var invalidFormsStore = derived(settings, ($settings) => {
  return pipe2(
    $settings.formDefinitions,
    A.filter((form) => form instanceof MigrationError)
  );
});
var settingsStore = {
  subscribe: subscribe2,
  set,
  updateForm(name, form) {
    update2((s) => {
      const forms = s.formDefinitions.map((f) => {
        if (f.name === name)
          return form;
        return f;
      });
      return { ...s, formDefinitions: forms };
    });
  },
  addNewForm(form) {
    update2((s) => {
      const forms = [...s.formDefinitions, form];
      return { ...s, formDefinitions: forms };
    });
  },
  removeForm(name) {
    update2((s) => {
      const forms = s.formDefinitions.filter((f) => f.name !== name);
      return { ...s, formDefinitions: forms };
    });
  },
  duplicateForm(formName) {
    update2((s) => {
      return { ...s, formDefinitions: duplicateForm(formName, s.formDefinitions) };
    });
  }
};

// src/views/EditFormView.ts
var EDIT_FORM_VIEW = "modal-form-edit-form-view";
function parseState(maybeState) {
  if (maybeState === null) {
    return false;
  }
  if (typeof maybeState !== "object") {
    return false;
  }
  if ("title" in maybeState && "name" in maybeState && "fields" in maybeState) {
    return true;
  }
  return false;
}
var EditFormView = class extends import_obsidian15.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.formState = { title: "", name: "", version: "1", fields: [] };
    this.icon = "note-glyph";
  }
  getViewType() {
    return EDIT_FORM_VIEW;
  }
  getDisplayText() {
    return "Edit form";
  }
  async onOpen() {
    this.containerEl.empty();
    this.formEditor = new FormBuilder_default({
      target: this.containerEl,
      props: {
        definition: this.formState,
        app: this.app,
        onChange: () => {
          console.log("Save form state", this.formState);
          this.app.workspace.requestSaveLayout();
        },
        onSubmit: (formDefinition) => {
          console.log("Submitting form", { formDefinition });
          if (this.originalFormName && this.originalFormName !== "") {
            settingsStore.updateForm(this.originalFormName, formDefinition);
          } else {
            settingsStore.addNewForm(formDefinition);
          }
          this.plugin.closeEditForm();
        },
        onCancel: () => {
          this.plugin.closeEditForm();
        },
        onPreview: async (formDefinition) => {
          const result = await this.plugin.api.openForm(formDefinition);
          const result_str = JSON.stringify(result, null, 2);
          log_notice("Form result", result_str);
          console.log(result_str);
        }
      }
    });
  }
  async onClose() {
    console.log("onClose of edit form called");
    this.formEditor.$destroy();
  }
  async setState(state, result) {
    console.log("setState of edit form called", state);
    if (parseState(state)) {
      this.formState = state;
      this.originalFormName = state.name;
      this.formEditor.$set({ definition: this.formState });
    }
    return super.setState(state, result);
  }
  getState() {
    return this.formState;
  }
};

// src/views/components/KeyValue.svelte
function add_css9(target) {
  append_styles(target, "svelte-1i8bb6o", "div.svelte-1i8bb6o{display:flex;flex-direction:row;align-items:flex-start;gap:var(--mf-spacing)}.key.svelte-1i8bb6o{color:var(--text-faint)}");
}
function create_fragment12(ctx) {
  let div;
  let span;
  let t0;
  let t1;
  let t2;
  let current;
  const default_slot_template = (
    /*#slots*/
    ctx[2].default
  );
  const default_slot = create_slot(
    default_slot_template,
    ctx,
    /*$$scope*/
    ctx[1],
    null
  );
  return {
    c() {
      div = element("div");
      span = element("span");
      t0 = text(
        /*key*/
        ctx[0]
      );
      t1 = text(":");
      t2 = space();
      if (default_slot)
        default_slot.c();
      attr(span, "class", "key svelte-1i8bb6o");
      attr(div, "class", "svelte-1i8bb6o");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, span);
      append5(span, t0);
      append5(span, t1);
      append5(div, t2);
      if (default_slot) {
        default_slot.m(div, null);
      }
      current = true;
    },
    p(ctx2, [dirty]) {
      if (!current || dirty & /*key*/
      1)
        set_data(
          t0,
          /*key*/
          ctx2[0]
        );
      if (default_slot) {
        if (default_slot.p && (!current || dirty & /*$$scope*/
        2)) {
          update_slot_base(
            default_slot,
            default_slot_template,
            ctx2,
            /*$$scope*/
            ctx2[1],
            !current ? get_all_dirty_from_scope(
              /*$$scope*/
              ctx2[1]
            ) : get_slot_changes(
              default_slot_template,
              /*$$scope*/
              ctx2[1],
              dirty,
              null
            ),
            null
          );
        }
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(default_slot, local);
      current = true;
    },
    o(local) {
      transition_out(default_slot, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      if (default_slot)
        default_slot.d(detaching);
    }
  };
}
function instance12($$self, $$props, $$invalidate) {
  let { $$slots: slots = {}, $$scope } = $$props;
  let { key } = $$props;
  $$self.$$set = ($$props2) => {
    if ("key" in $$props2)
      $$invalidate(0, key = $$props2.key);
    if ("$$scope" in $$props2)
      $$invalidate(1, $$scope = $$props2.$$scope);
  };
  return [key, $$scope, slots];
}
var KeyValue = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance12, create_fragment12, safe_not_equal, { key: 0 }, add_css9);
  }
};
var KeyValue_default = KeyValue;

// src/views/components/Button.svelte
var import_obsidian16 = require("obsidian");
function create_fragment13(ctx) {
  let span;
  return {
    c() {
      span = element("span");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      ctx[6](span);
    },
    p: noop,
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      ctx[6](null);
    }
  };
}
function instance13($$self, $$props, $$invalidate) {
  let { tooltip = void 0 } = $$props;
  let { icon = void 0 } = $$props;
  let { text: text3 = void 0 } = $$props;
  let { variant = "regular" } = $$props;
  let { onClick } = $$props;
  const variants = {
    regular: "modal-form-regular",
    danger: "modal-form-danger",
    primary: "modal-form-primary"
  };
  let root;
  onMount(() => {
    const btn = new import_obsidian16.ButtonComponent(root);
    if (icon)
      btn.setIcon(icon);
    if (tooltip)
      btn.setTooltip(tooltip);
    if (text3)
      btn.setButtonText(text3);
    btn.onClick(onClick);
    btn.setClass(variants[variant]);
  });
  function span_binding($$value) {
    binding_callbacks[$$value ? "unshift" : "push"](() => {
      root = $$value;
      $$invalidate(0, root);
    });
  }
  $$self.$$set = ($$props2) => {
    if ("tooltip" in $$props2)
      $$invalidate(1, tooltip = $$props2.tooltip);
    if ("icon" in $$props2)
      $$invalidate(2, icon = $$props2.icon);
    if ("text" in $$props2)
      $$invalidate(3, text3 = $$props2.text);
    if ("variant" in $$props2)
      $$invalidate(4, variant = $$props2.variant);
    if ("onClick" in $$props2)
      $$invalidate(5, onClick = $$props2.onClick);
  };
  return [root, tooltip, icon, text3, variant, onClick, span_binding];
}
var Button = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance13, create_fragment13, safe_not_equal, {
      tooltip: 1,
      icon: 2,
      text: 3,
      variant: 4,
      onClick: 5
    });
  }
};
var Button_default = Button;

// src/views/ManageForms.svelte
function add_css10(target) {
  append_styles(target, "svelte-1gkuvrl", ".form-row.svelte-1gkuvrl.svelte-1gkuvrl{display:flex;flex-direction:column;gap:8px}.form-row-buttons.svelte-1gkuvrl.svelte-1gkuvrl{display:flex;gap:8px}.form-name.svelte-1gkuvrl.svelte-1gkuvrl{margin-bottom:0}.header.svelte-1gkuvrl.svelte-1gkuvrl{display:flex;flex-direction:column;justify-content:space-between;align-items:flex-start}h5.svelte-1gkuvrl.svelte-1gkuvrl{margin-bottom:0}.flex-row.svelte-1gkuvrl.svelte-1gkuvrl{display:flex;flex-direction:row;gap:8px}pre.svelte-1gkuvrl.svelte-1gkuvrl{white-space:pre-wrap}.invalid-field-json.svelte-1gkuvrl.svelte-1gkuvrl{background-color:var(--background-secondary);padding:0 8px;margin:0}.invalid-field-json.svelte-1gkuvrl code.svelte-1gkuvrl{display:flex}");
}
function get_each_context6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_13(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_22(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[21] = list[i];
  return child_ctx;
}
function get_each_context_3(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[26] = list[i];
  return child_ctx;
}
function get_each_context_4(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[18] = list[i];
  return child_ctx;
}
function get_each_context_5(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[31] = list[i];
  return child_ctx;
}
function get_each_context_6(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[34] = list[i][0];
  child_ctx[35] = list[i][1];
  return child_ctx;
}
function create_if_block_23(ctx) {
  let h5;
  let t0;
  let t1_value = (
    /*$invalidForms*/
    ctx[4].length + ""
  );
  let t1;
  let t2;
  let t3;
  let p;
  return {
    c() {
      h5 = element("h5");
      t0 = text("There are ");
      t1 = text(t1_value);
      t2 = text(" invalid forms.");
      t3 = space();
      p = element("p");
      p.textContent = "Please take a look at the invalid forms section for details and potential fixes.";
      attr(h5, "class", "modal-form-danger svelte-1gkuvrl");
    },
    m(target, anchor) {
      insert(target, h5, anchor);
      append5(h5, t0);
      append5(h5, t1);
      append5(h5, t2);
      insert(target, t3, anchor);
      insert(target, p, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      16 && t1_value !== (t1_value = /*$invalidForms*/
      ctx2[4].length + ""))
        set_data(t1, t1_value);
    },
    d(detaching) {
      if (detaching) {
        detach(h5);
        detach(t3);
        detach(p);
      }
    }
  };
}
function create_if_block_13(ctx) {
  let keyvalue;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: (
        /*key*/
        ctx[34]
      ),
      $$slots: { default: [create_default_slot_32] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(keyvalue.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvalue, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const keyvalue_changes = {};
      if (dirty[0] & /*$forms*/
      32)
        keyvalue_changes.key = /*key*/
        ctx2[34];
      if (dirty[0] & /*$forms*/
      32 | dirty[1] & /*$$scope*/
      128) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_default_slot_32(ctx) {
  let span;
  let t_value = (Array.isArray(
    /*value*/
    ctx[35]
  ) ? (
    /*value*/
    ctx[35].length
  ) : typeof /*value*/
  ctx[35] === "object" ? !!/*value*/
  ctx[35] : (
    /*value*/
    ctx[35]
  )) + "";
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      32 && t_value !== (t_value = (Array.isArray(
        /*value*/
        ctx2[35]
      ) ? (
        /*value*/
        ctx2[35].length
      ) : typeof /*value*/
      ctx2[35] === "object" ? !!/*value*/
      ctx2[35] : (
        /*value*/
        ctx2[35]
      )) + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_6(ctx) {
  let if_block_anchor;
  let current;
  let if_block = (
    /*key*/
    ctx[34] !== "name" && create_if_block_13(ctx)
  );
  return {
    c() {
      if (if_block)
        if_block.c();
      if_block_anchor = empty3();
    },
    m(target, anchor) {
      if (if_block)
        if_block.m(target, anchor);
      insert(target, if_block_anchor, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      if (
        /*key*/
        ctx2[34] !== "name"
      ) {
        if (if_block) {
          if_block.p(ctx2, dirty);
          if (dirty[0] & /*$forms*/
          32) {
            transition_in(if_block, 1);
          }
        } else {
          if_block = create_if_block_13(ctx2);
          if_block.c();
          transition_in(if_block, 1);
          if_block.m(if_block_anchor.parentNode, if_block_anchor);
        }
      } else if (if_block) {
        group_outros();
        transition_out(if_block, 1, 1, () => {
          if_block = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(if_block);
      current = true;
    },
    o(local) {
      transition_out(if_block);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(if_block_anchor);
      }
      if (if_block)
        if_block.d(detaching);
    }
  };
}
function create_each_block_5(ctx) {
  let span;
  let t0_value = (
    /*field*/
    ctx[31].name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = space();
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t0);
      insert(target, t1, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      32 && t0_value !== (t0_value = /*field*/
      ctx2[31].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
        detach(t1);
      }
    }
  };
}
function create_default_slot_22(ctx) {
  let span;
  let each_value_5 = ensure_array_like(
    /*form*/
    ctx[18].fields
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_5.length; i += 1) {
    each_blocks[i] = create_each_block_5(get_each_context_5(ctx, each_value_5, i));
  }
  return {
    c() {
      span = element("span");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      set_style(span, "display", "flex");
      set_style(span, "flex-direction", "column");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(span, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$forms*/
      32) {
        each_value_5 = ensure_array_like(
          /*form*/
          ctx2[18].fields
        );
        let i;
        for (i = 0; i < each_value_5.length; i += 1) {
          const child_ctx = get_each_context_5(ctx2, each_value_5, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_5(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(span, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_5.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_4(ctx) {
  let div2;
  let h4;
  let t0_value = (
    /*form*/
    ctx[18].name + ""
  );
  let t0;
  let t1;
  let div0;
  let t2;
  let keyvalue;
  let t3;
  let div1;
  let button0;
  let t4;
  let button1;
  let t5;
  let button2;
  let t7;
  let button3;
  let current;
  let mounted;
  let dispose;
  let each_value_6 = ensure_array_like(Object.entries(
    /*form*/
    ctx[18]
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_6.length; i += 1) {
    each_blocks[i] = create_each_block_6(get_each_context_6(ctx, each_value_6, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  keyvalue = new KeyValue_default({
    props: {
      key: "Field names",
      $$slots: { default: [create_default_slot_22] },
      $$scope: { ctx }
    }
  });
  function func() {
    return (
      /*func*/
      ctx[14](
        /*form*/
        ctx[18]
      )
    );
  }
  button0 = new Button_default({
    props: {
      onClick: func,
      tooltip: `Delete ${/*form*/
      ctx[18].name}`,
      icon: "trash",
      variant: "danger"
    }
  });
  function func_1() {
    return (
      /*func_1*/
      ctx[15](
        /*form*/
        ctx[18]
      )
    );
  }
  button1 = new Button_default({
    props: {
      onClick: func_1,
      text: "Edit",
      variant: "primary",
      icon: "pencil"
    }
  });
  function click_handler() {
    return (
      /*click_handler*/
      ctx[16](
        /*form*/
        ctx[18]
      )
    );
  }
  function func_2() {
    return (
      /*func_2*/
      ctx[17](
        /*form*/
        ctx[18]
      )
    );
  }
  button3 = new Button_default({
    props: {
      tooltip: `Copy ${/*form*/
      ctx[18].name} to clipboard`,
      icon: "clipboard-copy",
      onClick: func_2
    }
  });
  return {
    c() {
      div2 = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      div0 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t2 = space();
      create_component(keyvalue.$$.fragment);
      t3 = space();
      div1 = element("div");
      create_component(button0.$$.fragment);
      t4 = space();
      create_component(button1.$$.fragment);
      t5 = space();
      button2 = element("button");
      button2.innerHTML = `<span>Duplicate</span>`;
      t7 = space();
      create_component(button3.$$.fragment);
      attr(h4, "class", "form-name svelte-1gkuvrl");
      attr(div1, "class", "form-row-buttons svelte-1gkuvrl");
      attr(div2, "class", "form-row svelte-1gkuvrl");
    },
    m(target, anchor) {
      insert(target, div2, anchor);
      append5(div2, h4);
      append5(h4, t0);
      append5(div2, t1);
      append5(div2, div0);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div0, null);
        }
      }
      append5(div0, t2);
      mount_component(keyvalue, div0, null);
      append5(div2, t3);
      append5(div2, div1);
      mount_component(button0, div1, null);
      append5(div1, t4);
      mount_component(button1, div1, null);
      append5(div1, t5);
      append5(div1, button2);
      append5(div1, t7);
      mount_component(button3, div1, null);
      current = true;
      if (!mounted) {
        dispose = listen(button2, "click", click_handler);
        mounted = true;
      }
    },
    p(new_ctx, dirty) {
      ctx = new_ctx;
      if ((!current || dirty[0] & /*$forms*/
      32) && t0_value !== (t0_value = /*form*/
      ctx[18].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$forms*/
      32) {
        each_value_6 = ensure_array_like(Object.entries(
          /*form*/
          ctx[18]
        ));
        let i;
        for (i = 0; i < each_value_6.length; i += 1) {
          const child_ctx = get_each_context_6(ctx, each_value_6, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div0, t2);
          }
        }
        group_outros();
        for (i = each_value_6.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      const keyvalue_changes = {};
      if (dirty[0] & /*$forms*/
      32 | dirty[1] & /*$$scope*/
      128) {
        keyvalue_changes.$$scope = { dirty, ctx };
      }
      keyvalue.$set(keyvalue_changes);
      const button0_changes = {};
      if (dirty[0] & /*$forms*/
      32)
        button0_changes.onClick = func;
      if (dirty[0] & /*$forms*/
      32)
        button0_changes.tooltip = `Delete ${/*form*/
        ctx[18].name}`;
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*$forms*/
      32)
        button1_changes.onClick = func_1;
      button1.$set(button1_changes);
      const button3_changes = {};
      if (dirty[0] & /*$forms*/
      32)
        button3_changes.tooltip = `Copy ${/*form*/
        ctx[18].name} to clipboard`;
      if (dirty[0] & /*$forms*/
      32)
        button3_changes.onClick = func_2;
      button3.$set(button3_changes);
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_6.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(keyvalue.$$.fragment, local);
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      transition_in(button3.$$.fragment, local);
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(keyvalue.$$.fragment, local);
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      transition_out(button3.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div2);
      }
      destroy_each(each_blocks, detaching);
      destroy_component(keyvalue);
      destroy_component(button0);
      destroy_component(button1);
      destroy_component(button3);
      mounted = false;
      dispose();
    }
  };
}
function create_if_block6(ctx) {
  let h3;
  let t1;
  let div;
  let current;
  let each_value = ensure_array_like(
    /*$invalidForms*/
    ctx[4]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block6(get_each_context6(ctx, each_value, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      h3 = element("h3");
      h3.textContent = "Invalid forms";
      t1 = space();
      div = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(h3, "class", "form-name modal-form-danger svelte-1gkuvrl");
    },
    m(target, anchor) {
      insert(target, h3, anchor);
      insert(target, t1, anchor);
      insert(target, div, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      current = true;
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      16) {
        each_value = ensure_array_like(
          /*$invalidForms*/
          ctx2[4]
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context6(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block6(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, null);
          }
        }
        group_outros();
        for (i = each_value.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(h3);
        detach(t1);
        detach(div);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_3(ctx) {
  let span;
  let t_value = (
    /*fieldError*/
    ctx[26] + ""
  );
  let t;
  return {
    c() {
      span = element("span");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      16 && t_value !== (t_value = /*fieldError*/
      ctx2[26] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_default_slot_14(ctx) {
  let each_1_anchor;
  let each_value_3 = ensure_array_like(
    /*error*/
    ctx[21].getFieldErrors()
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_3.length; i += 1) {
    each_blocks[i] = create_each_block_3(get_each_context_3(ctx, each_value_3, i));
  }
  return {
    c() {
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      each_1_anchor = empty3();
    },
    m(target, anchor) {
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(target, anchor);
        }
      }
      insert(target, each_1_anchor, anchor);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      16) {
        each_value_3 = ensure_array_like(
          /*error*/
          ctx2[21].getFieldErrors()
        );
        let i;
        for (i = 0; i < each_value_3.length; i += 1) {
          const child_ctx = get_each_context_3(ctx2, each_value_3, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block_3(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(each_1_anchor.parentNode, each_1_anchor);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value_3.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(each_1_anchor);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block_22(ctx) {
  let div;
  let pre;
  let code;
  let t0;
  let t1_value = "\n" + JSON.stringify(
    /*error*/
    ctx[21].field,
    null,
    1
  );
  let t1;
  let t2;
  let t3;
  let keyvalue;
  let t4;
  let hr;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: (
        /*error*/
        ctx[21].path
      ),
      $$slots: { default: [create_default_slot_14] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      div = element("div");
      pre = element("pre");
      code = element("code");
      t0 = text("\n                                    ");
      t1 = text(t1_value);
      t2 = text("\n                                ");
      t3 = space();
      create_component(keyvalue.$$.fragment);
      t4 = space();
      hr = element("hr");
      attr(code, "class", "svelte-1gkuvrl");
      attr(pre, "class", "invalid-field-json svelte-1gkuvrl");
      attr(div, "class", "flex-row svelte-1gkuvrl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, pre);
      append5(pre, code);
      append5(code, t0);
      append5(code, t1);
      append5(code, t2);
      append5(div, t3);
      mount_component(keyvalue, div, null);
      append5(div, t4);
      append5(div, hr);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$invalidForms*/
      16) && t1_value !== (t1_value = "\n" + JSON.stringify(
        /*error*/
        ctx2[21].field,
        null,
        1
      )))
        set_data(t1, t1_value);
      const keyvalue_changes = {};
      if (dirty[0] & /*$invalidForms*/
      16)
        keyvalue_changes.key = /*error*/
        ctx2[21].path;
      if (dirty[0] & /*$invalidForms*/
      16 | dirty[1] & /*$$scope*/
      128) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_component(keyvalue);
    }
  };
}
function create_default_slot6(ctx) {
  let span;
  let t0_value = (
    /*error*/
    ctx[21].name + ""
  );
  let t0;
  let t1;
  return {
    c() {
      span = element("span");
      t0 = text(t0_value);
      t1 = text(" \u2705");
    },
    m(target, anchor) {
      insert(target, span, anchor);
      append5(span, t0);
      append5(span, t1);
    },
    p(ctx2, dirty) {
      if (dirty[0] & /*$invalidForms*/
      16 && t0_value !== (t0_value = /*error*/
      ctx2[21].name + ""))
        set_data(t0, t0_value);
    },
    d(detaching) {
      if (detaching) {
        detach(span);
      }
    }
  };
}
function create_each_block_13(ctx) {
  let keyvalue;
  let current;
  keyvalue = new KeyValue_default({
    props: {
      key: "field",
      $$slots: { default: [create_default_slot6] },
      $$scope: { ctx }
    }
  });
  return {
    c() {
      create_component(keyvalue.$$.fragment);
    },
    m(target, anchor) {
      mount_component(keyvalue, target, anchor);
      current = true;
    },
    p(ctx2, dirty) {
      const keyvalue_changes = {};
      if (dirty[0] & /*$invalidForms*/
      16 | dirty[1] & /*$$scope*/
      128) {
        keyvalue_changes.$$scope = { dirty, ctx: ctx2 };
      }
      keyvalue.$set(keyvalue_changes);
    },
    i(local) {
      if (current)
        return;
      transition_in(keyvalue.$$.fragment, local);
      current = true;
    },
    o(local) {
      transition_out(keyvalue.$$.fragment, local);
      current = false;
    },
    d(detaching) {
      destroy_component(keyvalue, detaching);
    }
  };
}
function create_each_block6(ctx) {
  let div;
  let h4;
  let t0_value = (
    /*form*/
    ctx[18].name + ""
  );
  let t0;
  let t1;
  let t2;
  let t3;
  let current;
  let each_value_2 = ensure_array_like(left2(
    /*form*/
    ctx[18].fieldErrors
  ));
  let each_blocks_1 = [];
  for (let i = 0; i < each_value_2.length; i += 1) {
    each_blocks_1[i] = create_each_block_22(get_each_context_22(ctx, each_value_2, i));
  }
  const out = (i) => transition_out(each_blocks_1[i], 1, 1, () => {
    each_blocks_1[i] = null;
  });
  let each_value_1 = ensure_array_like(right2(
    /*form*/
    ctx[18].fieldErrors
  ));
  let each_blocks = [];
  for (let i = 0; i < each_value_1.length; i += 1) {
    each_blocks[i] = create_each_block_13(get_each_context_13(ctx, each_value_1, i));
  }
  const out_1 = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  return {
    c() {
      div = element("div");
      h4 = element("h4");
      t0 = text(t0_value);
      t1 = space();
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        each_blocks_1[i].c();
      }
      t2 = space();
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t3 = space();
      attr(h4, "class", "form-name svelte-1gkuvrl");
      attr(div, "class", "form-row svelte-1gkuvrl");
    },
    m(target, anchor) {
      insert(target, div, anchor);
      append5(div, h4);
      append5(h4, t0);
      append5(div, t1);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        if (each_blocks_1[i]) {
          each_blocks_1[i].m(div, null);
        }
      }
      append5(div, t2);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div, null);
        }
      }
      append5(div, t3);
      current = true;
    },
    p(ctx2, dirty) {
      if ((!current || dirty[0] & /*$invalidForms*/
      16) && t0_value !== (t0_value = /*form*/
      ctx2[18].name + ""))
        set_data(t0, t0_value);
      if (dirty[0] & /*$invalidForms*/
      16) {
        each_value_2 = ensure_array_like(left2(
          /*form*/
          ctx2[18].fieldErrors
        ));
        let i;
        for (i = 0; i < each_value_2.length; i += 1) {
          const child_ctx = get_each_context_22(ctx2, each_value_2, i);
          if (each_blocks_1[i]) {
            each_blocks_1[i].p(child_ctx, dirty);
            transition_in(each_blocks_1[i], 1);
          } else {
            each_blocks_1[i] = create_each_block_22(child_ctx);
            each_blocks_1[i].c();
            transition_in(each_blocks_1[i], 1);
            each_blocks_1[i].m(div, t2);
          }
        }
        group_outros();
        for (i = each_value_2.length; i < each_blocks_1.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (dirty[0] & /*$invalidForms*/
      16) {
        each_value_1 = ensure_array_like(right2(
          /*form*/
          ctx2[18].fieldErrors
        ));
        let i;
        for (i = 0; i < each_value_1.length; i += 1) {
          const child_ctx = get_each_context_13(ctx2, each_value_1, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_13(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div, t3);
          }
        }
        group_outros();
        for (i = each_value_1.length; i < each_blocks.length; i += 1) {
          out_1(i);
        }
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      for (let i = 0; i < each_value_2.length; i += 1) {
        transition_in(each_blocks_1[i]);
      }
      for (let i = 0; i < each_value_1.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      current = true;
    },
    o(local) {
      each_blocks_1 = each_blocks_1.filter(Boolean);
      for (let i = 0; i < each_blocks_1.length; i += 1) {
        transition_out(each_blocks_1[i]);
      }
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div);
      }
      destroy_each(each_blocks_1, detaching);
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_fragment14(ctx) {
  let div1;
  let h1;
  let t1;
  let div0;
  let button0;
  let t2;
  let button1;
  let t3;
  let t4;
  let div2;
  let t5;
  let current;
  button0 = new Button_default({
    props: {
      onClick: (
        /*createNewForm*/
        ctx[0]
      ),
      text: "Create new form",
      variant: "primary"
    }
  });
  button1 = new Button_default({
    props: {
      onClick: (
        /*openImportFormModal*/
        ctx[1]
      ),
      text: "Import form",
      variant: "regular"
    }
  });
  let if_block0 = (
    /*$invalidForms*/
    ctx[4].length && create_if_block_23(ctx)
  );
  let each_value_4 = ensure_array_like(
    /*$forms*/
    ctx[5]
  );
  let each_blocks = [];
  for (let i = 0; i < each_value_4.length; i += 1) {
    each_blocks[i] = create_each_block_4(get_each_context_4(ctx, each_value_4, i));
  }
  const out = (i) => transition_out(each_blocks[i], 1, 1, () => {
    each_blocks[i] = null;
  });
  let if_block1 = (
    /*$invalidForms*/
    ctx[4].length && create_if_block6(ctx)
  );
  return {
    c() {
      div1 = element("div");
      h1 = element("h1");
      h1.textContent = "Manage forms";
      t1 = space();
      div0 = element("div");
      create_component(button0.$$.fragment);
      t2 = space();
      create_component(button1.$$.fragment);
      t3 = space();
      if (if_block0)
        if_block0.c();
      t4 = space();
      div2 = element("div");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      t5 = space();
      if (if_block1)
        if_block1.c();
      attr(div0, "class", "flex gap-1");
      attr(div1, "class", "header svelte-1gkuvrl");
      attr(div2, "id", "form-rows");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append5(div1, h1);
      append5(div1, t1);
      append5(div1, div0);
      mount_component(button0, div0, null);
      append5(div0, t2);
      mount_component(button1, div0, null);
      append5(div1, t3);
      if (if_block0)
        if_block0.m(div1, null);
      insert(target, t4, anchor);
      insert(target, div2, anchor);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(div2, null);
        }
      }
      append5(div2, t5);
      if (if_block1)
        if_block1.m(div2, null);
      current = true;
    },
    p(ctx2, dirty) {
      const button0_changes = {};
      if (dirty[0] & /*createNewForm*/
      1)
        button0_changes.onClick = /*createNewForm*/
        ctx2[0];
      button0.$set(button0_changes);
      const button1_changes = {};
      if (dirty[0] & /*openImportFormModal*/
      2)
        button1_changes.onClick = /*openImportFormModal*/
        ctx2[1];
      button1.$set(button1_changes);
      if (
        /*$invalidForms*/
        ctx2[4].length
      ) {
        if (if_block0) {
          if_block0.p(ctx2, dirty);
        } else {
          if_block0 = create_if_block_23(ctx2);
          if_block0.c();
          if_block0.m(div1, null);
        }
      } else if (if_block0) {
        if_block0.d(1);
        if_block0 = null;
      }
      if (dirty[0] & /*$forms, handleCopyForm, handleDuplicateForm, handleEditForm, handleDeleteForm*/
      992) {
        each_value_4 = ensure_array_like(
          /*$forms*/
          ctx2[5]
        );
        let i;
        for (i = 0; i < each_value_4.length; i += 1) {
          const child_ctx = get_each_context_4(ctx2, each_value_4, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
            transition_in(each_blocks[i], 1);
          } else {
            each_blocks[i] = create_each_block_4(child_ctx);
            each_blocks[i].c();
            transition_in(each_blocks[i], 1);
            each_blocks[i].m(div2, t5);
          }
        }
        group_outros();
        for (i = each_value_4.length; i < each_blocks.length; i += 1) {
          out(i);
        }
        check_outros();
      }
      if (
        /*$invalidForms*/
        ctx2[4].length
      ) {
        if (if_block1) {
          if_block1.p(ctx2, dirty);
          if (dirty[0] & /*$invalidForms*/
          16) {
            transition_in(if_block1, 1);
          }
        } else {
          if_block1 = create_if_block6(ctx2);
          if_block1.c();
          transition_in(if_block1, 1);
          if_block1.m(div2, null);
        }
      } else if (if_block1) {
        group_outros();
        transition_out(if_block1, 1, 1, () => {
          if_block1 = null;
        });
        check_outros();
      }
    },
    i(local) {
      if (current)
        return;
      transition_in(button0.$$.fragment, local);
      transition_in(button1.$$.fragment, local);
      for (let i = 0; i < each_value_4.length; i += 1) {
        transition_in(each_blocks[i]);
      }
      transition_in(if_block1);
      current = true;
    },
    o(local) {
      transition_out(button0.$$.fragment, local);
      transition_out(button1.$$.fragment, local);
      each_blocks = each_blocks.filter(Boolean);
      for (let i = 0; i < each_blocks.length; i += 1) {
        transition_out(each_blocks[i]);
      }
      transition_out(if_block1);
      current = false;
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
        detach(t4);
        detach(div2);
      }
      destroy_component(button0);
      destroy_component(button1);
      if (if_block0)
        if_block0.d();
      destroy_each(each_blocks, detaching);
      if (if_block1)
        if_block1.d();
    }
  };
}
function instance14($$self, $$props, $$invalidate) {
  let $invalidForms, $$unsubscribe_invalidForms = noop, $$subscribe_invalidForms = () => ($$unsubscribe_invalidForms(), $$unsubscribe_invalidForms = subscribe(invalidForms, ($$value) => $$invalidate(4, $invalidForms = $$value)), invalidForms);
  let $forms, $$unsubscribe_forms = noop, $$subscribe_forms = () => ($$unsubscribe_forms(), $$unsubscribe_forms = subscribe(forms, ($$value) => $$invalidate(5, $forms = $$value)), forms);
  $$self.$$.on_destroy.push(() => $$unsubscribe_invalidForms());
  $$self.$$.on_destroy.push(() => $$unsubscribe_forms());
  let { createNewForm } = $$props;
  let { deleteForm } = $$props;
  let { duplicateForm: duplicateForm2 } = $$props;
  let { editForm } = $$props;
  let { copyFormToClipboard } = $$props;
  let { openImportFormModal } = $$props;
  let { forms } = $$props;
  $$subscribe_forms();
  let { invalidForms } = $$props;
  $$subscribe_invalidForms();
  function handleDeleteForm(formName) {
    const confirmed = confirm(`Are you sure you want to delete ${formName}?`);
    if (confirmed) {
      console.log(`Deleting ${formName}`);
      deleteForm(formName);
    }
  }
  function handleEditForm(formName) {
    console.log(`Editing ${formName}`);
    editForm(formName);
  }
  function handleDuplicateForm(form) {
    console.log(`Duplicating ${form.name}`);
    duplicateForm2(form.name);
  }
  function handleCopyForm(form) {
    console.log(`Copying ${form.name}`);
    copyFormToClipboard(form);
  }
  const func = (form) => handleDeleteForm(form.name);
  const func_1 = (form) => handleEditForm(form.name);
  const click_handler = (form) => handleDuplicateForm(form);
  const func_2 = (form) => handleCopyForm(form);
  $$self.$$set = ($$props2) => {
    if ("createNewForm" in $$props2)
      $$invalidate(0, createNewForm = $$props2.createNewForm);
    if ("deleteForm" in $$props2)
      $$invalidate(10, deleteForm = $$props2.deleteForm);
    if ("duplicateForm" in $$props2)
      $$invalidate(11, duplicateForm2 = $$props2.duplicateForm);
    if ("editForm" in $$props2)
      $$invalidate(12, editForm = $$props2.editForm);
    if ("copyFormToClipboard" in $$props2)
      $$invalidate(13, copyFormToClipboard = $$props2.copyFormToClipboard);
    if ("openImportFormModal" in $$props2)
      $$invalidate(1, openImportFormModal = $$props2.openImportFormModal);
    if ("forms" in $$props2)
      $$subscribe_forms($$invalidate(2, forms = $$props2.forms));
    if ("invalidForms" in $$props2)
      $$subscribe_invalidForms($$invalidate(3, invalidForms = $$props2.invalidForms));
  };
  return [
    createNewForm,
    openImportFormModal,
    forms,
    invalidForms,
    $invalidForms,
    $forms,
    handleDeleteForm,
    handleEditForm,
    handleDuplicateForm,
    handleCopyForm,
    deleteForm,
    duplicateForm2,
    editForm,
    copyFormToClipboard,
    func,
    func_1,
    click_handler,
    func_2
  ];
}
var ManageForms = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(
      this,
      options,
      instance14,
      create_fragment14,
      safe_not_equal,
      {
        createNewForm: 0,
        deleteForm: 10,
        duplicateForm: 11,
        editForm: 12,
        copyFormToClipboard: 13,
        openImportFormModal: 1,
        forms: 2,
        invalidForms: 3
      },
      add_css10,
      [-1, -1]
    );
  }
};
var ManageForms_default = ManageForms;

// src/views/ManageFormsView.ts
var import_obsidian17 = require("obsidian");
var MANAGE_FORMS_VIEW = "modal-form-manage-forms-view";
var ManageFormsView = class extends import_obsidian17.ItemView {
  constructor(leaf, plugin) {
    super(leaf);
    this.leaf = leaf;
    this.plugin = plugin;
    this.icon = "documents";
  }
  getViewType() {
    return MANAGE_FORMS_VIEW;
  }
  getDisplayText() {
    return "Manage forms";
  }
  async onOpen() {
    const container = this.containerEl.children[1] || this.containerEl.createDiv();
    container.empty();
    this.component = new ManageForms_default({
      target: container,
      props: {
        forms: formsStore,
        invalidForms: invalidFormsStore,
        createNewForm: () => {
          this.plugin.createNewForm();
        },
        editForm: (formName) => {
          this.plugin.editForm(formName);
        },
        deleteForm: (formName) => {
          settingsStore.removeForm(formName);
        },
        duplicateForm: (formName) => {
          settingsStore.duplicateForm(formName);
        },
        copyFormToClipboard: async (form) => {
          await navigator.clipboard.writeText(JSON.stringify(form, null, 2));
          new import_obsidian17.Notice("Form has been copied to the clipboard");
        },
        openImportFormModal: () => {
          this.plugin.openImportFormModal();
        }
      }
    });
  }
  async onClose() {
    this.component.$destroy();
  }
};

// src/suggesters/NewNoteModal.ts
var import_obsidian19 = require("obsidian");

// src/suggesters/suggestGeneric.ts
var import_obsidian18 = require("obsidian");
var GenericSuggest = class extends import_obsidian18.AbstractInputSuggest {
  constructor(app2, inputEl, content, strategy) {
    super(app2, inputEl);
    this.inputEl = inputEl;
    this.strategy = strategy;
    this.content = content;
  }
  getSuggestions(inputStr) {
    const lowerCaseInputStr = inputStr.toLowerCase();
    return this.strategy.getSuggestions(lowerCaseInputStr, [...this.content]);
  }
  renderSuggestion(content, el) {
    return this.strategy.renderSuggestion(content, el);
  }
  selectSuggestion(value) {
    this.inputEl.value = this.strategy.selectSuggestion(value);
    this.inputEl.trigger("input");
    this.close();
  }
};

// src/suggesters/NewNoteModal.ts
var formSuggester = (app2, input, forms, onChange) => new GenericSuggest(
  app2,
  input,
  new Set(forms),
  {
    getSuggestions: (inputStr, forms2) => {
      return forms2.filter((form) => form.name.toLowerCase().contains(inputStr));
    },
    renderSuggestion: (form, el) => {
      el.setText(form.name);
    },
    selectSuggestion: (form) => {
      onChange(form);
      return form.name;
    }
  }
);
var NewNoteModal = class extends import_obsidian19.Modal {
  constructor(app2, forms, onSelected) {
    super(app2);
    this.forms = forms;
    this.onSelected = onSelected;
  }
  onOpen() {
    let destinationFolder = "";
    let form;
    let noteName = "";
    const { contentEl } = this;
    contentEl.createEl("h1", { text: "New Note from form" });
    new import_obsidian19.Setting(contentEl).addSearch((element2) => {
      formSuggester(this.app, element2.inputEl, this.forms, (value) => {
        form = value;
      });
    }).setDesc("Pick a form");
    new import_obsidian19.Setting(contentEl).addSearch((element2) => {
      new FolderSuggest(element2.inputEl, this.app);
      element2.onChange((value) => {
        destinationFolder = value;
      });
    }).setName("Destination folder");
    new import_obsidian19.Setting(contentEl).addText((element2) => {
      element2.onChange((value) => {
        noteName = value;
      });
    }).setName("Note name");
    new import_obsidian19.Setting(contentEl).addButton((element2) => {
      element2.setButtonText("Create new note");
      element2.onClick(() => {
        if (!form || !destinationFolder.trim() || !noteName.trim()) {
          log_notice("Missing fields", "Please fill all the fields");
          return;
        }
        this.close();
        this.onSelected({
          form,
          folder: destinationFolder.trim(),
          noteName: noteName.trim()
        });
      });
    });
  }
  onClose() {
    const { contentEl } = this;
    contentEl.empty();
  }
};

// src/suggesters/FormPickerModal.ts
var import_obsidian20 = require("obsidian");
var FormPickerModal = class extends import_obsidian20.FuzzySuggestModal {
  constructor(app2, forms, onSelected) {
    super(app2);
    this.forms = forms;
    this.onSelected = onSelected;
  }
  getItems() {
    return this.forms;
  }
  getItemText(item2) {
    return item2.title;
  }
  onChooseItem(item2, _) {
    this.close();
    this.onSelected(item2);
  }
};

// src/views/FormImportView.ts
var import_obsidian21 = require("obsidian");

// src/views/FormImport.svelte
function add_css11(target) {
  append_styles(target, "svelte-it9buy", ".vertical.svelte-it9buy{display:flex;flex-direction:column;height:100%;gap:1rem}.full-height.svelte-it9buy{height:100%;flex:1}.horizontal.svelte-it9buy{display:flex;flex-direction:row;height:100%;gap:0.5rem}button.svelte-it9buy:disabled{opacity:0.5;cursor:not-allowed}.mainView.svelte-it9buy{padding:0.8rem;min-height:50vh}p.svelte-it9buy{margin:0}textarea.svelte-it9buy{font-family:monospace;flex-grow:1;flex-shrink:0;flex-basis:50%}");
}
function get_each_context7(ctx, list, i) {
  const child_ctx = ctx.slice();
  child_ctx[8] = list[i];
  return child_ctx;
}
function create_if_block7(ctx) {
  let div1;
  let p;
  let t1;
  let div0;
  let ul;
  let each_value = ensure_array_like(
    /*ui*/
    ctx[1].errors
  );
  let each_blocks = [];
  for (let i = 0; i < each_value.length; i += 1) {
    each_blocks[i] = create_each_block7(get_each_context7(ctx, each_value, i));
  }
  return {
    c() {
      div1 = element("div");
      p = element("p");
      p.textContent = "We found the following errors in the form definition:";
      t1 = space();
      div0 = element("div");
      ul = element("ul");
      for (let i = 0; i < each_blocks.length; i += 1) {
        each_blocks[i].c();
      }
      attr(p, "class", "modal-form-danger svelte-it9buy");
      attr(div1, "class", "vertical svelte-it9buy");
    },
    m(target, anchor) {
      insert(target, div1, anchor);
      append5(div1, p);
      append5(div1, t1);
      append5(div1, div0);
      append5(div0, ul);
      for (let i = 0; i < each_blocks.length; i += 1) {
        if (each_blocks[i]) {
          each_blocks[i].m(ul, null);
        }
      }
    },
    p(ctx2, dirty) {
      if (dirty & /*ui*/
      2) {
        each_value = ensure_array_like(
          /*ui*/
          ctx2[1].errors
        );
        let i;
        for (i = 0; i < each_value.length; i += 1) {
          const child_ctx = get_each_context7(ctx2, each_value, i);
          if (each_blocks[i]) {
            each_blocks[i].p(child_ctx, dirty);
          } else {
            each_blocks[i] = create_each_block7(child_ctx);
            each_blocks[i].c();
            each_blocks[i].m(ul, null);
          }
        }
        for (; i < each_blocks.length; i += 1) {
          each_blocks[i].d(1);
        }
        each_blocks.length = each_value.length;
      }
    },
    d(detaching) {
      if (detaching) {
        detach(div1);
      }
      destroy_each(each_blocks, detaching);
    }
  };
}
function create_each_block7(ctx) {
  let li;
  let t_value = (
    /*error*/
    ctx[8] + ""
  );
  let t;
  return {
    c() {
      li = element("li");
      t = text(t_value);
    },
    m(target, anchor) {
      insert(target, li, anchor);
      append5(li, t);
    },
    p(ctx2, dirty) {
      if (dirty & /*ui*/
      2 && t_value !== (t_value = /*error*/
      ctx2[8] + ""))
        set_data(t, t_value);
    },
    d(detaching) {
      if (detaching) {
        detach(li);
      }
    }
  };
}
function create_fragment15(ctx) {
  let div3;
  let h1;
  let t1;
  let div0;
  let t3;
  let div2;
  let textarea;
  let t4;
  let div1;
  let t5;
  let button;
  let t6;
  let t7_value = (
    /*ui*/
    ctx[1].buttonHint + ""
  );
  let t7;
  let button_disabled_value;
  let mounted;
  let dispose;
  let if_block = (
    /*ui*/
    ctx[1].errors.length > 0 && create_if_block7(ctx)
  );
  return {
    c() {
      div3 = element("div");
      h1 = element("h1");
      h1.textContent = "Import a form";
      t1 = space();
      div0 = element("div");
      div0.textContent = "Import a form by pasting the JSON definition into the box below. You can export a form from\n        the Form Builder. Any errors in the JSON will be displayed below. You will only be able to\n        import the form if there are no errors.";
      t3 = space();
      div2 = element("div");
      textarea = element("textarea");
      t4 = space();
      div1 = element("div");
      if (if_block)
        if_block.c();
      t5 = space();
      button = element("button");
      t6 = text("Import ");
      t7 = text(t7_value);
      attr(textarea, "class", "form-input svelte-it9buy");
      attr(textarea, "placeholder", "Paste your form JSON here");
      attr(button, "class", "btn btn-primary svelte-it9buy");
      button.disabled = button_disabled_value = !/*ui*/
      ctx[1].canSubmit;
      attr(div1, "class", "vertical svelte-it9buy");
      attr(div2, "class", "horizontal full-height svelte-it9buy");
      attr(div3, "class", "vertical mainView svelte-it9buy");
    },
    m(target, anchor) {
      insert(target, div3, anchor);
      append5(div3, h1);
      append5(div3, t1);
      append5(div3, div0);
      append5(div3, t3);
      append5(div3, div2);
      append5(div2, textarea);
      set_input_value(
        textarea,
        /*value*/
        ctx[0]
      );
      append5(div2, t4);
      append5(div2, div1);
      if (if_block)
        if_block.m(div1, null);
      append5(div1, t5);
      append5(div1, button);
      append5(button, t6);
      append5(button, t7);
      if (!mounted) {
        dispose = [
          listen(
            textarea,
            "input",
            /*textarea_input_handler*/
            ctx[6]
          ),
          listen(
            textarea,
            "input",
            /*input_handler*/
            ctx[7]
          ),
          listen(button, "click", function() {
            if (is_function(
              /*ui*/
              ctx[1].onSubmit
            ))
              ctx[1].onSubmit.apply(this, arguments);
          })
        ];
        mounted = true;
      }
    },
    p(new_ctx, [dirty]) {
      ctx = new_ctx;
      if (dirty & /*value*/
      1) {
        set_input_value(
          textarea,
          /*value*/
          ctx[0]
        );
      }
      if (
        /*ui*/
        ctx[1].errors.length > 0
      ) {
        if (if_block) {
          if_block.p(ctx, dirty);
        } else {
          if_block = create_if_block7(ctx);
          if_block.c();
          if_block.m(div1, t5);
        }
      } else if (if_block) {
        if_block.d(1);
        if_block = null;
      }
      if (dirty & /*ui*/
      2 && t7_value !== (t7_value = /*ui*/
      ctx[1].buttonHint + ""))
        set_data(t7, t7_value);
      if (dirty & /*ui*/
      2 && button_disabled_value !== (button_disabled_value = !/*ui*/
      ctx[1].canSubmit)) {
        button.disabled = button_disabled_value;
      }
    },
    i: noop,
    o: noop,
    d(detaching) {
      if (detaching) {
        detach(div3);
      }
      if (if_block)
        if_block.d();
      mounted = false;
      run_all(dispose);
    }
  };
}
function instance15($$self, $$props, $$invalidate) {
  let ui;
  let $state;
  let { model } = $$props;
  const { state, validate } = model;
  component_subscribe($$self, state, (value2) => $$invalidate(5, $state = value2));
  let value = "";
  function textarea_input_handler() {
    value = this.value;
    $$invalidate(0, value);
  }
  const input_handler = () => validate(value);
  $$self.$$set = ($$props2) => {
    if ("model" in $$props2)
      $$invalidate(4, model = $$props2.model);
  };
  $$self.$$.update = () => {
    if ($$self.$$.dirty & /*model, $state*/
    48) {
      $:
        $$invalidate(1, ui = model.uiState($state));
    }
  };
  return [
    value,
    ui,
    state,
    validate,
    model,
    $state,
    textarea_input_handler,
    input_handler
  ];
}
var FormImport = class extends SvelteComponent {
  constructor(options) {
    super();
    init3(this, options, instance15, create_fragment15, safe_not_equal, { model: 4 }, add_css11);
  }
};
var FormImport_default = FormImport;

// node_modules/fp-ts/es6/Json.js
var parse4 = function(s) {
  return tryCatch(function() {
    return JSON.parse(s);
  }, identity);
};

// src/views/FormImport.ts
function matchState(state, matchers) {
  return pipe2(
    state,
    match(
      matchers.error,
      (form) => pipe2(
        form,
        // prettier, shut up
        O.match(matchers.empty, matchers.ok)
      )
    )
  );
}
function noop2() {
}
function makeFormInputModel({ createForm }) {
  const state = writable(of(O.none));
  const setErrors = (errors) => state.set(left3(errors));
  const resetState = () => state.set(of(O.none));
  return {
    state,
    uiState(state2) {
      return matchState(state2, {
        empty: () => ({ canSubmit: false, errors: [], onSubmit: noop2, buttonHint: "" }),
        ok: (form) => ({
          canSubmit: true,
          errors: [],
          onSubmit: () => createForm(form),
          buttonHint: "\u2705"
        }),
        error: (errors) => ({ canSubmit: false, errors, onSubmit: noop2, buttonHint: "\u274C" })
      });
    },
    validate: (value) => {
      if (value.trim() === "") {
        resetState();
        return;
      }
      pipe2(
        value,
        parse4,
        mapLeft(ensureError),
        chainW(migrateToLatest),
        match(
          (error2) => {
            if (error2 instanceof InvalidData) {
              setErrors(error2.toArrayOfStrings());
              return;
            }
            setErrors([error2.toString()]);
          },
          (form) => {
            if (form instanceof MigrationError) {
              setErrors(form.toArrayOfStrings());
              return;
            }
            state.set(of(O.some(form)));
            console.log(form);
          }
        )
      );
    }
  };
}

// src/views/FormImportView.ts
var FormImportModal = class extends import_obsidian21.Modal {
  constructor(app2, deps) {
    super(app2);
    this.deps = deps;
  }
  onClose() {
    this._component.$destroy();
  }
  onOpen() {
    const { contentEl } = this;
    this._component = new FormImport_default({
      target: contentEl,
      props: { model: makeFormInputModel(this.deps) }
    });
  }
};

// src/main.ts
function notifyParsingErrors(errors) {
  if (errors.length === 0) {
    return;
  }
  log_notice(
    "\u26A0\uFE0F Some forms could not be parsed \u26A0\uFE0F",
    `We found some invalid data while parsing the form settings, please take a look at the following errors: 
            ${errors.join("\n")}`
  );
}
function notifyMigrationErrors(errors) {
  if (errors.length === 0) {
    return;
  }
  log_notice(
    "Some forms could not be migrated",
    `We tried to perform an automatic migration, but we failed. Go to the forms manager and fix the following forms:
            ${errors.map((e) => e.name).join("\n")}`
  );
}
var ModalFormPlugin = class extends import_obsidian22.Plugin {
  constructor() {
    super(...arguments);
    this.unsubscribeSettingsStore = () => {
    };
  }
  manageForms() {
    return this.activateView(MANAGE_FORMS_VIEW);
  }
  createNewForm() {
    return this.activateView(EDIT_FORM_VIEW);
  }
  /**
   * Opens the form in the editor.
   * @returns
   */
  async editForm(formName) {
    const savedSettings = await this.getSettings();
    const formDefinition = savedSettings.formDefinitions.find((form) => form.name === formName);
    if (!formDefinition) {
      throw new ModalFormError(`Form ${formName} not found`);
    }
    if (formDefinition instanceof MigrationError) {
      notifyMigrationErrors([formDefinition]);
      return;
    }
    await this.activateView(EDIT_FORM_VIEW, formDefinition);
  }
  openImportFormModal() {
    const importModal = new FormImportModal(this.app, {
      createForm: (form) => {
        importModal.close();
        this.activateView(EDIT_FORM_VIEW, form);
      }
    });
    importModal.open();
  }
  closeEditForm() {
    this.app.workspace.detachLeavesOfType(EDIT_FORM_VIEW);
  }
  onunload() {
    this.unsubscribeSettingsStore();
  }
  async activateView(viewType, state) {
    var _a, _b, _c, _d;
    const { workspace } = this.app;
    let leaf = workspace.getLeavesOfType(viewType)[0];
    if (leaf) {
      console.info("found leaf, no reason to create a new one");
    } else if (import_obsidian22.Platform.isMobile || ((_a = this.settings) == null ? void 0 : _a.editorPosition) === "mainView") {
      leaf = this.app.workspace.getLeaf("tab");
    } else if (((_b = this.settings) == null ? void 0 : _b.editorPosition) === "right") {
      leaf = this.app.workspace.getRightLeaf(false);
    } else if (((_c = this.settings) == null ? void 0 : _c.editorPosition) === "left") {
      leaf = this.app.workspace.getLeftLeaf(false);
    } else if (((_d = this.settings) == null ? void 0 : _d.editorPosition) === "modal") {
      leaf = this.app.workspace.getLeaf(false);
    } else {
      leaf = this.app.workspace.getRightLeaf(false);
    }
    await leaf.setViewState({
      type: viewType,
      active: true,
      state
    });
    this.app.workspace.revealLeaf(leaf);
    return leaf;
  }
  // TODO: extract the migration logic to a separate function and test it
  // TODO: collect actual migration events to decide if we need to migrate or not rather than this naive approach
  async getSettings() {
    const data = await this.loadData();
    const [migrationIsNeeded, settings2] = pipe2(
      parseSettings(data),
      E.map((settings3) => {
        const migrationIsNeeded2 = settings3.formDefinitions.some(formNeedsMigration);
        const { right: formDefinitions, left: errors } = A.partitionMap(migrateToLatest)(
          settings3.formDefinitions
        );
        notifyParsingErrors(errors);
        const validSettings = {
          ...settings3,
          formDefinitions
        };
        return [migrationIsNeeded2, validSettings];
      }),
      E.getOrElse(() => [false, getDefaultSettings()])
    );
    if (migrationIsNeeded) {
      await this.saveSettings(settings2);
      console.info("Settings were migrated to the latest version");
    }
    return settings2;
  }
  async saveSettings(newSettings) {
    await this.saveData(newSettings || this.settings);
  }
  async setEditorPosition(position) {
    this.settings.editorPosition = position;
    await this.saveSettings();
  }
  attachShortcutToGlobalWindow() {
    var _a;
    if (!this.settings) {
      log_error(new ModalFormError("Settings not loaded yet"));
      return;
    }
    const globalNamespace = this.settings.globalNamespace;
    if ((_a = this.settings) == null ? void 0 : _a.attachShortcutToGlobalWindow) {
      window[globalNamespace] = this.api;
    }
  }
  async setAttachShortcutToGlobalWindow(value) {
    this.settings.attachShortcutToGlobalWindow = value;
    this.attachShortcutToGlobalWindow();
    await this.saveSettings();
  }
  get validFormDefinitions() {
    return pipe2(
      this.settings.formDefinitions,
      A.filterMap((form) => form instanceof MigrationError ? O.none : O.some(form))
    );
  }
  async onload() {
    const settings2 = await this.getSettings();
    if (settings2.formDefinitions.length === 0) {
      settings2.formDefinitions.push(exampleModalDefinition);
    }
    settingsStore.set(settings2);
    this.unsubscribeSettingsStore = settingsStore.subscribe((s) => {
      console.log("settings changed", s);
      this.settings = s;
      this.saveSettings(s);
    });
    this.api = new API(this.app, this);
    this.attachShortcutToGlobalWindow();
    this.registerView(EDIT_FORM_VIEW, (leaf) => new EditFormView(leaf, this));
    this.registerView(MANAGE_FORMS_VIEW, (leaf) => new ManageFormsView(leaf, this));
    this.addRibbonIcon("documents", "Edit forms", (evt) => {
      this.manageForms();
    });
    this.addCommand({
      id: "new-form",
      name: "New form",
      callback: () => {
        this.createNewForm();
      }
    });
    this.addCommand({
      id: "manage-forms",
      name: "Manage forms",
      callback: () => {
        this.manageForms();
      }
    });
    this.addCommand({
      id: "create-note-from-form",
      name: "Create new note from a form",
      callback: () => {
        this.createNoteFromForm();
      }
    });
    this.addCommand({
      id: "edit-form",
      name: "Edit form",
      callback: async () => {
        new FormPickerModal(this.app, this.validFormDefinitions, (formToEdit) => {
          this.activateView(EDIT_FORM_VIEW, formToEdit);
        }).open();
      }
    });
    this.addCommand({
      id: "import-form",
      name: "Import form",
      callback: () => this.openImportFormModal
    });
    this.addSettingTab(new ModalFormSettingTab(this.app, this));
  }
  /**
   * Finds a unique name for a note, given a name.
   * It just adds a number at the end of the name if the name is already taken.
   * @param name the name of the note, without the extension
   * @returns a unique name for the note, full path including the extension
   */
  getUniqueNoteName(name, destinationFolder) {
    const defaultNotesFolder = this.app.fileManager.getNewFileParent("", "note.md");
    function makePath(name2, folder, suffix) {
      return `${folder || defaultNotesFolder.path}/${name2}${suffix ? "-" + suffix : ""}.md`;
    }
    let destinationPath = makePath(name, destinationFolder);
    let i = 1;
    while (file_exists(destinationPath, this.app)) {
      destinationPath = makePath(name, destinationFolder, i);
      i++;
    }
    return destinationPath;
  }
  /**
   * Checks if there are forms with templates, and presents a prompt
   * to select a form, then opens the forms, and creates a new note
   * with the template and the form values
   */
  createNoteFromForm() {
    const formsWithTemplates = pipe2(
      this.settings.formDefinitions,
      A.filterMap((form) => {
        if (form instanceof MigrationError) {
          return O.none;
        }
        if (form.template !== void 0) {
          return O.some(form);
        }
        return O.none;
      })
    );
    const onFormSelected = async (form, noteName, destinationFolder) => {
      const formData = await this.api.openForm(form);
      const newNoteFullPath = this.getUniqueNoteName(noteName, destinationFolder);
      const noteContent = executeTemplate(form.template.parsedTemplate, formData.getData());
      console.log("new note content", noteContent);
      this.app.vault.create(newNoteFullPath, noteContent);
    };
    const picker = new NewNoteModal(
      this.app,
      formsWithTemplates,
      ({ form, folder, noteName }) => {
        onFormSelected(form, noteName, folder);
      }
    );
    picker.open();
  }
};
